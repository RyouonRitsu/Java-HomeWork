[{"id":0,"href":"/Java-HomeWork/docs/OOP-LAB/","title":"Oop Lab","section":"Docs","content":"LAB -\u0026gt; 这个实验是每周都有的 #  不用太纠结于名字的问题，只需要知道这些东西每周都要写就行了\n（历史遗留\u0026hellip;）\n"},{"id":1,"href":"/Java-HomeWork/docs/OOP-LAB/LAB00/","title":"Lab00","section":"Oop Lab","content":"Lab00: 认识 Java #  1. 实验⽬的 #   掌握 Java 环境配置 使用 CMD 编译运行 Java 程序 使用 IDE 编译运行 Java 应用程序 理解 Java 语言中的关键字、标识符并能灵活使用 理解、掌握 Java 语言的简单数据类型并能灵活使用（重点强制类型转换） 理解引用数据类型，理解简单数据类型和引用数据类型的特点 理解、掌握 Java 语言中的运算符并能灵活使用 理解、掌握常量与变量的概念并能灵活使用  2. 编译与运行 #  Question01:\n借助身边的工具，学习 java， javac 等命令的使用，并尝试编译运行一个 Java 程序。\n2. Hello, World! #  Question02:\n学习一个新语言的第一步，自然是输出 Hello, World!。\n但是作为大二的学生，我们略微增加一点点难度 ~ 你需要输出很多 Hello, World!\n本题需要你实现一个 Test 类：\n  程序开始运行，进入main方法，并输出你的学号和姓名\n  当终端输入 QUIT 时，系统退出，并在终端打印一行字符：\n  ----- Good Bye! -----  对于其他的输入，在终端中输出一行 Hello, World!，等待下一行输入  你需要提交运行时的截图。\n程序退出 #  和 C 语言的return 0类似，Java 程序也有其退出码，整个程序的正常的退出码应该为 0，而不应该为-1、1 等。\n 在测评机中，退出状态非 0 则会被认为是程序未正常结束，很容易导致你的作业被错判，因此请务必注意在循环等进行程序退出时，确保退出状态为 0\n 下面给出 Java 中退出的一个例子：\nclass Example { \tpublic static void main(String[] args) { \tint x = 0;  \twhile (true) { \tx++; \tif (x \u0026gt; 100) { \tSystem.out.println(\u0026#34;get 100\u0026#34;); \tSystem.exit(0); \t} \t} \t} }  // 这只是退出程序的一种方法，当然，针对该例子，你也可以直接使用break，跳出while循环，直接到达整个程序的退出区域（默认退出状态为0） 参考实现 #   Java 打印字符串与其他语言有所区别，不是直接调用 print 函数，可以用如下语句：  String str = \u0026#34;Hello world!\u0026#34; System.out.println(str);  Java 连续读取输入行的一种实现：  Scanner in = new Scanner(System.in); String argStr; while (true) {  argStr = in.nextLine(); } 3. IDE 的使用 #  Question03:\n(1). 编写以下程序，并运行。将运行结果截图提交。\n(2). 将断点设置在第八行，查看变量 a 的值，提交此刻的屏幕截图。\npublic class HelloWorld {  public static void main(String[] args) {  System.out.println(\u0026#34;Hello World!\u0026#34;);  int a = 1;  a=a+1;  a=a+2;  System.out.println(\u0026#34;a is \u0026#34; + a);  a=a+3; //断点行  a=a+4;  System.out.println(\u0026#34;a is \u0026#34; + a);  } } 4. 基本数据类型 #  Question04:\n看程序输出结果,并提交结果内容或截图\npublic class App1 {  public static void main(String args[]) {  // 定义整形变量a和双精度浮点变量b、c  int a = 126;  double b = 0.2;  double c = 1.6;  // 创建字符串对象  String str1 = \u0026#34;Hello World\u0026#34;;   String str = new String(\u0026#34;字符串不是基本数据类型\u0026#34;);  // 输出各个变量  System.out.println(\u0026#34;a=\u0026#34; + a);  System.out.println(\u0026#34;b+c=\u0026#34; + (b + c));  System.out.println(\u0026#34;b+c=\u0026#34; + b + c);  System.out.println(str);  System.out.println(str1);  } } Question05:\n看程序输出结果,并提交结果内容或截图\npublic class VarDemo {  public static void main(String[] args) {  byte b = 0x55;  boolean B = true;  short s = 0x55ff;  int i = 1000000;  long l = 0xffffL;  char c = \u0026#39;c\u0026#39;;  float f = 0.23F;  double d = 0.7E-3;  String S = \u0026#34;This is a string\u0026#34;;  System.out.println(\u0026#34;字节型变量 b = \u0026#34; + b);  System.out.println(\u0026#34;短整型变量 s = \u0026#34; + s);  System.out.println(\u0026#34;整型变量 i = \u0026#34; + i);  System.out.println(\u0026#34;长整型变量 l = \u0026#34; + l);  System.out.println(\u0026#34;字符型变量 c = \u0026#34; + c);  System.out.println(\u0026#34;浮点型变量 f = \u0026#34; + f);  System.out.println(\u0026#34;双精度变量 d = \u0026#34; + d);  System.out.println(\u0026#34;布尔型变量 B = \u0026#34; + B);  System.out.println(\u0026#34;字符串对象 S = \u0026#34; + S);  } } Question06:\n编写一段代码验证 Java 中类的基本数据类型字段（成员变量）的默认初始化值，请按照对应类型的字面量填写。\n   基本类型 默认值 基本类型 默认值     byte  boolean    short  char    int  float    long  double     6. 三元运算符 #  Question07:\n看程序输出结果,并提交结果内容或截图\npublic class FindMinMax{  public static void main(String []args)  {  double temp, max, min;  double d1=1,d2=-9.9,d3=96.9;  temp=d1\u0026gt;d2?d1:d2;  temp=temp\u0026gt;d3?temp:d3;  max=temp;  temp=d1\u0026lt;d2?d1:d2;  temp=temp\u0026lt;d3?temp:d3;  min=temp;  System.out.println(\u0026#34;max=\u0026#34;+max);  System.out.println(\u0026#34;min=\u0026#34;+min);  } } 7. 短路 #  Question08:\n阅读下面这段代码：\n// ShortCircuit.java public class ShortCircuit {  static void print(String s) {  System.out.println(s);  }  static boolean test1(int val) {  print(\u0026#34;1\u0026#34;);  return val \u0026lt; 1;  }  static boolean test2(int val) {  print(\u0026#34;2\u0026#34;);  return val \u0026lt; 2;  }  static boolean test3(int val) {  print(\u0026#34;3\u0026#34;);  return val \u0026lt; 3;  }  public static void main(String[] args) {  boolean b = test1(0) \u0026amp;\u0026amp; test2(2) \u0026amp;\u0026amp; test3(2);  print(\u0026#34;b is \u0026#34; + b);  } } 运行 java ShortCircuit，程序的输出是什么？\n请解释 Java 执行串联逻辑运算时的流程，可以用文字、流程图、伪代码描述。\n思考如何利用短路这个机制来优化程序。\n8. 全局变量 #  Question09:\n看程序输出结果,并提交结果内容或截图\npublic class GlobalVar {  int a = 10; // 全局变量,下同  double b = 20;   public static void main(String[] args) {  GlobalVar globalVar = new GlobalVar();  System.out.println(\u0026#34;全局变量 a = \u0026#34; + globalVar.a);  // System.out.println(\u0026#34;全局变量 a = \u0026#34; +a); 错误写法  globalVar.print();  System.out.println(\u0026#34;全局变量变化后 a = \u0026#34; + globalVar.a);  }   public void print() {  System.out.println(\u0026#34;在print()中, 全局变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b);  a = 30;  System.out.println(\u0026#34;在print()中, 全局变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b);  } } 9. 局部变量 #  Question10:\n看程序输出结果,并提交结果内容或截图\npublic class LocalVar {  public static void main(String[] args) {  LocalVar localVar = new LocalVar();  // System.out.println(\u0026#34;局部变量 a = \u0026#34; + localVar.a); 引用错误，下同  localVar.print();  // System.out.println(\u0026#34;变化后的局部变量 a = \u0026#34; + localVar.a);  }   public void print() {  int a = 10; // 局部变量，下同  double b = 20;  System.out.println(\u0026#34;在print()中的局部变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b);  a = 30;  System.out.println(\u0026#34;在print()中的局部变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b);  } } "},{"id":2,"href":"/Java-HomeWork/docs/OOP-LAB/LAB01/","title":"Lab01","section":"Oop Lab","content":"Lab01: Java 语法 \u0026amp; 面向对象初步 #  1. 实验⽬的 #   掌握 Java 环境配置 使⽤ CMD 编译运⾏ Java 程序 使⽤ IDE 编译运⾏ Java 应⽤程序 理解 Java 语⾔中的关键字、标识符并能灵活使⽤ 理解、掌握 Java 语⾔的简单数据类型并能灵活使⽤（重点强制类型转换） 理解引⽤数据类型，理解简单数据类型和引⽤数据类型的特点 理解、掌握 Java 语⾔中的运算符并能灵活使⽤ 理解、掌握常量与变量的概念并能灵活使⽤ 理解、掌握 Java 语⾔的流程控制（重点 switch case break 语句）并能灵活使⽤ 理解、掌握 Java 语⾔的数组的声明、赋值及使⽤ 理解掌握面向对象思维方式，确定问题域，使用面向对象思维解决实际问题  2. Class 初步 #  Question01: 阅读下列 Java 源文件，并回答问题。\npublic class Person {  void speakHello() {  System.out.print(\u0026#34;您好，很高兴认识您\u0026#34;);  System.out.println(\u0026#34; nice to meet you\u0026#34;);  } }  class Xiti {  public static void main(String args[]) {  Person zhang = new Person();  zhang.speakHello();  } } （a）上述源文件的名字是什么？\n（b）编译上述源文件将生成几个字节码文件？这些字节码文件的名字都是什么？\n（c）在命令行执行 java Person 得到怎样的错误提示？执行 java xiti 得到怎样的错误提示？执行 java Xiti.class 得到怎样的错误提示？执行 java Xiti 得到怎样的输出结果？\nQuestion02: 编写程序输出自己的学号姓名，运行并截图。\n3. Unicode 编码 #  Question03: 看程序输出结果,并提交结果内容或截图\npublic class Unicode {  public static void main(String args[]) {  char c = \u0026#39;大\u0026#39;;  System.out.println(\u0026#34;\\\u0026#39;\u0026#34; + c + \u0026#34;\\\u0026#39;的Unicode编码：\u0026#34; + (int) c);  int num = 23398;  System.out.println(\u0026#34;Unicode编码为\u0026#34; + num + \u0026#34;的字符是：\u0026#34; + (char) num);  } } 4. 数组 #  Question04: 看程序输出结果,并提交结果内容或截图\npublic class UseIntArray {  public static void main(String[] args) {  int intArray[] = { 8, 9, 12,13,14};  int sum = 0;  for (int i = 0; i \u0026lt; intArray.length; i++)  sum += intArray[i];  for (int i = 0; i \u0026lt; intArray.length; i++)  System.out.println(\u0026#34;intArray[\u0026#34; + i + \u0026#34;]=\u0026#34; + intArray[i]);  System.out.println();  System.out.println(\u0026#34;sum=\u0026#34; + sum);  } } Question05: 看程序输出结果,并提交结果内容或截图:\nclass TwoDimensionArray {  public static void main(String args[]) {  int b[][] = { { 11 }, { 21, 22 }, { 31, 32, 33 } };  int sum = 0;  b[0][0] = 1000;  for (int i = 0; i \u0026lt; b.length; i++) {  for (int j = 0; j \u0026lt; b[i].length; j++)  sum += b[i][j];  }  System.out.println(\u0026#34;b[0][0]=\u0026#34; + b[0][0] + \u0026#39;\\n\u0026#39; + \u0026#34;sum=\u0026#34; + sum + \u0026#39;\\n\u0026#39;  + \u0026#34;b.lengh=\u0026#34; + b.length);   int arr1[][] = new int[3][4];  int arr2[][] = new int[3][];  int arr3[][] = { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } };  int i, j, k = 0;   // arr1[][]赋值  for (i = 0; i \u0026lt; 3; i++)  // arr1为3行4列  for (j = 0; j \u0026lt; 4; j++)  arr1[i][j] = k++;   // arr2[][]开辟内存空间  for (i = 0; i \u0026lt; 3; i++)  // arr2每一行是变长的，元素个数为3、4、5  arr2[i] = new int[i + 3];  // arr2[][]赋值  for (i = 0; i \u0026lt; 3; i++)  for (j = 0; j \u0026lt; arr2[i].length; j++)  arr2[i][j] = k++;   // 输出arr1  System.out.println(\u0026#34; arr1:\u0026#34;);  for (i = 0; i \u0026lt; 3; i++)  for (j = 0; j \u0026lt; 4; j++)  System.out.print(\u0026#34; \u0026#34; + arr1[i][j]);  System.out.println();   // 输出arr2  System.out.println(\u0026#34; arr2:\u0026#34;);  for (i = 0; i \u0026lt; 3; i++)  for (j = 0; j \u0026lt; arr2[i].length; j++)  System.out.println(\u0026#34; \u0026#34; + arr2[i][j]);   // 输出arr3  System.out.println(\u0026#34; arr3:\u0026#34;);  for (i = 0; i \u0026lt; 3; i++)  // arr3为3行3列  for (j = 0; j \u0026lt; 3; j++)  System.out.print(\u0026#34; \u0026#34; + arr3[i][j]);  } } 5. switch #  Question06: 阅读下面程序，给出程序的输出结果，为什么？\npublic class E {  public static void main (String args[ ]) {  char c = \u0026#39;\\0\u0026#39;;  for(int i=1;i\u0026lt;=4;i++) {  switch(i) {  case 1: c = \u0026#39;J\u0026#39;;  System.out.print(c);  case 2: c = \u0026#39;e\u0026#39;;  System.out.print(c);  break;  case 3: c = \u0026#39;p\u0026#39;;  System.out.print(c);  default: System.out.print(\u0026#34;好\u0026#34;);  }  }  } } 6. 循环 #  Question07: 请实现程序输出以下 5*5 数字方格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 需要在 main 函数的输入参数中设置 5，输出 5*5 的数字方格。如果是输入 7，则是 7*7 的数字方格。需要提交代码及运行结果截图。\nQuestion08: 请实现程序输出以下星塔.\n需要在 main 函数的输入参数中设置 5，输出 5 层星塔。如果是输入 7，则输出 7 层星塔。假设输入参数都是奇数，且都大于等于 5，小于等于 11，提交代码及运行结果截图。\n *  *** *****  ***  * Question09: 编写静态方法 double getPi(int n)，利用公式$\\pi = 4\\sum_{i=0}^{n}{\\frac{\\left(-1\\right)^{i}}{2i+1}}$，求 pi 的近似值，需求如下\n/** * 利用公式\\pi = 4\\sum_{i=0}^{n}{\\frac{\\left(-1\\right)^{i}}{2i+1}}求指定精度的圆周率 * 如果n是负数，视其为0 * @param n 公式中的i的上限 * @return 圆周率的近似值 */ public static double getPi(int n); 题外话：\n如果 n 是负数，视其为 0\n有穷求和的区间是闭区间，上限 n 对应的级数项也是要被计算的。\nQuestion10: 快速排序\n编写静态方法int[] qsort(int[] arr)，需求如下：\n /** * 对一个int数组进行快速排序，结果是升序的，并且不会开辟额外的数组空间 * @param arr 待排序的数组 * @return 升序排列好的arr，如果arr==null，则返回null */  public static int[] qsort(int[] arr); 约束：\n返回值必须是原数组，即 return arr。\n可以任意次创建指向原数组的引用，但是请不要在排序过程中创建新的数组。\n可以根据需要定义新的函数。\n如果数组是 null，返回 null。\n对于空数组(arr.length==0)，原样返回，而不是 null。\n这一次请不要使用 java.util.Array.sort()之类的操作。\nQuestion11: 现有一组数据分别是：12,45,67,89,123,-45,67，实现以下两步：\n(1) 请对这组数据排序后，按照从小到大的顺序打印；\n(2) 从键盘输入任意整数，程序判断该整数是否存在该数组中；\nQuestion12: 阅读下面代码并查看输出结果\npublic class ForInString {  public static void main(String[] args) {  for(char c : \u0026#34;An African Swallow\u0026#34;.toCharArray())  System.out.print(c + \u0026#34; \u0026#34;);  } } 7. 引用 #  Question13: 阅读下面这段代码：\nclass Point {  int x,y;  void setXY(int m,int n){  x = m;  y = n;  } } public class Example {  public static void main(String args[]) {  Point p1,p2;  p1=new Point();  p2=new Point();  System.out.println(\u0026#34;p1的引用:\u0026#34;+p1);  System.out.println(\u0026#34;p2的引用:\u0026#34;+p2);  p1.setXY(1111, 2222);  p2.setXY(-100, -200);  System.out.println(\u0026#34;p1的x,y坐标:\u0026#34;+p1.x+\u0026#34;,\u0026#34;+p1.y); // 1  System.out.println(\u0026#34;p2的x,y坐标:\u0026#34;+p2.x+\u0026#34;,\u0026#34;+p2.y); // 2  p1 = p2;  p1.setXY(0, 0);  System.out.println(\u0026#34;p1的引用:\u0026#34;+p1);  System.out.println(\u0026#34;p2的引用:\u0026#34;+p2);  System.out.println(\u0026#34;p1的x,y坐标:\u0026#34;+p1.x+\u0026#34;,\u0026#34;+p1.y); // 3  System.out.println(\u0026#34;p2的x,y坐标:\u0026#34;+p2.x+\u0026#34;,\u0026#34;+p2.y); // 4  } } 请指出代码中注释标注出的四行输出的内容会是什么。\n题外话：\n意在理解 Java 对象实例是作为引用存在的。\n如果你要为一个类实现 copy() 方法，思考如何避免引用间赋值导致的浅拷贝？或者说，如何确保进行的是深拷贝。你需要查一下什么是浅拷贝？什么是深拷贝？\n同样的问题也存在于 String 的 == 和 equals() 方法，对于不同的背景，相等的定义可能也不同。\nQuestion14: 阅读下面程序，给出程序的输出结果，为什么？\npublic class Test{  public static void main(String args[]) {  int a[]={1,2,3,4};  int b[]={100,200,300};  System.out.println(\u0026#34;数组a的元素个数=\u0026#34;+a.length);  System.out.println(\u0026#34;数组b的元素个数=\u0026#34;+b.length);  System.out.println(\u0026#34;数组a的引用=\u0026#34;+a);  System.out.println(\u0026#34;数组b的引用=\u0026#34;+b);  a=b;  System.out.println(\u0026#34;数组a的元素个数=\u0026#34;+a.length);  System.out.println(\u0026#34;数组b的元素个数=\u0026#34;+b.length);  System.out.println(\u0026#34;a[0]=\u0026#34;+a[0]+\u0026#34;,a[1]=\u0026#34;+a[1]+\u0026#34;,a[2]=\u0026#34;+a[2]);  System.out.print(\u0026#34;b[0]=\u0026#34;+b[0]+\u0026#34;,b[1]=\u0026#34;+b[1]+\u0026#34;,b[2]=\u0026#34;+b[2]);  } } 8. 可变参数 #  Question15: 看程序输出结果,并提交结果内容或截图:\npublic class E {  public static void main(String args[]) {  f(1,2);  f(-1,-2,-3,-4); //给参数传值时，实参的个数很灵活  f(9,7,6) ;  }  public static void f(int ... x){ //x是可变参数的代表，代表若干个int型参数  for(int i=0;i\u0026lt;x.length;i++) { //x.length是x代表的参数的个数  System.out.println(x[i]); //x[i]是x代表的第i个参数(类似数组)  }  } } Question16: 编写静态方法String strscat(String... args)，需求如下：\n/** * 将任意个字符串顺序连接，不应该改变任意一个原有参数 * @param args 字符串们 * @return args中的字符串顺序连接组成的新字符串 */ public static String strscat(String... args); 样例：\n   调用方法 返回值     strscat(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;e\u0026rdquo;) \u0026ldquo;abce\u0026rdquo;   strscat(\u0026ldquo;str\u0026rdquo;) \u0026ldquo;str\u0026rdquo;    回答：\n请尝试理解 Java 可变参数的实现机制。\n调用strscat(new String[]{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;})能通过编译吗？\n如果还有静态方法String strscat(String[] args)同时存在，代码能编译通过吗？这时传入的参数是什么？又会返回什么？\n如果我们声明的是String strscat(String[] args)，strscat()这样的调用还能通过编译吗？如果能，这时传入参数和返回值的情况和String strscat(String... args)通过相同吗？\n9. 面向对象（复习并完成课堂知识点） #  Question17: 减肥。小王本来体重 70Kg，经过减肥，体重降到 45Kg，试从这个问题领域中识别对象、类、属性、行为、状态，和状态变化。尝试将你抽象出来的类用 Java 代码实现出来，并编写一个测试类，来描述上述过程。\nQuestion18: 制作一桌丰盛的年夜饭。定义采购员类和厨师类的属性和行为，在测试类中产生采购员的对象：姑姑，妈妈和你，在测试类中产生出厨师的对象：爸爸和婶婶，协同制作年夜饭。\n"},{"id":3,"href":"/Java-HomeWork/docs/OOP-LAB/LAB02/","title":"Lab02","section":"Oop Lab","content":"Java 程序设计 Lab02 #  实验目的 #   理解并掌握类的概念 理解并掌握对象的概念 理解类与对象的关系 理解面向对象中抽象过程 理解面向对象中的消息 理解 Java 程序的基本结构并能灵活使用 理解并掌握 Java 类的定义（成员变量、成员方法和方法重载） 理解并掌握 Java 类的构造函数（默认构造函数、带参数构造函数），理解重 载的构造函数并灵活使用 理解 Java 垃圾内存自动回收机制 理解并掌握 Java 类变量和类方法  实验题目 #  Question1: 简答题 #  编译下面这个类：\npublic class Sample {  int x; // 1  long y = x; // 2  public void f(int n) {  int m; // 3  int t = n + m; // 4  }  public static void main(String[] args) {  Sample t=new Sample();  t.f(5);  System.out.println(t.x);  } } 注释标记的哪些行会导致编译错误，为什么?\nQuestion2: 简答题 overload #  阅读下面代码：\npublic class Overload{  Overload(int m){}  Overload(double m){}  int Overload(int m){return 23;}  void Overload(double m){} } 对于Overload类，下面哪些叙述是错误的，为什么错？\n a. Overload(int m)与Overload(double m)互为重载的构造方法。 b. int Overload(int m)与void Overload(double m)互为重载的非构造方法。 c. Overload类有 2 个构造方法，尝试调用默认构造方法Overload()会无法通过编译。 d. Overload类有 3 个构造方法。  Question3: 简答题 overload2 #  阅读下面这段代码：\npublic class Overload2 {  int a,b;  int c=-1;  public Overload2(){a=-2;}  public Overload2(int p1,int p2){a=p1; b=p2;}  public Overload2(int p1,int p2,int p3){  this(p1,p2);  c=p3;  }   @Override  public String toString(){  return String.format(\u0026#34;(a,b,c)=(%d,%d,%d)\u0026#34;,a,b,c);  }  public static void main(String args[]){  Overload2 s = new Overload2();  System.out.println(s);  System.out.println(new Overload2(5,6));  System.out.println((new Overload2(2,3,4)).toString());  }  } 运行java Overload2，程序的输出是什么？\n题外话：\n根据void java.io.PrintStream.print()系列函数的实现，当传入的 String 或 Object 是 null 时，最后都会导致输出字符串”null”，而不是什么都不输出。\n进行字符串连接时也一样：\u0026quot; \u0026quot; + null 的结果是 \u0026quot;null\u0026quot;。\n因此当涉及相关操作时需要稍微注意一下。\n具体原因参见java.io.PrintStream、java.lang.String的源代码。\nQuestion4: 简答题 finalize #  阅读下面这段代码：\npublic class User {  public static int userCount = 0;  public User() {  ++userCount;  }   @Override  protected void finalize() throws Throwable {  super.finalize();  System.out.println(\u0026#34;bye\u0026#34;);  --userCount;  }  public static void main(String[] args) {  System.out.println(User.userCount); // 1  User u = new User();  System.out.println(User.userCount); // 2  u = null;  System.out.println(User.userCount); // 3  System.gc();  System.out.println(User.userCount); // 4  } } 注意代码中用注释标出的四行System.out.println(User.userCount)，某些行的输出结果有多种可能。\n运行java User，程序的输出可能是什么？\n 你需要在 answer.md 中说明如下内容\n    注释标记行 可能的输出内容     1    2    3    4     有什么办法可以让finalize()在main()结束前一定被调用吗？\n题外话：\n和 C++不同，在 Java 中显式重写 finalize() 通常是不必要的。\njava.lang.System.gc()只会在需要的时候执行垃圾收集，你的调用只是一个“建议”。\nQuestion5: 编程题 #  写一个音乐类，并编写测试类显示音乐信息（音乐名称、音乐类型）。\n写一个手机类，并编写测试类显示手机信息（手机品牌、手机型号）\n你需要在 answer.md 中说明如下内容\n目录名为：Question5 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置)   唠叨两句：\n手机类和音乐类都需要完成 “显示信息” 这样的功能，那我们能否将这一功能封装起来实现呢？\n比如我们可以让手机类和音乐类都实现一个 IMessage 接口， 他们就有了统一的测试方法：\nclass Test {  public static void main(String args[]) {  IMessage music = new Music();  IMessage mobile = new Mobile();  music.print()  mobile.print()  } } 当然，在这个题中，使用这样的实现方式未免有点 “过度封装”。\n如果之后完成个人 / 团队大作业时遇到了类似的场景，不妨在想一想能否应用上述的模式进行设计。\nQuestion6: 编程题 #  编写程序,在其中定义两个类：\n Person 类：  属性有 name、age 和 sex 提供你认为必要的构造方法 方法 setAge() 设置人的合法年龄 (0~130) 方法 getAge() 返回人的年龄 方法 work() 输出字符串“working” 方法 showAge() 输出 age 值   TestPerson 类：  创建 Person 类的对象，设置该对象的 name、age 和 sex 属性 调用 setAge() 和 getAge() 方法，体会 Java 的封装性。 创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。    你需要在 answer.md 中说明如下内容\n目录名为：Question6 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置)   Question7: 编程题 #  编写一个 Java 命令行程序，只从标准输入读取一行用户输入，判断这行输入是否是一个没有前导 0 的无符号整数；如果是，则还要判断该数字是否是一个回文数。输出你的判断和执行结果。\n对于“没有前导 0 的无符号整数”的定义：\n 是一个字符串 s s 的长度至少是 1，没有上限要求 s 的字符集 Σ={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}，其他所有字符都不应该出现在 s 中 当 s 的长度大于 1 时，若从其首部开始有若干个连续字符 0，那么这些字符 0 都叫做 s 的“前导 0”  比如数字串 00010020，有三个前导 0 比如数字串 01，有 1 个前导 0 比如数字串 102030，没有前导 0 比如数字串 0，没有前导 0    本题对于回文数的定义：\n 是一个字符串 s s 的长度至少是 1，没有上限要求 s 的字符集 Σ={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}，其他所有字符都不应该出现在 s 中 将 s 中的字符逆序排列并去除前导 0 得到的数字串 r，有 s 和 r 完全相同  s=123 时，r=321，不相同，s 和 r 都不是回文数 s=12321 时，r=12321，相同，s 是回文数 s=12100 时，r=121，不相同，s 不是回文数，但 r 是回文数 s=1 时，r=1，相同，s 是回文数 s=0 时，r=0，相同，s 是回文数    本题将输入的一行字符视为一个完整的字符串，如果输入的是诸如“121 121”这样包含空格的串，虽然 121 是回文数，但是整个串不应该被认为是回文数。如果将字符集扩充为包含空格的其他字符集，那么“121 121”就是一个该字符集下的回文串，不过本题的字符集限定为由 0~9 这十个数字组成的字符集。\n你需要在 answer.md 中说明如下内容\n目录名为：Question7 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置)   "},{"id":4,"href":"/Java-HomeWork/docs/OOP-LAB/LAB03/","title":"Lab03","section":"Oop Lab","content":"Java 程序设计 LAB03 #  实验目的 #   理解封装含义 理解信息隐藏的必要性 掌握访问控制修饰符的使用  私有成员（变量和方法）的理解和使用 共有成员的理解和使用 保护成员的理解和使用 使用不加任何权限修饰符的成员   加深对“类和对象”的理解  注意事项 #  建议建立一个自己的统一且良好的代码风格，比如命名风格（camelCase、snake_case 等）、缩进方式（空格数量、switch-case 缩不缩进等）、开闭大括号换不换行等容易引发战 争（迫真）的东西，以养成良好的编程习惯。\n编程题最好为每一个类编写一个完备的测试类，覆盖尽可能多的输入、函数调用、输出，以证明代码正确实现了功能。\n如果编程题使用了 package 语句，应当确保提交时目录结构和 package 语句表达的包结构相同。（IDE 很多时候会帮你做）\n编程题在给出了具体需求的情况下，可以根据自己的需要添加额外的方法。\n实验题目 #  初始化 I #  阅读下面这段代码，尝试理解 Java 中初始化的顺序：\nclass A {  int value;  static A a1 = new A(1);  public A(int i) {  System.out.println(\u0026#34;initialize A\u0026#34;+i);  value = i;  }   public A(A a) {  System.out.println(\u0026#34;copy from A\u0026#34;+a.value);  value = a.value;  }  static A a2 = new A(2);  }  class B {  A a8;  // A a7 = new A(a6);  A a6 = new A(6);  static A a3 = new A(3);  static A a4;  static {  a4 = new A(4);  }  static A a5 = new A(5);   public B(int i) {  System.out.println(\u0026#34;initialize B\u0026#34;+i);  a8 = new A(8);  }  A a7 = new A(a6); }  public class Initialization {  static B b1 = new B(1);  static B b2;  public static void main(String[] args) {  System.out.println(\u0026#34;main begins\u0026#34;);  A a9 = new A(9);  b2 = new B(2);  System.out.println(\u0026#34;main ends\u0026#34;);  } } Question1 #   阅读这段代码，请问程序的输出是什么？\n Question2 #  对于非静态属性，它的初始化方法有两种：\n 在属性定义处显式初始化（如本例中的 a6）； 在构造方法或非静态方法中初始化（如本例中的 a8）；   这段代码能够证明“在属性定义处初始化的属性，比在方法中初始化的属性先被初始化”吗？\n  这段代码能够证明“在属性定义处初始化的属性，初始化顺序等同于他们在类定义中出现的顺序”吗？\n Question3 #   请尝试仿照 Q2 的内容，描述静态属性的初始化方式和实际初始化时的顺序。\n Question4 #   已知 static 属性的初始化、static 块的执行，只在 JVM 进行类加载的时候执行。这段代码能够证明 “在类的实例第一次被构造、或类的静态属性和静态方法第一次被访问时，JVM 会执行类加载”吗？如果不能，请尝试修改代码并证明。\n 题外话 #  懒加载：lazy load，对某资源只在需要时才寻找其存在并初始化；对立面是预加载。\n预加载：提前加载好所有资源，等待使用资源的那一刻。\n对于一些使用频率较低但初始化开销很大的资源，懒加载可以避免他们给程序的初始化增加过多的负担。\nJVM 的类加载是懒加载，只有在程序第一次使用到某个类时才去尝试读取其.class 文件。类加载只会进行一次，这一次类加载会完成所有的静态初始化工作。更多内容会在后续课程讲解 RTTI 和反射的时候提到。\n在游戏编程中，当某一个类的所有实例都使用同一批贴图文件时，可以将贴图资源声明为 static 属性并直接（或在 static 块）初始化。让类的贴图属性引用这些静态资源，这样就可以避免为每一个对象构造单独的贴图文件导致的内存浪费和时间浪费。\n单例模式 #  阅读下面这段代码，它实现了经典设计模式之一————单例模式（singleton pattern）：\n/** * Singleton 一个最简单的单例模式的实现 */ public class Singleton {  private static Singleton uniqueInstance = new Singleton();   private Singleton() {  }   public static Singleton getInstance() {  return uniqueInstance;  }   public void foo() {  System.out.println(\u0026#34;Aha!\u0026#34;);  } } Question5 #   其他的外部类可以通过new Singleton()来构造一个新的Singleton变量吗？\n Question6 #   本题给出的 Singleton 类的写法被称为单例模式，是因为这个类最多只可能有 1 个实例同时存在。为什么只可能有 1 个？这个唯一的实例在什么时候被构造？\n Question7 #   请写出任意一种外部类调用 Singleton 类的 foo()的方法。\n 题外话 #  这里的 uniqueInstance 初始化方法不是懒加载（lazy load）的，因为 uniqueInstance 在类加载时就被初始化了，虽然我们可能最终并用不到它。你可以思考一下如何实现一个懒加载的单例模式。\n"},{"id":5,"href":"/Java-HomeWork/docs/OOP-LAB/LAB04/","title":"Lab04","section":"Oop Lab","content":"Java 程序设计 LAB04 #  实验目的 #   理解继承的必要性 理解继承的基本概念：单继承，多继承 掌握继承的使用  子类属性、构造方法和一般成员方法的书写的编写 变量隐藏 this 和 super 的使用 向上映射 在继承的基础上加深理解权限控制符的使用 保护成员的使用 方法覆盖（初步，重点放在多态一章）   复合与继承的区别及使用  注意事项 #  建议建立一个自己的统一且良好的代码风格，比如命名风格（camelCase、snake_case等）、缩进方式（空格数量、switch-case 缩不缩进等）、开闭大括号换不换行等容易引发战争（迫真）的东西，以养成良好的编程习惯。编程题最好为每一个类编写一个完备的测试类，覆盖尽可能多的输入、函数调用、输出，以证明代码正确实现了功能。如果编程题使用了 package 语句，应当确保提交时目录结构和 package 语句表达的包结构相同。（IDE 很多时候会帮你做）编程题在给出了具体需求的情况下，可以根据自己的需要添加额外的方法。\n 大家可以在 vscode、IDEA 等 ide 上找到对应的代码风格检查工具，也可以自己设置自己的代码风格文件，可自行搜索了解 例如： vscode 插件 checkstyle\n 实验题目 #  Question1. Package #  浏览 Code 文件夹中的 Question01 目录，不允许变更目录结构和文件位置，只允许在文件中添加 package 和 import 语句，使根目录下 build 和 test 文件中的指令可以无报错顺利执行。\nQuestion2. 权限 #  阅读 Code 文件夹中的 Question02 目录，根据你对访问权限的理解。将文件中所有无法通过编译的语句注释掉。\n你遇到的问题可能会集中在 protected 和默认访问权限。 从这次实验和上一次实验，可以引申出几个问题：\n LAB03 中的单例模式，或者说所有构造方法都是 private 时，可能有子类吗？ final 类可以视为所有构造方法都是 private 的类吗？  题外话：\n如果不知道怎么编译和运行，参见第一题\nQuestion3. Hide \u0026amp; Override #  阅读：\nclass Parent {  int num = 4;   protected void foo() {  System.out.println(\u0026#34;foo() of Parent\u0026#34;);  }   static protected void bar() {  System.out.println(\u0026#34;bar() of Parent\u0026#34;);  } }  class Child extends Parent {  int num = 5;   protected void foo() {  System.out.println(\u0026#34;foo() of Child\u0026#34;);  }   static protected void bar() {  System.out.println(\u0026#34;bar() of Child\u0026#34;);  } }  public class Test {  public static void main(String[] args) {  Parent f1 = new Parent();  System.out.println(f1.num);   Parent f2 = new Child();  System.out.println(f2.num);   Child c = new Child();  System.out.println(c.num);   f1.foo();  f2.foo();  c.foo();   f1.bar();  f2.bar();  c.bar();  } } a. 执行 java Test，程序的运行结果是什么？ b. 如果将子类的 protected void foo()改为默认访问权限，程序还能通过编译吗？ c. 如果将子类的 protected void bar()改为默认访问权限，程序还能通过编译吗？ d. foo 和 bar 的测试输出结果表现一致吗？ e. 属性、静态方法、非静态方法，哪些可以覆盖（重写、override），哪些可以隐藏？\n题外话：\n在想要覆盖的时候，主动写一个@Override 注解，可以提高代码可读性，也可以防止你想要覆盖但是写成了重载的情况发生。不想让父类方法在子类中被覆盖的时候，将父类方法声明为 final 的\nQuestion4. shape #  阅读下面的二维形状类 Shape 的描述：\npublic abstract class Shape {  protected double a;  protected double b;   public Shape() { this(0.0, 0.0); }  public Shape(double a, double b) {  this.a = a;  this.b = b;  }   /** calcArea * 计算形状的面积 * @return 面积 */  abstract public double calcArea();   /* 其他必要的方法，比如 getter 和 setter */ } 你的任务是：\n 编写 Rectangle 类，a 和 b 分别代表矩形两条边的长度（长和宽）； 编写 Rhombus 类，a 和 b 分别代表两条菱形对角线的长度； 编写 Ellipse 类，a 和 b 分别代表椭圆两个半轴（半长轴和半短轴）的长度； 编写一个测试类，构造子类对象并测试  注意：\n 上述三个类都继承自 Shape 类，都必须要 override 方法 calcArea； a 和 b 都不能是负数，当通过 constructor 或者 setter 设定为负数时，将对应的值 置为 0.0，或 throw 异常； a 和 b 的大小关系没有任何约束，没有“a 必须不小于 b”的说法。  题外话：\n我们知道属性不设置为 public 是为了保护数据，如果 a 和 b 在 Shape 中的访问权限被设置为 private，在不添加新的属性的情况下，子类想要实现自己的 calcArea()该怎么办？\nQuestion5. 车车 #  定义一个 Vehicle 类，在其中声明一个属性代表这个交通工具有多少个轮子，提供对这个属性的 setter。提供轮子类、引擎类。创建几个 Vehicle 的导出类：Motorbike、Car、Tank。自由发挥，在测试类中构造这几种交通工具，并测试功能。\n其中Motorbike类需增加两个属性：driver、passenger表示司机和乘客。增加你觉得合适的方法。\n定义一个Person类，加入你觉得合适的属性和方法，生成brother和sister两个对象，结合Motorbike试图实现以下场景：\n 生成三个对象（Motorbike实例mb、brother、sister） 设置mb的司机与乘客为brother和sister 打印mb的格式化信息（尽可能详细） 调用sister的say()方法，输出“不像我，我只会心疼geigei~”  Question6. 其实 OOP Lab 里面也可以写操作系统 #  操作系统中，有一个概念叫做文件系统。以 Windows 为例，其文件系统中的文件可以粗略地分为以下几种：\n 文件夹（包含一个子目录） 快捷方式（打开它等价于打开其所指向的文件） 可执行文件（.exe 这种不需要借助其他程序就能直接运行的文件） 不可执行文件（本身无法运行，需要借助其他程序（打开方式）才能正确使用）  以上四种，都是“文件”。所有文件的属性都有：\n 名称（不能为空，字符集是 ASCII 可打印字符） 创建时间（年月日时分秒） 大小（以 byte 为单位，是整数） 内容（字节序列） 位置（直接包含此文件的文件夹）  文件夹：\n 不考虑 OS 层面的内存对齐，文件夹的大小等于其内部所有文件的大小的加和； 文件夹的额外属性是，他的直接子目录中包含的文件夹数和其他文件数； 打开文件夹，会切换当前的工作路径到该文件夹下，初始工作路径我们认为是 C 盘； 可以在文件夹中添加新的文件；\n 快捷方式：\n 本质是一个类型为.lnk 的文件； 快捷方式的额外属性是其指向的文件（可以是任何文件，包括快捷方式和文件夹）； 打开快捷方式，等价于打开其指向的文件；指向的文件被删除后，无法打开快捷方式； 注意，快捷方式的所有属性，都代表其本身，不代表其指向的文件；\n 可执行文件：\n 打开就是运行其内容。\n 不可执行文件：\n 没有给出打开方式的情况下，无法被正确打开。\n 任务：\n抽象出上述文本中的属性、方法、继承和组合信息，编写多个类描述上述关系。 不用实现很具体的功能，甚至不用实现可以运行的程序。但是不能有逻辑硬伤和编译错误。\n题外话：\n你可能需要回忆一下 C 中的结构体，学习一下 Java 中的 enum 类\n"},{"id":6,"href":"/Java-HomeWork/docs/OOP-LAB/LAB05/","title":"Lab05","section":"Oop Lab","content":"Java 程序设计 LAB05 #  实验目的： #   理解静多态和动多态的概念 理解多态的必要性和实现机制 理解并灵活使用方法重载和方法覆盖 理解并灵活使用抽象类和抽象方法 理解接口的必要性（将接口用作 API） 掌握如何定义接口、实现接口 将接口用作类型、使用接口回调 理解并掌握接口的继承 面向接口的编程 简单了解 Object 类 掌握良好重写 Object 类中方法的能力  实验题目 #  Question01 多态 1 输出/简答题 #  阅读下面这段代码：\n// Test.java class PrivateOverride {  private void f() { \tSystem.out.println(\u0026#34;private f()\u0026#34;);  }   public static void main(String[] args) { \tPrivateOverride po = new Derived(); \tpo.f();  } }  class Derived extends PrivateOverride {  public void f() { \tSystem.out.println(\u0026#34;public f()\u0026#34;);  } }  public class Test {  public static void main(String[] args) { \tPrivateOverride.main(args);  } }  运行 java Test，程序的输出是什么？ 如果将父类中的方法声明为 public，而子类为 private，编译能通过吗？如果能，最后 会输出什么？  题外话： #  private 方法被默认是 final 的\nQuestion02 多态 2 输出/简答题 #  阅读下面这段代码：\n// Test.java class Super {  public int field = 0;   public int getField() { \treturn field;  } }  class Sub extends Super {  public int field = 1;   public int getField() { \treturn field;  }   public int getSuperField() { \treturn super.field;  } }  public class Test {  public static void main(String[] args) { \tSuper sup = new Sub(); // Upcast \tSystem.out.println(\u0026#34;sup.field = \u0026#34; + sup.field + \t\u0026#34;, sup.getField() = \u0026#34; + sup.getField()); \tSub sub = new Sub(); \tSystem.out.println(\u0026#34;sub.field = \u0026#34; + sub.field + \t\u0026#34;, sub.getField() = \u0026#34; + sub.getField() + \t\u0026#34;, sub.getSuperField() = \u0026#34; + sub.getSuperField());  } }  运行 java Test，程序的输出是什么？ 类的非静态属性能体现多态性吗？  Question03 多态 3 输出/简答题 #  阅读下面这段代码：\n// Test.java class StaticSuper {  public static String staticGet() { \treturn \u0026#34;Base staticGet()\u0026#34;;  }   public String dynamicGet() { \treturn \u0026#34;Base dynamicGet()\u0026#34;;  } }  class StaticSub extends StaticSuper {  public static String staticGet() { \treturn \u0026#34;Derived staticGet()\u0026#34;;  }   public String dynamicGet() { \treturn \u0026#34;Derived dynamicGet()\u0026#34;;  } }  public class Test {  public static void main(String[] args) { \tStaticSuper sup = new StaticSub(); // Upcast \tSystem.out.println(StaticSuper.staticGet()); \tSystem.out.println(sup.dynamicGet());  } }  运行 java Test，程序的输出是什么？ 类的静态属性和静态方法能体现多态性吗？  Question04 多态 4 输出/简答题 #  阅读下面这段代码：\n// Test.java class A {  void draw() { \tSystem.out.println(\u0026#34;A.draw()\u0026#34;);  }   A() { \tSystem.out.println(\u0026#34;A() before draw()\u0026#34;); \tdraw(); \tSystem.out.println(\u0026#34;A() after draw()\u0026#34;);  } }  class B extends A {  private int b = 1;   B(int b) { \tthis.b = b; \tSystem.out.println(\u0026#34;B(), b = \u0026#34; + this.b);  }   void draw() { \tSystem.out.println(\u0026#34;B.draw(), b = \u0026#34; + this.b);  } }  public class Test {  public static void main(String[] args) { \tnew B(5);  } }  运行 java Test，程序的输出是什么？ 结合之前实验的初始化顺序和多态，给出程序这样输出的解释。  Question05 ShapeFactory 1 编程题 #  在 LAB04 的 Shape 的基础上，实现一个满足如下需求的 ShapeFactory 类：\n 提供一个 ShapeType 的枚举类，其中有表示矩形、菱形、椭圆的枚举量； 具有方法 public Shape makeShape(ShapeType type, double a, double b) ，返回 一个由 type 指定类型，a 和 b 指定大小的形状；  参数不合法时，返回 null 或抛出异常   具有方法 public Shape randomNextShape() ，返回一个随机类型，随机大小的形状；  随机得到的形状要合法 不能随机出来 null    编写测试类：\n 使用以上的两种生成形状的方式，分别随机生成五个形状并存储到 Shape 类型的 数组（或其他容器）中，最后使用 foreach 循环将他们的面积输出  注意：不能修改上一次的 Shape。\n题外话： #  这题不是设计模式中的工厂方法模式（factory method pattern）。本题中的工厂，如果你为 Shape 添加了一个新的子类（比如直角三角形类），那么你就需要给 ShapeType 添加新的枚举量，还要重新写 makeShape 和 randomNextShape。\nQuestion06 Overload？Override？ 简答题 #  阅读下面这段代码：\n// Test.java interface I0 {  void f(); // 默认是 abstract public 的 }  interface I1 {  void f(); }  interface I2 {  int a = 2; // 默认是 static public final 的   int f(); }  interface I3 {  int a = 3;   int f(int i); }  interface I4 {  void f(int i); }  class Test01 implements I0, I1 {  @Override  void f() {  } }  class Test02 implements I0, I2 {  @Override  void f() {  }   @Override  int f() { \treturn 0;  } }  class Test23 implements I2, I3 {  @Override  int f() { \treturn a;  }   @Override  int f(int i) { \treturn i;  } }  这段程序是无法通过编译的，都有哪些原因呢？尝试从继承、覆盖、重载的角度考虑。 如果 I1 extends I0，会引入新的错误吗？I2、I3 也 extends I0 呢？  题外话： #   在任何支持多重继承的语言中，多个父类拥有相同的函数名都会带来误会，如果不是万不得已，千万不要这么做。 还有更多复杂的情况：  比如 class B extends A implements I 比如 class A implements I1，class B extends A implements I2 更多情况请自行尝试并理解。    附加题 #   附加题可以在时间不充足时先略过，但请务必在完成作业期间或者完成后完成一遍，附加题包括的知识点并不重复，甚至更为重要，放到附加题不代表这些题是不重要的\n话句话说， 你在提交实验报告的时候， 可以不完成下面的题目。\n只要完成了基础的 6 个题目，即可拿到本次实验的全部分数\n Extra 1 策略模式（Strategy Pattern） 编程题 #  如果一些方法只保留了业务中逻辑固定不变的部分，只依据参数的不同来产生不同的行为，符合这样的方法，就是符合策略模式（Strategy Pattern）。\n接口经常用于策略模式。定义 interface ITextProcess：\n 具有方法 String process(String s)  利用 interface ITextProcess 完成几个类：\n class Splitter，其 process 方法将 s 中的所有空格都去掉。 class UpperCaseProcessor，其 process 方法将 s 中的所有字符都变为大写的。 class SnakeCaseProcessor，其 process 方法将 s 转变为 snake_case  snake_case 指的是不用空格而用下划线分隔单词 I hate ddl -\u0026gt; I_hate_ddl have a good time -\u0026gt; have_a_good_time    编写测试类：\n 提供方法public static void process(ITextProcess p, String s)，在其中使用 p 处理 s，并输出处理结果 在 main 中测试你的功能  题外话： #  本题中，业务逻辑不变的是使用一个文本处理器处理文本，变化的是使用的处理器和文本内容。测试类的 process 方法是符合策略模式的。这样可以保证也实现了 ITextProcess 的类在添加到系统时，无需对原有代码产生影响，在这种情况下，保证了原有代码的可复用性。interface 在这里的作用，就是定义一个标准，定义一种框架。如果没有 interface，那么我们就需要像第五题的 ShapeFacotry 一样，通过参数指定处 理器的类型，为原有代码增加更多的特殊情况判断。\n使用 interface 而不使用继承的另一个原因是：现实场景下，Splitter 等可能需要继承其他类，而 TextProcess 并没有必须要有的属性，所以没有必要让他们都继承一个 abstract class TextProcessor。如果出现了不得不同时继承多个类的情况，后续实验会提到装饰器模式（Decorator Pattern），也可以通过拆解类结构来化继承为组合。\nExtra 2 真·工厂方法模式 编程题 #  在 LAB04 的 Shape 的基础上，定义一个满足如下需求的 IShapeFactory 接口：\n 具有方法 Shape makeShape(double a, double b) ，返回一个由 a 和 b 指定大小的形状；  参数不合法时，返回 null 或抛出异常    为每一种形状编写它的工厂类：\n 比如生成矩形的工厂类 RectangleFactory 要 implements 接口 IShapeFactory。  编写测试类 ShapeFactoriesTest：\n 具有 static 方法 Shape makeShape(IShapeFactory factory, double a, double b) ，在其中使用 factory.makeShape(a, b)方法生成形状并返回 在 main 方法中声明所有 3 种工厂，将他们存入一个 IShapeFactory 类型的数组（或其他容器） 对工厂数组（或容器）使用 foreach 循环遍历，利用 ShapeFactories.makeShape方法生成所有种类的形状并输出他们的面积  题外话： #  这题才是设计模式中的工厂方法模式（factory method pattern），第五题虽然也是比较常用的“工厂”，但并不是工厂方法模式，甚至不是一个专门的设计模式。\n工厂方法模式将实例化延迟到子类，由专门的工厂类生成特定类型的产品（比如 Shape）。本次实验没有关于 Random 的需求，主要是因为设计上的问题，他和本题的初衷“简单了解工厂方法模式”不符，它不是特定的，它需要知道所有的类型信息，类似本题中的 ShapeFactoriesTest 的地位。\n第五题中的方法，需要使用诸如 ShapeType 的标准来指定类型，这就导致了如果有新 的需求（新的形状种类）出现，整个 ShapeFactory 类都要重新编写并编译。而使用工厂方法模式，你需要做的是编写一个新的工厂类并编译这个新的类，对原有的工厂代码无需进行修改（重构过的同学应该能体会到“不用修改代码”是一种多么幸福的事）。编写的时候可能觉得引入过多的类比较反人类，但是程序不是开发出来就完事了，还有维护和迭代更新。提倡在开工之前的设计环节为未来做足打算，但是也不要因此变成设计狂魔。上机题是为了在比较小的工作量下让大家了解基础内容，所以才会抽象出各种各样不现实的场景。如果像某次实验的“文件”那样，在工作量上并不友好。本题的 ShapeFactories.makeShape 也是策略模式的应用。\nExtra 3 匿名类的 ShapeFactory 编程题 #  在前面实验的 Shape 的基础上，定义一个满足如下需求的 IShapeFactory 接口：\n 具有方法 Shape makeShape(double a, double b) ，返回一个由 a 和 b 指定大小的 形状；  参数不合法时，返回 null 或抛出异常    用单例模式+工厂方法模式的思想修改矩形、椭圆、菱形类：\n 每一个类都增设一个 private static IShapeFactory factory 字段  类中的 factory 用于生成该类的形状对象  比如 Rectangle 类中的 factory，其 makeShape 方法返回 Rectangle 对象   直接使用匿名类为 factory 进行静态初始化，不允许像 ShapeFactory2 那样定义工厂类   进行其他的修改，使外界的其他类能够获取到 factory 并成功构造形状对象  选择你认为合适的方式编写测试类：\n 你的测试类应该能够覆盖到所有等价类。 测试形式可以是单元测试，被测对象的形式可以参考之前实验中的 ShapeFactoriesTest.makeShape 方法。 在代码注释中（或者与代码一起提交一个 readme），描述你的测试计划  题外话： #  使用匿名类，依然是为每一个形状创建了一个对应的工厂，因此本质上依然是工厂方法模式，区别在于不用显式定义新的类（据说编码过程中，起名字是最麻烦的事情）。\n工厂方法模式的应用中，每一种工厂通常只有一个实例，因此它经常和单例模式一起被使用。\nExtra 4 命令模式 编程题 #  我们来模拟一个酒吧的点餐过程\n实现一个酒吧类 Bar：柜台上可以点炒饭（为了防止测试工程师炸掉酒吧），啤酒，伏特加。\n实现一个测试工程师类 Engineer：有很多很多钱可以用来点炒饭。\n实现一个满足如下需求的 interface ICommand：\n 具有方法 void excute()  利用 interface ICommand，实现如下四个具体命令类：\n 买炒饭 BuyEggFriedRice(Bar bar, int num)  含义是在酒吧 bar 中点 num 份炒饭， 该命令在执行时需要调用 bar 的相关方法， 下同   买啤酒 BuyBeer(Bar bar, int num) 买伏特加 BuyVodka(Bar bar, int num) 消费 x 元 SpendMoney(Engineer engineer, double money)  实现一个执行类 Executor 负责接收并执行上述命令\n 具有方法： void add(ICommand command) 含义是添加一个命令 具有方法： void run() 含义是执行所有命令  最终，你应该可以跑通下面的测试函数，当然你也可以自行设计其他的测试代码\npublic static void main(String[] args) {  Bar bar = new Bar();  Engineer engineer1 = new Engineer();  Engineer engineer2 = new Engineer();  // 点一份炒饭 + 啤酒， 花费 30 元  Executor executor1 = new Executor();  executor1.add(new BuyBeer(bar, 1));  executor1.add(new BuyEggFriedRice(bar, 1));  executor1.add(new SpendMoney(engineer1, 50));  executor1.run();  // 点两份炒饭， AA，每人 20 元  Executor executor2 = new Executor();  executor2.add(new BuyBeer(bar, 2));  executor2.add(new SpendMoney(engineer1, 50));  executor2.add(new SpendMoney(engineer2, 50));  executor1.run(); } "},{"id":7,"href":"/Java-HomeWork/docs/OOP-LAB/LAB06/","title":"Lab06","section":"Oop Lab","content":"Java 程序设计 LAB06 #  实验目的 #   简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类  实验题目 #   本实验假设你明白：\n 涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。    本次实验不会涉及以下内部类的常用技巧：\n 回调与闭包 事件与控制框架  也不会涉及以下内部类的边角情况：\n 内部类的继承与覆盖 多重嵌套的内部类   Question01 InnerClass1 代码填空 #  阅读下面这段代码：\nclass Outer {  public int num = 10;   class Inner { \tpublic int num = 20;  \tpublic void show() { \tint num = 30; \tSystem.out.println(/*???*/); \tSystem.out.println(/*???*/); \tSystem.out.println(/*???*/); \t}  } }  public class Test {  public static void main(String[] args) { \tOuter.Inner oi = /*???*/; \toi.show();  } }  在 Code/Question01/Test.java 中的注释部分填代码，使程序先后输出 30、20、10。 注意：  不允许修改已经有的代码。 考察的是内部类的构造以及访问外部类的方法，请不要用加减运算这种操作。    Question02 InnerClass2 代码填空 #  阅读下面这段代码：\ninterface Inter {  void show(); }  class Outer {  /*???*/ }  public class Test {  public static void main(String[] args) { \tOuter.method().show();  } }  在 Code/Question02/Test.java 中的注释部分填代码，使程序输出\u0026quot;DuluDulu\u0026quot;。 注意：  不允许修改已经有的代码。 考察的是匿名类，但是用内部类也可以实现    Question03 匿名类的 ShapeFactory 编程题|旧题 #  在前面实验的 Shape 的基础上，定义一个满足如下需求的 IShapeFactory 接口：\n 具有方法 Shape makeShape(double a, double b) ，返回一个由 a 和 b 指定大小的 形状；  参数不合法时，返回 null 或抛出异常    用单例模式+工厂方法模式的思想修改矩形、椭圆、菱形类：\n 每一个类都增设一个 private static IShapeFactory factory 字段  类中的 factory 用于生成该类的形状对象  比如 Rectangle 类中的 factory，其 makeShape 方法返回 Rectangle 对象   直接使用匿名类为 factory 进行静态初始化，不允许像 ShapeFactory2 那样定义工厂类   进行其他的修改，使外界的其他类能够获取到 factory 并成功构造形状对象  选择你认为合适的方式编写测试类，：\n 你的测试类应该能够覆盖到所有等价类。 测试形式可以是单元测试，被测对象的形式可以参考之前实验中的 ShapeFactoriesTest.makeShape 方法。 在代码注释中（或者与代码一起提交一个 readme），描述你的测试计划  题外话： #  使用匿名类，依然是为每一个形状创建了一个对应的工厂，因此本质上依然是工厂方法模式，区别在于不用显式定义新的类（据说编码过程中，起名字是最麻烦的事情）。 工厂方法模式的应用中，每一种工厂通常只有一个实例，因此它经常和单例模式一起被使用。\nQuestion04 ShapeSequence 编程题 #   这是一个主动要求大家造轮子的题，因此不允许继承或组合任何 java 自带的容器（除了数组）。 本题假设大家在算法上机时能够较为熟练的使用 C++中 STL 容器，并至少对变长容器的迭代访问有一定了解。\n 在 Shape 的基础上，定义一个满足如下需求的 ShapeSequence 类：\n 具有属性 private Shape[] shapes 构造方法 ShapeSequence(int size)  size 用于指定 shapes 的最大长度，如果 size 是负数，那么按照 0 来处理。 构造方法中应当对 shapes 进行初始化赋值，在其他过程中 shapes 的大小不 应该被改变   方法 public void add(Shape shape)  向 shapes 中添加一个新的元素 当 shapes 被填满时，什么都不做   方法 public String toString()  返回这个容器的字符串表达，格式为 [Type, Type,...] 格式中的 Type 是形状类型的全小写英文单词，比如 rectangle、ellipse   方法 public SequenceIterator iterator() {return new SequenceIterator();} 具有内部类 private class SequenceIterator，它用于序列遍历的迭代器  默认构造方法，在被构造时，迭代器指向的位置代表数组下标 0 方法 public boolean isEnd()，迭代器完成遍历时，返回 true  完成遍历不代表迭代器指向了最后一个元素，而是指向了最后一个元素的下一个位置   方法 public Shape current()，返回当前迭代器指向位置的 Shape 对象  isEnd()是 true 时，访问 current 是非法操作   方法 public void moveNext()，使迭代器移动到下一个元素的位置  isEnd()是 true 时，什么都不做   方法 public boolean equals(Object o)，当 o 是 SequenceItetator 类型的、且 o 和 this 的外部类对象相同、且 o 和 this 的位置相同时，返回 true    编写测试类并描述你的测试计划\n注意： #  toString 和 equals 是 override 继承自 Object 的方法，尽量避免出现诸如 ToString、 equals 的参数类型不是 Object（这种情况会算作 overload）等情况\n题目中省略了一些实现上必要但是方式不唯一的属性：比如你可以在 ShapeSequence 类中声明一个 int 属性来表示当前容器被填充到了什么位置；给 SequenceIterator 一个 int 属性表示当前迭代器指向的位置，当使用 isEnd 时，判断迭代器位置和外部类容器的填充位置进行比较。\n题外话： #   本题的目的是进行内部类、Object 相关的综合实践，通过使用自定义的迭代器和容器提前复习 C++基础并理解一些基础概念。 后续容器和泛型课程中，会引入可变长容器以及匿名类实现的迭代器。 虽然我们上机并不评测程序的性能，但是在实现本题的 toString 时，还是推荐考虑使用 StringBuilder。 你可以考虑一下不使用内部类时要如何实现迭代器，内部类为这种数据访问是否带来了足够的便利？ 为什么 SequenceIterator 被限定为了 private  "},{"id":8,"href":"/Java-HomeWork/docs/OOP-LAB/LAB07/","title":"Lab07","section":"Oop Lab","content":"Java 程序设计 LAB07 #  实验目的 #    理解集合框架的设计思路\n  了解 Java 常用的数据结构类及其使用，重点迭代器(Iterator) 、线性表（List、ArrayList、LinkedList）、HashMap 类、HashSet 类及枚举类在企业级软件编写中经常用到，要求在理解的基础上，熟练掌握\n  理解泛型的概念、必要性并能够灵活使用\n  实验题目 #  Question1 简述ArrayList和LinkedList的区别 简答 #  Question2 写出以下程序的输出 简答 #  //Animal.java public class Animal {  public Animal(){  System.out.println(\u0026#34;I am an animal\u0026#34;);  } }  //Dog.java public class Dog extends Animal{  public Dog(){  System.out.println(\u0026#34;I am a dog\u0026#34;);  } }  //AnimalTest.java public class AnimalTest {  public \u0026lt;T,S extends T\u0026gt; T testDemo(T t,S s){  System.out.println(\u0026#34;I am type T and my type is \u0026#34;+t.getClass().getName());  System.out.println(\u0026#34;I am type S and my type is \u0026#34;+s.getClass().getName());  return t;  }  public static void main(String[] args){  AnimalTest test=new AnimalTest();  Dog dog=new Dog();  Animal animal=new Animal();  Animal animal1=test.testDemo(animal,dog);  } } Question3 写出以下程序的输出(注意通配符的使用) 简答 #  //Animal.java public class Animal {  public Animal(){  System.out.println(\u0026#34;I am an animal\u0026#34;);  } }  //Dog.java public class Dog extends Animal{  public Dog(){  System.out.println(\u0026#34;I am a dog\u0026#34;);  } }  //AnimalTest1.java import java.util.List; import java.util.ArrayList;  public class AnimalTest1 {  public void testDemo(List\u0026lt;?\u0026gt; s){  for(Object obj:s){  System.out.println(\u0026#34;My type is \u0026#34;+obj.getClass().getName());  }  }  public static void main(String[] args){  AnimalTest1 test=new AnimalTest1();  Dog dog=new Dog();  Animal animal=new Animal();  List\u0026lt;Animal\u0026gt; s=new ArrayList\u0026lt;Animal\u0026gt;();  s.add(dog);  s.add(animal);  test.testDemo(s);  } } Question4 编写程序完成以下要求 编程 #  请用 LinkedList 实现一个支持泛型的栈 MyStack，并在 main 函数中测试\n//MyStack.java import java.util.LinkedList;  public class MyStack\u0026lt;T\u0026gt; {  private LinkedList\u0026lt;T\u0026gt; values=new LinkedList\u0026lt;T\u0026gt;();  public void push(T t){  //Your code here  }  public T pull(){  //Your code here  }  public T peak(){  //Your code here  }  public static void main(String[] args){  /* Your test code here */  } } Question5 编写程序完成以下要求 编程 #  假如有以下 email 数据 aa@sohu.com, bb@163.com, cc@sina.com, ... 现需要把 email 中的用户名和邮件地址部分分离(例如 aa@sohu.com 分离为 aa 和 sohu.com )，分离后以键值对应的方式放入 HashMap 。\n给定 email 数据为： String str = \u0026quot;aa@sohu.com,bb@163.com,cc@sina.com\u0026quot;;\nimport java.util.HashMap; import java.util.Map;  public class EmailSplit {  public static void main(String[] args)  {  String str = \u0026#34;aa@sohu.com,bb@163.com,cc@sina.com\u0026#34;;  Map\u0026lt;String, String\u0026gt; emailMap = new HashMap\u0026lt;String, String\u0026gt;();  /* Your code here */  System.out.println(emailMap.toString());  } } Question6 编写程序完成以下要求 编程 #  双色球规则：双色球每注投注号码由 6 个红色球号码和 1 个蓝色球号码组成。红色球号码从 1—33 中选择；蓝色球号码从 1—16 中选择；请随机生成一注双色球号码，并输出到控制台。（要求同色号码不重复） 举例如下，双色球号码一注：\n 红球 8\n红球 20\n红球 17\n红球 1\n红球 28\n蓝球 6\n红球 32\n public class TwoColorBall {  public static void main(String[] args) {  /* Your code here */  } } "},{"id":9,"href":"/Java-HomeWork/docs/OOP-LAB/LAB08/","title":"Lab08","section":"Oop Lab","content":"Java 程序设计 LAB08 #  实验目的 #   掌握异常处理机制 掌握使用 try…catch…finally 处理异常 掌握使用 throws 关键字 掌握使用 throw 关键字 创建用户自定义异常，并处理这种异常  实验题目 #  Question1 Java中的检查型异常 (checked exception) 和非检查型异常 (unchecked exception) 有什么区别？ 简答 #  Question2 简述Java异常处理中 throws 和 throw 关键字的作用。 简答 #  Question3 请列出2个常见的运行时异常和2个非运行时异常。 简答 #  Question4 指出下列程序的错误并改正。 改错 #  import java.io.IOException;  public class p04 {  public static void start() throws IOException,RuntimeException{  throw new RuntimeException(\u0026#34;Unable to Start\u0026#34;);  }   public static void main(String[] args){  try{  start();  }catch (Exception ex){  ex.printStackTrace();  }catch (RuntimeException re){  re.printStackTrace();  }  } } Question5 指出下列程序的错误并改正。 改错 #  //SuperClass.java import java.io.IOException;  public class SuperClass {  public void start() throws IOException{  throw new IOException(\u0026#34;Unable to start\u0026#34;);  } }  //SubClass.java import java.io.FileInputStream;  public class SubClass extends SuperClass {  public void start() throws Exception{  throw new Exception(\u0026#34;Unable to open file\u0026#34;);  }  public void open(String fileName){  FileInputStream fis=new FileInputStream(fileName);  } } Question6 写出以下程序的输出。 程序输出 #  public class p06 {  public static void main(String[] args) {  try {  methodA();  } catch (Exception e) {  methodB();  }  }  private static void methodA() {  try {  System.out.println(\u0026#34;methodA抛出一个异常！\u0026#34;);  throw new RuntimeException();  } finally {  System.out.println(\u0026#34;执行methodA的finally!\u0026#34;);  }  }  private static void methodB() {  try {  System.out.println(\u0026#34;methodB执行！\u0026#34;);  } finally {  System.out.println(\u0026#34;执行methodB的finally!\u0026#34;);  }  } } Question7 写出以下程序的输出，试着解释三个函数不同输出的原因。 程序输出 #  public class p07 {  public static void main(String[] args) {  System.out.println(\u0026#34;-----------------------\u0026#34;);  System.out.println(get0());  System.out.println(\u0026#34;-----------------------\u0026#34;);  System.out.println(get1());  System.out.println(\u0026#34;-----------------------\u0026#34;);  System.out.println(get2());  System.out.println(\u0026#34;-----------------------\u0026#34;);  }  public static int get0(){  int i=1;  try{  throw new Exception();  }catch (Exception e){  System.out.println(\u0026#34;error\u0026#34;);  return i;  }finally {  i++;  System.out.println(\u0026#34;i in finally block:\u0026#34;+i);  }  }  public static String get1(){  String i=\u0026#34;ok\u0026#34;;  try{  throw new Exception();  }catch (Exception e){  System.out.println(\u0026#34;error\u0026#34;);  return i;  }finally {  i+=\u0026#34;finally\u0026#34;;  System.out.println(\u0026#34;i in finally:\u0026#34;+i);  }  }  public static StringBuilder get2(){  StringBuilder i=new StringBuilder(\u0026#34;ok\u0026#34;);  try{  throw new Exception();  }catch (Exception e){  System.out.println(\u0026#34;error\u0026#34;);  return i;  }finally {  i.append(\u0026#34;finally\u0026#34;);  System.out.println(\u0026#34;i in finally:\u0026#34;+i);  }  } } Question8 编写程序完成以下要求。 编程 #   自定义类 Triangle ，其中有成员 x,y,z 作为三边长，类型为 double ，构造方法 Triangle(a,b,c) 分别给 x,y,z 赋值 求面积方法 public double getArea() 显示三角形信息(三个边长) public void showInfo() 上述两个方法中当三条边不能构成一个三角形时要抛出自定义异常 NotTriangleException ，否则显示正确信息。 在测试类 Triangle_Test 中的主方法中构造一组 Triangle 对象，显示三角形信息和面积，要求捕获异常。  "},{"id":10,"href":"/Java-HomeWork/docs/OOP-LAB/LAB09/","title":"Lab09","section":"Oop Lab","content":"Java 程序设计 LAB09 #  实验目的 #    理解并掌握控制台读入数据、标准输入输出、Scanner类（基础的输入输出）\n  理解并掌握Java文件管理（File类）、输入/输出流类及其派生类的使用（字节流的顺序读写）\n  理解并掌握读写器及其派生类的使用（字符流的顺序读写）\n  理解并掌握对象序列化（对象流的读写）\n  实验题目 #  Question1 如果准备按字节读取一个文件的内容，应当使用 FileInputStream 流还是 FileReader 流，为什么？ 简答 #  Question2 简答 #  import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException;  public class FileInputStreamTest {  public static void main(String[] args) {  File f =new File(\u0026#34;hello.txt\u0026#34;);  byte [] a=\u0026#34;abcd\u0026#34;.getBytes();  try{  FileOutputStream out=new FileOutputStream(f);  out.write(a);  out.close();  FileInputStream in=new FileInputStream(f);  byte [] tom= new byte[3];  //Part Ⅰ  int m = in.read(tom,0,3);  System.out.println(m);//3  String s=new String(tom,0,3);  System.out.println(s);//abc  //Part Ⅱ  m = in.read(tom,0,3);  System.out.println(m);//1  s=new String(tom,0,3);  System.out.println(s);//dbc  }  catch(IOException e) {}  } } (1) 请写出程序的输出\n(2) 解释 Part Ⅰ 和 Part Ⅱ 的输出为什么不同\nQuestion3 设计一个方法，用于移除文件中的注释 编程 #  public static void removeComments(String inputPath,String outPath) throws IOException; input.txt\nFile f = new File(\u0026#34;./java.oop\u0026#34;); System.out.println(\u0026#34;当前文件是：\u0026#34; +f);// 这是一条注释 //这是另一条注释 System.out.println(\u0026#34;判断是否存在：\u0026#34;+f.exists()); /* 这些还是注释 */ System.out.println(\u0026#34;判断是否是文件夹：\u0026#34;+f.isDirectory());  //这是个位置有点奇怪的注释 out.txt\n在删除注释后， 你可以自由选择是否删除空行\n一个可能的输出如下：\nFile f = new File(\u0026#34;D:\\\\java\u0026#34;); System.out.println(\u0026#34;当前文件是：\u0026#34; +f);  System.out.println(\u0026#34;判断是否存在：\u0026#34;+f.exists());    System.out.println(\u0026#34;判断是否是文件夹：\u0026#34;+f.isDirectory());  Question4 设计一个方法，使用 Java 的输入、输出流将一个文本文件的内容按行读出，每读出一行就顺序添加行号，并写入到另一个文件中 编程 #  public static void addLineNo(String inputPath,String outPath) throws IOException; Question5 复制文件是常见的IO操作，设计如下方法，实现复制源文件 sourceFile 到目标文件 targetFile 编程 #  public static void copyFile (String sourceFile, String targetFile) throws IOException; Question6 复制一个文件夹下面所有文件和子文件夹内容到另一文件夹 编程 #  public static void copyDirectory(String sourceDir, String targetDir) throws IOException; 可以尝试复用 Q5 的代码\n"},{"id":11,"href":"/Java-HomeWork/docs/OOP-LAB/LAB10/","title":"Lab10","section":"Oop Lab","content":"Java 程序设计 LAB10 #  实验目的 #    理解程序、进程和多线程概念及特点\n  理解线程的状态、生命周期及调度策略\n  理解并掌握线程类 Thread 和 Runnable 接口，并能够进行相关应用的程序设计，实现多线程编程\n  实验题目 #  Question1 简述程序，进程，线程的概念 简答 #  Question2 产生死锁的四个条件是什么？ 简答 #  Question3 创建线程的两种方式分别是什么？各有什么优缺点 简答 #  Question4 判断题 #  (1) 进程是线程 Thread 内部的一个执行单元，它是程序中一个单一顺序控制流程。\n(2) 一个进程可以包括多个线程。两者的一个主要区别是：线程是资源分配的单位，而进程是CPU调度和执行的单位。\n(3) 线程可以用 yield 使低优先级的线程运行。\n(4) 当一个线程进入一个对象的一个 synchronized 方法后，其它线程可以再进入该对象的其它同步方法执行。\n(5) notify 是唤醒所在对象 wait pool 中的第一个线程。\nQuestion5 程序输出简答 #  public class Main {  public static void main(String[] args) {  SyncThread syncThread = new SyncThread();  Thread thread1 = new Thread(syncThread, \u0026#34;SyncThread1\u0026#34;);  Thread thread2 = new Thread(syncThread, \u0026#34;SyncThread2\u0026#34;);  thread1.start();  thread2.start();  } } class SyncThread implements Runnable {  private static int count;  public SyncThread() {  count = 0;  }  public synchronized void run() {  for (int i = 0; i \u0026lt; 5; i++) {  try {  System.out.println(Thread.currentThread().getName() + \u0026#34;:\u0026#34; + (count++));  Thread.sleep(100);//【1】  } catch (InterruptedException e) {  e.printStackTrace();  }  }  }  public int getCount() {  return count;  } } (1) 请写出上述程序的输出\n(2) 用 synchronized 修饰 run() 的作用是什么？\n(3) 标号【1】处 sleep 的作用是什么？如果改为 wait(100); 输出会发生改变吗，为什么？\nQuestion6 程序补全题 #  public class ThreadPrint {  public static void main(String[] args) throws InterruptedException{  Object a=new Object();  Object b=new Object();  Object c=new Object();  Thread8 threadA=new Thread8(\u0026#34;A\u0026#34;,c,a);  Thread8 threadB=new Thread8(\u0026#34;B\u0026#34;,a,b);  Thread8 threadC=new Thread8(\u0026#34;C\u0026#34;,b,c);  new Thread(threadA).start();  Thread.sleep(100);  new Thread(threadB).start();  Thread.sleep(100);  new Thread(threadC).start();  Thread.sleep(100);  } } class Thread8 implements Runnable{  private String name;  private Object prev;  private Object self;  public Thread8(String name,Object prev,Object self){  this.name=name;  this.prev=prev;  this.self=self;  }  @Override  public void run(){  int count=10;  while(count\u0026gt;0){  synchronized (prev){  synchronized (self){  System.out.print(name);  count--;  【1】  }  try{  if(count==0)  【2】  else  【3】  }catch (InterruptedException e){  e.printStackTrace();  }  }  }  } } (1) 补全标号处的代码\n(2) 详细说明上述程序的功能\n(3) 主函数 main 中的 Thread.sleep(100) 语句不能省略，请简述原因。\n(4) 主函数 main 中的 Thread.sleep(100) 语句全部去掉后程序可能出现死锁吗？试举例说明。\nQuestion7 创建两个线程，其中一个输出1-52，另外一个输出A-Z。输出格式要求： 编程 #  12A 34B 56C 78D 910E 1112F 1314G 1516H 1718I 1920J 2122K 2324L 2526M 2728N 2930O 3132P 3334Q 3536R 3738S 3940T 4142U 4344V 4546W 4748X 4950Y 5152Z 注意：\n (1) 可以参考T6\n(2) 12A 34B…… 看清楚A和3之间是有一个空格的，且输出以Z结尾，即结尾不能有空格\n(3) 请确保你的程序能够正常结束，不要在输出Z之后一直阻塞下去\n "},{"id":12,"href":"/Java-HomeWork/docs/OOP-LAB/TEMPLATE/","title":"Template","section":"Oop Lab","content":"Lab XX Assignment #   班级：\n学号：\n姓名：\n 提交要求（以下内容在最终提交的作业中可以删除，仅作参考） #  目录格式\n-- 班级-学号-姓名-LabXX.zip  |-- answer.pdf  |-- solution  |-- Question1  |-- 题1的代码文件(如果需要)   |-- Question2  |-- 题2的代码文件(如果需要)  |-- ... "},{"id":13,"href":"/Java-HomeWork/docs/CTS/CTS-1/","title":"Cts 1","section":"Cts","content":"CTS-1 #   咖喱铁路售票系统curry ticketing system -1\n  \n题目背景 #  ​\t在世界上某个能歌善舞的国家，铁路系统实行配额制，即为弱势群体提供不同的票价优惠，人们通过实名制进行铁路火车票预订，可以查询线路图和购票情况。铁路管理员则负责管理铁路线路，火车营运。同时，还存在团购性质的代理人，能够一次性购买更多的车票。为了让大家能够有序购票乘车，现开发一款铁路售票管理系统，实现上述场景功能。\n功能描述 #  ① 开关机 #  实现最基本的命令读入和退出功能\n首先，你的任务是编写一个Test类：\n  当程序启动，进入main方法，并连续读入输入的命令，命令的基本格式为：\n选项 [参数1] [参数2] [参数3] 其中参数数目为不定项\n  当终端输入 QUIT 时，系统退出（程序退出状态为0），并在终端打印一行字符：\n  ----- Good Bye! -----  对于其他的输入，不做任何处理，等待下一行输入 下方是按行读取的一种参考实现  Scanner in = new Scanner(System.in); String argStr; while (true) {  argStr = in.nextLine(); } ②用户注册 #  黄金右手国的居民们使用的身份证称为“Aadhaar卡\u0026quot;，铁路系统内的用户注册需要填写姓名、性别、Aadhaar卡号。其中Aadhaar号需要满足以下格式：\n \n Aadhaar卡号一共12位，全国唯一 前4位为区域代码，范围是[0001,1237] 中间4位为种姓代码，范围为[0020,0460] 最后四位为生物识别库提供的生物识别码，前三位的范围为[000,100]，最后一位表示持有人的性别，0代表女性，1代表男性，2代表其他。  合法的Aadhaar卡号示例：\n 0023 0122 0991 1000 0072 0000  不合法的Aadhaar卡号示例：\n 0000 0122 0991 0030 0500 1010 1234 0123 0553  具体实现\n为用户设立一个 User 类：\n  私有属性至少包括姓名（仅可能由 26 个字母大小写和下划线构成）、性别（字符 M/F/O，分别表示男性/女性/其他）、Aadhaar卡号（符合上述合法格式）\n  为用户的3种属性提供相应的 getter 和 setter 方法\n  实现方法 String toString() 打印用户格式化信息，具体要求如下：\n 冒号为英文字符 : 不包含多余的空格 所有字符为半角字符  以 sb_DYY，Aadhaar卡号 0910 0072 0112 为例：\n  Name:sb_DYY Sex:O Aadhaar:091000720112  实现添加用户方法，命令格式如下：     选项 [参数 1] [参数 2] [参数 3] 功能描述     addUser 姓名 性别 卡号 新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。    具体要求如下：\n  在输入 addUser 命令时，并不保证参数数量严格对应，这也是一种非法情况，需要在终端输出：\nArguments illegal   如果参数合法，按以下顺序依次进行信息检查\n 姓名由 26 个字母和下划线构成，其他情况请输出  Name illegal  性别必须为 F / M / O，其他情况请输出  Sex illegal  卡号需满足指定格式，非法（包括尾号和性别不符的情况）请输出  Aadhaar number illegal  一张卡号只能注册一次，若注册卡号已存在请输出  Aadhaar number exist   如果存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n   如果输入合法，按 toString() 输出格式打印刚添加的用户信息。如：  addUser LaoWang M Arguments illegal addUser LaoWang GHS 123123 Sex illegal addUser LaoWang M 003005001010 Aadhaar number illegal addUser LaoWang M 002301220991 Name:LaoWang Sex:M Aadhaar:002301220991 addUser HaiWang M 002301220991 Aadhaar number exist "},{"id":14,"href":"/Java-HomeWork/docs/CTS/CTS-2/","title":"Cts 2","section":"Cts","content":"CTS-2\n 咖喱铁路售票系统curry ticketing system -2\n 题目背景 #  售票系统最核心的功能是什么？当然是售票啦！现在请你在CTS-1的基础上实现以下功能：\n超级管理员 #  本着“以抢钱为宗旨，待旅客如孙子”的宗旨，咖喱铁路票价的定价权必须掌握在高层的手中。高层管理人员拥有一句神奇的咒语，向系统中输入这句咒语即可进入管理员模式，进行关键数据的修改。\n那么这句咒语就是——TunakTunakTun（译：我在东北玩泥巴）\n实现以下功能：\n   命令 功能描述     TunakTunakTun 从标准模式进入超级管理员模式，并输出DuluDulu   NutKanutKanut 退出超级管理员模式，并输出DaDaDa     异常处理  若已经在管理员模式下执行TunakTunakTun或在普通模式下执行NutKanutKanut，输出WanNiBa    注：以下功能前备注（超级管理员模式）为仅可以在超级管理员模式下执行的命令，（标准模式）为仅可以在标准模式下执行的命令，未标注的命令在两种模式下均可执行。\n线路和列车管理 #  为方便起见，我们假定在黄金右手国，所有的铁路线路都是从首都第三新德里市（Delhi-3）出发，沿自己的线路折返运行，跨线换乘需要在第三新德里市下车并重新购买车票，并且乘客中途到站下车不释放席位。\n在超级管理员模式下可以向系统中添加新建成的线路列车、指定票价、席位数量信息等操作。\n线路管理 #    （超级管理员模式）添加和删除线路\n   命令 参数1 参数2 参数2k+1(k\u0026gt;=1整数) 参数2*(k+1) 功能描述     addLine 线路编号 负载能力 站点名2k+1 里程数2k+1 添加一条新的线路，并添加初始站点，若成功则输出Add Line success 里程数计算方式：起点第三新德里市（站点0）的里程数为0，每个站点的里程数为该站距第三新德里市的里程（里程数可以相同）。线路编号为字符串类型，负载能力表示该线路上能开行的最大列车数量。   delLine 线路编号    删除线路，并删除在该线路上运行的全部列车。若成功输出Del Line success      异常处理\n 添加线路时站点名和里程数一一对应，里程数应为整数类型，否则不做任何修改并输出Arguments illegal 添加线路时同一线路上的的两个站名不得重复（没有环线），否则不做任何修改并输出Station duplicate 添加线路时线路编号不得重复，否则不做任何修改并输出Line already exists，删除线路时线路号必须存在，否则输出Line does not exist 添加线路时负载能力应该在合理的范围内（不能跑车的铁路修了个寂寞），否则输出Capacity illegal。      （超级管理员模式）添加和删除车站\n   命令 参数1 参数2 参数3 功能描述     addStation 线路编号 新站点名 里程数 向线路中添加新的站点，若成功则输出Add Station success   delStation 线路编号 站点名  从线路中删除指定站点，若成功则输出Delete Station success      异常处理\n 线路编号必须存在，否则不做任何修改并输出Line does not exist 添加车站时同一线路上的的两个站名不得重复（没有环线），否则不做任何修改并输出Station duplicate ；删除车站时车站必须存在，否则不做任何修改并输出Station does not exist 添加车站时里程数应当符合规范，否则输出Arguments illegal。      查询线路\n   命令 参数1 功能描述     lineInfo 线路编号 重写线路的toString方法，使得按照如下格式输出按照里程数升序的站点信息      输出格式\n[线路编号] [已承载列车数]/[总最大负载] [站点名1] [里程数1] [站点名2] [里程数2] ... [站点名k] [里程数k] 例：\nLine13 0/4 Dazhongshi:28 Zhichunlu:30 Wudaokou:48 Shangdi:96 Xierqi:121 Longze:148   异常处理\n 线路必须存在，否则输出Line does not exist      列出全部线路\n   命令 功能描述     listLine 列出全部线路信息，按格式输出按照线路编号字典序升序排列的站点信息，若为空，则输出No Lines      输出格式\n[1] [线路编号1] [已承载列车数]/[总最大负载] [站点名1] [里程数1] [站点名2] [里程数2] ... [站点名k] [里程数k] [2] [线路编号2] [已承载列车数]/[总最大负载] [站点名1] [里程数1] [站点名2] [里程数2] ... [站点名l] [里程数l] ... [i] [线路编号i] [已承载列车数]/[总最大负载] [站点名1] [里程数1] [站点名2] [里程数2] ... [站点名m] [里程数m] 例：\n[1] Beihei 5/8 Erjing:16 Erlongshantun:35 Wudalianchi:52 Longzhen:63 Xianghe:81 Longmenhe:95 Chenqing:137 Qingxi:167 Sunwu:187 Sunwubei:192 Eyu:218 Hushui:234 Xigangzi:257 Sanjitun:282 Jinhe:287 Heihe:302 [2] Line19 0/1 Mudanyuan:9 Jishuitan:34 Pinganli:50 Taipingqiao:77 Niujie:98 Jingfengmen:117 Caoqiao:144 Xinfadi:170 Xingong:198 [3] Manchu 0/2 Shahe:20 Hamazhen:59 Wulongbei:150 Tangshancheng:207 Fenghuangcheng:272 Gaolimen:281 Sitaizi:430 Jiguanshan:498 Benxihu:586     列车管理 #  黄金右手国的列车分为以下三种：\n  普通车：可以挂人的小车车，车次以0开头，出售坐票（CC）、站票（SB）、挂票（GG）\n  国产快车 गतिमान（Gatimaan，“搬家”号）：车次以G开头，出售软座票（SC）、硬座票（HC）、站票（SB）\n  锌淦线 曠野（Koya，“旷野”号）：象征着和霓虹国友谊的高速铁路，车次以K开头，出售一等座票（1A）和二等座票（2A）\n  假定旅客列车车次号由1位车次代码（G/K/0）+4位车次数字组成，不同列车的不同坐席有不同的每公里单价，价格可以取任意浮点数，张数可以取任意自然数。\n实现以下功能：\n  （超级管理员模式）添加删除列车\n   命令 参数1 参数2 参数3 参数4 参数5 参数6 参数7 参数8 功能描述     addTrain 列车车次 线路号 坐席1票价 坐席1张数 坐席2票价 坐席2张数 坐席3票价 坐席3张数 添加一班列车，并指定线路、各个席别的每公里票价和余票张数。对于普通车，有效参数为1~8，坐席1、2、3分别为坐票、站票、挂票；对于“搬家”号，有效参数为1~8，坐席1、2、3分别为软座票、硬座票、站票；对于“旷野”号，有效参数为1~6，坐席1、2分别为一等座票、二等座票。若添加成功，则输出 Add Train Success   delTrain 列车车次        删除列车，若删除列车成功，则输出Del Train Success      异常处理\n依次检验以下错误\n 列车号需符合规范，否则输出Train serial illegal 添加列车时车次号不得重复，否则输出Train serial duplicate，删除列车时车次号必须存在，否则输出Train does not exist 线路号必须存在，且未达到负载上限，否则输出Line illegal 票价具有实际意义，否则输出Price illegal 张数具有实际意义，否则输出Ticket num illegal      （标准模式）查询火车的余票和票价信息\n   命令 参数1 参数2 参数3 参数4 功能描述     checkTicket 列车车次 出发站 目的站 席位代号 查询列车余票和票价信息。     输出格式  [[列车号]: [出发站]-\u0026gt;[目的站]] seat:[席别代号] remain:[剩余票数] distance:[里程数] price:[最终票价(2位小数)] ​\t例：\n[K1151: Mudanyuan-\u0026gt;Niujie] seat:1A remain:90 distance:89 price:1958.00   异常处理\n  列车号需符合规范，否则输出Train serial illegal\n  车次号必须存在，否则输出Train serial does not exist\n  车站必须存在，否则输出Station does not exist\n  席位必须与车次类型对应，否则输出Seat does not match\n      列出火车信息\n   命令 参数1 功能描述     listTrain 线路编号 列出某一线路上的全部列车信息，若参数1为空，则列出全部线路上的全部列车信息。若没有火车，输出No Trains      输出格式\n按照如下格式输出列车信息，排序方式为“旷野”号、“搬家”号和普通车，相同类型按字典序排序。若线路上没有列车运行为空，则输出No Trains\n[1] [列车号1]: [线路编号1] [[席位代码1]][席位价格1]:[剩余席位数1] ... [[席位代码k]]:[席位价格k][剩余席位数k] [2] [列车号2]: [线路编号2] [[席位代码1]][席位价格1]:[剩余席位数1] ... [[席位代码k]:[席位价格k][剩余席位数k] ... [m] [列车号m]: [线路编号m] [[席位代码1]][席位价格1]:[剩余席位数1] ... [[席位代码k]]:[席位价格k][剩余席位数k] 例：\n[1] K1151: Beihei [1A]14.00:100 [2A]7.00:190 [2] G1121: Beihei [SC]3.00:90 [HC]2.60:120 [SB]2.40:200 [3] G1151: Beihei [SC]22.00:90 [HC]7.00:120 [SB]2.40:200 [4] G1191: Beihei [SC]3.00:90 [HC]2.60:120 [SB]2.40:200 [5] 01151: Beihei [CC]3.00:100 [SB]7.00:10 [GG]2.40:0   异常处理\n 线路必须存在，否则输出Line does not exist      输入错误处理 #    如果存在多种非法情况，按以下顺序进行检查，只输出最先发生的非法信息。\n  命令是否存在，若不存在输出Command does not exist\n  对应参数数量和类型是否正确，若不正确则输出Arguments illegal\n  命令规定的异常处理内容，按照上文描述依次检验处理\n  其他错误处理，发生未在上述列举出的错误，输出Unknown error\n    "},{"id":15,"href":"/Java-HomeWork/docs/CTS/CTS-3/","title":"Cts 3","section":"Cts","content":"CTS-3 #   咖喱铁路售票系统curry ticketing system -1\n 约定 #    这次真的超级简单der\n  CTS-3会测试前面已实现的功能，但不会加强，所以只要CTS-2能过就不会出现旧功能的问题\n  对于一行命令输入，只报优先级最高的一个错误，报错优先级为：\n命令名称 \u0026gt; 参数数量 \u0026gt; 参数合法性（从左至右） 其它情况请以功能描述要求的报错顺序为准\n  概览 #  ​\t本次CTS-3你需要实现的全部新功能（命令）如下表所示，详细要求请见下文。\n   命令 参数1 参数2 参数3 参数4 参数5 功能描述     login Aadhaar卡号 姓名    用户登录，是购票的前序操作   logout      退出当前登录的用户账户   buyTicket 列车车次 出发站 目的站 席位代号 张数 用户购买车票   listOrder      查询已购买的车票    login #  ​\n   命令 参数1 参数2 功能描述     login Aadhaar卡号 姓名 用户登录，是购票的前序操作    已注册用户通过该指令登录系统，登录后直到主动登出或者退出系统之前需维持当前登录状态，与超级管理员模式不冲突（不会不管不考）。\n  输出\n 登录成功输出Login success    异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前已有用户登录，输出You have logged in Aadhaar卡号不合法或不存在，输出User does not exist 姓名与卡号不对应，输出Wrong name    样例\n-addUser LaoWang M 002301220991 -Name:LaoWang Sex:M Aadhaar:002301220991 -login 002301220991 LaoWang -Login success   logout #     命令 功能描述     logout 退出当前登录的用户账户    已登录用户通过该指令退出登录状态，用以切换其它账号。\n  输出\n 登出成功输出Logout success    异常处理\n 命令不存在，输出Command does not exist 参数数量不正确（不为零），输出Arguments illegal 当前无用户登录，输出No user has logged in    样例\n  -addUser LaoWang M 002301220991 -Name:LaoWang Sex:M Aadhaar:002301220991 -login 002301220991 LaoWang -Login success -logout -Logout success buyTicket #     命令 参数1 参数2 参数3 参数4 参数5 功能描述     buyTicket 列车车次 出发站 目的站 席位代号 张数 用户购买车票    已登录用户通过该指令购买车票，车票来源于CTS-2中添加的车次的初始票数，每次购买后从当前余票中减去购买的数量。购买的车票信息需保存起来直到系统退出。\n席位代号包括 [ CC、SB、GG、SC、HC、1A、2A ]。\n  输出\n 购买成功输出Thanks for your order    异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前无用户登录，输出Please login first 列车车次不存在，输出Train does not exist 出发站或目的站不存在（地球上不存在或该车次不经过该车站），输出Station does not exist 席位代号与车次类型不符（席位代号非法或该车次没有这种席位），输出Seat does not match 张数不为正整数，输出Ticket number illegal 张数大于该车次该席位的剩余票数，输出Ticket does not enough    样例\n  -TunakTunakTun -DuluDulu -addLine Line13 4 Dazhongshi 28 Zhichunlu 30 Wudaokou 48 Shangdi 96 Xierqi 121 Longze 148 -Add Line success -addTrain K1151 Line13 22 90 7 120 -Add Train Success -addUser LaoWang M 002301220991 -Name:LaoWang Sex:M Aadhaar:002301220991 -login 002301220991 LaoWang -Login success -buyTicket K1151 Zhichunlu Wudaokou 1A 10 -Thanks for your order listOrder #     命令 功能描述     listOrder 查询已购买的车票    已登录用户通过该指令查询当前账号下已购买的车票，按照指定格式打印订单信息\n注：从系统开始运行到退出系统期间，用户的订单信息始终保留，即使登出再登录后仍能查看历史订单。\n  输出\n若历史订单不为空，按照最近购买日期优先顺序（下单顺序的倒序）输出订单信息，总价保留两位小数，格式为：\n[[列车车次]: [出发站]-\u0026gt;[目的站]] seat:[席别代号] num:[张数] price:[总价(保留两位小数)] 若历史订单为空，输出No order\n  异常处理\n 命令不存在，输出Command does not exist 参数数量不正确（不为零），输出Arguments illegal 当前无用户登录，输出Please login first    样例\n-TunakTunakTun -DuluDulu -addLine Line13 4 Dazhongshi 28 Zhichunlu 30 Wudaokou 48 Shangdi 96 Xierqi 121 Longze 148 -Add Line success -addTrain K1151 Line13 22 90 7 120 -Add Train Success -addUser LaoWang M 002301220991 -Name:LaoWang Sex:M Aadhaar:002301220991 -login 002301220991 LaoWang -Login success -buyTicket K1151 Zhichunlu Wudaokou 1A 10 -Thanks for your order -buyTicket K1151 Dazhongshi Shangdi 2A 20 -Thanks for your order -listOrder -[K1151: Dazhongshi-\u0026gt;Shangdi] seat:2A num:20 price:9520.00 [K1151: Zhichunlu-\u0026gt;Wudaokou] seat:1A num:10 price:3960.00   "},{"id":16,"href":"/Java-HomeWork/docs/Resource/","title":"Resource","section":"Docs","content":"也许有用的资源 #   Patpat 官方文档\n 涛哥的 OMS， \\zht/\\zht/\\zht/\n Java8 API 文档\n Java17 API 文档\n CTS的核酸检测证明文件\n（如果在完成作业的时候发现了有用的资源 / 写的不错的博客， 也可以联系 HZY 加到这个页面上）\n"},{"id":17,"href":"/Java-HomeWork/docs/CTS/CTS-4/","title":"Cts 4","section":"Cts","content":"CTS-4 #  概览 #  考察内容：继承、方法重写、文件I/O等\n本次CTS-4你需要实现的全部新功能（命令）如下表所示，详细要求请见下文。\n 虽然功能看起来不少，但是大部分是在原有基础上修改，新增功能逻辑比较简单。加油，CTS就要结束咧！\n    命令 参数1 参数2 参数3 参数4 参数5 功能描述     【修改】addUser 姓名 性别 卡号 学生优惠额度 无 添加用户【添加学生购票标志】   【修改】buyTicket 列车车次 出发站 目的站 席位代号 张数 用户购买车票【添加核酸检测判断】   【新增】rechargeBalance 充值金额 无 无 无 无 充值钱包余额   【新增】checkBalance 无 无 无 无 无 查询余额   【新增】importCert CSV文件名 无 无 无 无 导入核酸检测报告   【新增】cancelOrder 列车车次 出发站 目的站 席位代号 张数 取消订单   【新增】payOrder 无 无 无 无 无 支付全部未付款订单   【修改】listOrder 无 无 无 无 无 查询已购买的车票listOrder    以下功能在原来基础上修改 #    学生票功能 #  每位学生有多次以0.5折购买学生票的机会，并在下单时自动抵扣。\n学生优惠仅在结算时生效，订票、查询订单、取消订单时不涉及学生优惠！\n请实现以下功能、命令\n  创建学生类，继承自用户类，并做出如下修改：\n 添加属性：剩余的优惠次数    查询用户身份为学生时，重写学生类的toString方法，按照以下格式输出\nName:sb_DYY\rSex:O\rAadhaar:091000720112\rDiscount:1   修改方法：addUser\n  参数4存在时创建Student类对象，并将优惠额度数设为参数4对应的值（保证参数4为合法的正整数）；若不存在，则和CTS-1中要求一致。\n   选项 参数 1 参数 2 参数 3 参数4【新增】 功能描述     addUser 姓名 性别 卡号 学生优惠次数 新增用户对象并储存相关信息，对于非法输入，终端输出相应报错。对于合法输入，调用该对象的 toString() 方法。      修改方法：listOrder\n listOrder命令查看的价格是全票价格（与CTS-3相同），始终不显示折扣后的价格 学生票优惠仅在payOrder结算时进行扣减，在buyTicket之后payOrder之前不进行扣减 输出格式  【新增】paid:[结算状态(T/F)](支付功能详细描述见下方)，T(rue)表示已经结算，F(alse)表示未结算。\n[[列车车次]: [出发站]-\u0026gt;[目的站]] seat:[席别代号] num:[张数] price:[总价(保留两位小数)] paid:[结算状态(T/F)]     购票功能 #    修改CTS-3中的购票命令\n   命令 参数1 参数2 参数3 参数4 参数5 功能描述     buyTicket 列车车次 出发站 目的站 席位代号 张数 用户购买车票      输出\n 购买成功输出Thanks for your order    异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前无用户登录，输出Please login first 列车车次不存在，输出Train does not exist 出发站或目的站不存在（地球上不存在或该车次不经过该车站），输出Station does not exist 席位代号与车次类型不符（席位代号非法或该车次没有这种席位），输出Seat does not match 【新增】若当前用户购买车票坐席为[1A, 2A],且核酸检测证明结果为阳性或不存在，则输出Cert illegal 张数不为正整数，输出Ticket number illegal 张数大于该车次该席位的剩余票数，输出Ticket does not enough      添加以下新功能 #    电子钱包功能 #    在现有功能基础上添加电子钱包功能，请根据实际自行选择合适的实现方式\n  精度不做特殊要求，先取小数点后两位，再进行加减即可\n  新增属性：钱包余额\n  新增命令\n 充值余额     命令 参数1 功能描述     rechargeBalance 充值金额 充值余额      输出\n 充值成功输出Recharge Success    异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前无用户登录，输出Please login first 充值金额保证为数字类型，若为负数，输出Arguments illegal    查询余额\n     命令 功能描述     checkBalance 查询余额      输出\n  保留小数点后两位\n[+]checkBalance\rUserName:SB_DYY\rBalance:19198.10     异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前无用户登录，输出Please login first        核酸检测功能 #    购买车票坐席为[1A, 2A]时需要保证系统中最新的核酸检测证明为阴性，若证明为阳性或不存在则无法购票\n  实现导入证明的功能，核酸检测证明从系统外部导入，保证Aadhaar及检测结果格式正确\n  若多次导入结果，进行更新操作。总阳性人数和总阴性人数中的【总人数】表示【当前有证明的全部人员数量】\n  多次导入的不同文件中，若有相同的Aadhaar卡号，则为此人保留最后一次导入的文件中的核酸检测结果\n  创建核酸证明类Cert,添加如下属性和方法\n  属性：自行设计实现相关数据的存储。\n  方法：从CSV数据表批量导入证明（超级管理员模式）\n导入乘客核酸检测证明的命令格式如下：\n   命令 参数1 功能描述     importCert CSV文件名（带.csv扩展名） 机构导入检测结果    CSV文件格式如下（表格无标题），第一列为Aadhaar卡号（保证格式正确），第二列为最新的检测结果（P为阳，N为阴），文件下载地址和文件读取demo详见其他部分\n   002301220991 P     100000720000 N      输出格式：\n 导入成功输出Import Success, Positive:[总阳性人数] Negative:[总阴性人数]    异常处理：\n 命令不存在，输出Command does not exist （命令中）参数数量不正确，输出Arguments illegal    例：\n[+] importCert cert.csv\r[-] Import Success, Positive:1 Negative:1       退票功能 #  用户购买车票后可进行退票，实现以下命令：\n   命令 参数1 参数2 参数3 参数4 参数5 功能描述     cancelOrder 列车车次 出发站 目的站 席位代号 张数 用户退票      说明\n  退票规则\n 相同出发站、目的站、席位的车票，优先从最近一次的订单中退票，最后一个订单张数不足再去寻找其他符合条件的订单进行退票。 退票数小于订单张数，仅修改该订单张数，订票的顺序不发生变化；当一笔订单中的车票数量为0时，应当删除这个订单 已确认支付的订单不予退票 退票后应当立即释放席位（不考虑线程安全问题）。    保证命令中列车车次、出发站、目的站、席位代号、张数均合法，不需额外判断\n  如：\n// 退票顺序\r[+]buyTicket G1001 Shahe Gaolimen SB 50\rThanks for your order\r[+]buyTicket G1001 Shahe Hamazhen SB 20\rThanks for your order\r[+]buyTicket G1001 Shahe Gaolimen SB 20\rThanks for your order\r[+]listOrder\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:20 price:12528.00 paid:F\r[G1001: Shahe-\u0026gt;Hamazhen] seat:SB num:20 price:1872.00 paid:F\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:50 price:31320.00 paid:F\r[+]cancelOrder G1001 Shahe Gaolimen SB 11\rCancel success\r[+]listOrder\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:9 price:5637.60 paid:F\r[G1001: Shahe-\u0026gt;Hamazhen] seat:SB num:20 price:1872.00 paid:F\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:50 price:31320.00 paid:F\r[+]cancelOrder G1001 Shahe Gaolimen SB 4\rCancel success\r[+]listOrder\r[G1001: Shahe-\u0026gt;Hamazhen] seat:SB num:20 price:1872.00 paid:F\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:19 price:11901.60 paid:F // 已支付订单不予退票\r[+]listOrder\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:20 price:12528.00 paid:F\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:50 price:31320.00 paid:T\r[+]cancelOrder G1001 Shahe Gaolimen SB 21\rNo enough orders\r[+]listOrder\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:20 price:12528.00 paid:F\r[G1001: Shahe-\u0026gt;Gaolimen] seat:SB num:50 price:31320.00 paid:T     输出格式\n若退票成功，输出\nCancel success   异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前无用户登录，输出Please login first 未找到匹配的购票信息，输出No such Record 退票张数大于已购张数，输出No enough orders      结算功能 #    新增结算全部订单命令，从电子钱包中扣除余额并修改订单结算状态。一旦扣除后，无法再进行取消订单操作。\n  学生票优惠从最近一笔订单开始抵扣，直到资格耗尽为止，耗尽后其余车票按正常价格计算。购票成功后扣除相应的优惠次数\n 例如：正常票价500，分两次购买，每次购买3张，共有4张优惠资格，则总应付价格为（500*4）*0.05+500*2=1100\n   订单是结算的最小单位，即只能按照整笔订单进行结算，订单的结算状态只有T和F。\n  命令格式如下：\n   命令 功能描述     payOrder 结算订单      输出格式\n 若结算成功，则输出Payment success    异常处理\n 命令不存在，输出Command does not exist 参数数量不正确，输出Arguments illegal 当前无用户登录，输出Please login first 当前无订单，输出No order 电子钱包余额不足以结算全部订单，输出Balance does not enough    说明：在订单的添加、取消和支付部分，我们采用了【栈】的设计思想。可以依此来设计相关的数据结构（仅作参考，不考察具体实现方式）\n    其他 #  cert.csv文件下载地址:\n https://bhpan.buaa.edu.cn:443/link/AED2B7D2568D3AAE55D84895D487EA95 有效期限：2022-06-02 23:59\n评测时，请将CSV文件放到patpat可执行文件相同路径下。例如：\nCTS\\example\r│ cert.csv\r│ cert2.csv\r│ cert3.csv\r│ patpat-windows-amd64.exe\r│\r├─4-学号-姓名\r│ ├─out\r│ └─src\r│ Test.java\r│\r└─test\rcts2.yaml\rjudge.yaml 提交代码时，请保持以上目录结构。\n不要使用excel等软件修改CSV文件，可能会导致格式混乱。\n请保持良好的代码风格以及合理的类封装，下一次实验中可能会添加序列化相关内容。\n请注意：PatPat仅支持单个Scanner对象，使用Scanner读入文件可能导致测评结果错误，请采用其他方式读入！\n 举个栗子(使用BufferedReader)\npublic static HashMap\u0026lt;String, Boolean\u0026gt; read(String fileName) throws IOException {\rHashMap\u0026lt;String, Boolean\u0026gt; cert = new HashMap\u0026lt;\u0026gt;();\rBufferedReader br = new BufferedReader(new FileReader(fileName));\rString line;\rwhile ((line = br.readLine()) != null) {\rString[] lines = line.split(\u0026#34;,\u0026#34;);\rcert.put(lines[0], lines[1].equals(\u0026#34;P\u0026#34;));\r}\rbr.close();\rreturn cert;\r}  "}]