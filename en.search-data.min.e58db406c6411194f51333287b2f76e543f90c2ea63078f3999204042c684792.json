[{"id":0,"href":"/Java-HomeWork/docs/OOP-LAB/","title":"Oop Lab","section":"Docs","content":" LAB -\u0026gt; 这个实验是每周都有的 # 不用太纠结于名字的问题，只需要知道这些东西每周都要写就行了\n（历史遗留\u0026hellip;）\n"},{"id":1,"href":"/Java-HomeWork/docs/OOP-LAB/LAB01/","title":"Lab01","section":"Oop Lab","content":" Lab01: 认识 Java # 1. 实验目的 # 掌握 Java 环境配置 使用 CMD 编译运行 Java 程序 使用 IDE 编译运行 Java 应用程序 理解 Java 语言中的关键字、标识符并能灵活使用 理解、掌握 Java 语言的简单数据类型并能灵活使用（重点强制类型转换） 理解引用数据类型，理解简单数据类型和引用数据类型的特点 理解、掌握 Java 语言中的运算符并能灵活使用 理解、掌握常量与变量的概念并能灵活使用 2. 编译与运行 # Question01 # 借助身边的工具，学习 java， javac 等命令的使用，并尝试通过命令行来编译并运行一个 Java 程序，输出 Hello, World!，提交你所使用的命令和运行结果截图。\nQuestion02 # 相信这一定难不倒聪明的你，接下来我们略微增加一点点难度 ~ 你需要输出很多 Hello, World!\n本题需要你实现一个 Test 类：\n程序开始运行，进入main方法，并输出你的学号和姓名\n当终端输入 QUIT 时，系统退出，并在终端打印一行字符：\n----- Good Bye! ----- 对于其他的输入，在终端中输出一行 Hello, World!，等待下一行输入 你需要提交运行时的截图。\n程序退出 # 和 C 语言的return 0类似，Java 程序也有其退出码，整个程序的正常的退出码应该为 0，而不应该为-1、1 等。\n在测评机中，退出状态非 0 则会被认为是程序未正常结束，很容易导致你的作业被错判，因此请务必注意若需要在循环等程序正在运行时的情况进行退出，应确保退出状态为 0\n下面给出 Java 中退出的一个例子：\nclass Example { public static void main(String[] args) { int x = 0; while (true) { x++; if (x \u0026gt; 10) { System.out.println(\u0026#34;----- Good Bye! -----\u0026#34;); System.exit(0); } } } } // 这只是退出程序的一种方法，当然，针对该例子，你也可以直接使用break，跳出while循环，直接到达整个程序的退出区域（默认退出状态为0） 参考实现 # Java 打印字符串与其他语言有所区别，不是直接调用 print 函数，可以用如下语句： String str = \u0026#34;Hello world!\u0026#34; System.out.println(str); Java 连续读取输入行的一种实现： Scanner in = new Scanner(System.in); String argStr; while (true) { argStr = in.nextLine(); } 留意 Java 的字符串比较的特殊之处\n3. IDE 的使用 # Question03 # (1). 编写以下程序，并运行。将运行结果截图提交。\n(2). 将断点设置在第八行，查看变量 a 的值，提交此刻的屏幕截图。\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); int a = 1; a=a+1; a=a+2; System.out.println(\u0026#34;a is \u0026#34; + a); a=a+3; //断点行 a=a+4; System.out.println(\u0026#34;a is \u0026#34; + a); } } 4. 基本数据类型 # Question04 # 看程序输出结果,并提交结果内容或截图\npublic class App1 { public static void main(String args[]) { // 定义整形变量a和双精度浮点变量b、c int a = 126; double b = 0.2; double c = 1.6; // 创建字符串对象 String str1 = \u0026#34;Hello World\u0026#34;; String str = new String(\u0026#34;字符串不是基本数据类型\u0026#34;); // 输出各个变量 System.out.println(\u0026#34;a=\u0026#34; + a); System.out.println(\u0026#34;b+c=\u0026#34; + (b + c)); System.out.println(\u0026#34;b+c=\u0026#34; + b + c); System.out.println(str); System.out.println(str1); System.out.println(str + str1); } } Question05 # 看程序输出结果,并提交结果内容或截图\npublic class VarDemo { public static void main(String[] args) { byte b = 0x55; boolean B = true; short s = 0x55ff; int i = 1000000; long l = 0xffffL; char c = \u0026#39;c\u0026#39;; float f = 0.23F; double d = 0.7E-3; String S = \u0026#34;This is a string\u0026#34;; System.out.println(\u0026#34;字节型变量 b = \u0026#34; + b); System.out.println(\u0026#34;短整型变量 s = \u0026#34; + s); System.out.println(\u0026#34;整型变量 i = \u0026#34; + i); System.out.println(\u0026#34;长整型变量 l = \u0026#34; + l); System.out.println(\u0026#34;字符型变量 c = \u0026#34; + c); System.out.println(\u0026#34;浮点型变量 f = \u0026#34; + f); System.out.println(\u0026#34;双精度变量 d = \u0026#34; + d); System.out.println(\u0026#34;布尔型变量 B = \u0026#34; + B); System.out.println(\u0026#34;字符串对象 S = \u0026#34; + S); } } Question06 # 运行下面这段代码，体会Integer与int的不同之处，并提供运行结果截图。\npublic class Test { static Integer a; static int b; public static void main(String[] args) { System.out.println(\u0026#34;a is \u0026#34; + a); System.out.println(\u0026#34;b is \u0026#34; + b); a = new Integer(\u0026#34;1\u0026#34;); System.out.println(\u0026#34;now a is \u0026#34; + a); Integer c = new Integer(\u0026#34;1\u0026#34;); System.out.println(a == c); System.out.println(a.compareTo(c)); // 0 is true } } Question07 # 编写一段代码验证 Java 中类的基本数据类型字段（成员变量）的默认初始化值，请按照对应类型的字面量填写。\n基本类型 默认值 基本类型 默认值 byte boolean short char int float long double 5. 短路 # Question08 # 阅读下面这段代码：\n// ShortCircuit.java public class ShortCircuit { static void print(String s) { System.out.println(s); } static boolean test1(int val) { print(\u0026#34;1\u0026#34;); return val \u0026lt; 1; } static boolean test2(int val) { print(\u0026#34;2\u0026#34;); return val \u0026lt; 2; } static boolean test3(int val) { print(\u0026#34;3\u0026#34;); return val \u0026lt; 3; } public static void main(String[] args) { boolean a = test1(0) \u0026amp;\u0026amp; test2(2) \u0026amp;\u0026amp; test3(2); boolean b = test1(1) || test2(1) || test3(1); print(\u0026#34;a is \u0026#34; + a); print(\u0026#34;b is \u0026#34; + b); } } 运行 java ShortCircuit，程序的输出是什么？\n请解释 Java 执行串联逻辑运算时的流程，可以用文字、流程图、伪代码描述。\n思考如何利用短路这个机制来优化程序。\n6. 三元运算符 # Question09 # 看程序输出结果,并提交结果内容或截图\npublic class FindMinMax{ public static void main(String []args) { double temp, max, min; double d1 = 0, d2 = -9.9, d3 = 9.9; temp = d1 \u0026gt; d2 ? d1 : d2; temp = temp \u0026gt; d3 ? temp : d3; max = temp; temp = d1 \u0026lt; d2 ? d1 : d2; temp = temp \u0026lt; d3 ? temp : d3; min = temp; System.out.println(\u0026#34;max = \u0026#34; + max); System.out.println(\u0026#34;min = \u0026#34; + min); } } 7. 局部变量 # Question10 # 看程序输出结果,并提交结果内容或截图\npublic class LocalVar { public static void main(String[] args) { LocalVar localVar = new LocalVar(); // System.out.println(\u0026#34;局部变量 a = \u0026#34; + localVar.a); 引用错误，下同 localVar.print(); // System.out.println(\u0026#34;局部变量变化后 a = \u0026#34; + localVar.a); } public void print() { int a = 10; // 局部变量，下同 double b = 20; System.out.println(\u0026#34;在print()中的局部变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); a = 30; System.out.println(\u0026#34;在print()中的局部变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); } } 8. 全局变量 # Question11 # 看程序输出结果,并提交结果内容或截图\npublic class GlobalVar { int a = 10; // 全局变量,下同 double b = 20; public static void main(String[] args) { GlobalVar globalVar = new GlobalVar(); System.out.println(\u0026#34;全局变量 a = \u0026#34; + globalVar.a); // System.out.println(\u0026#34;全局变量 a = \u0026#34; + a); 错误写法 globalVar.print(); System.out.println(\u0026#34;全局变量变化后 a = \u0026#34; + globalVar.a); } public void print() { System.out.println(\u0026#34;在print()中, 全局变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); a = 30; System.out.println(\u0026#34;在print()中, 全局变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); } } 思考程序中的错误写法，简要描述你的看法。\n"},{"id":2,"href":"/Java-HomeWork/docs/OOP-LAB/LAB02/","title":"Lab02","section":"Oop Lab","content":" Lab02: Java 语法 \u0026amp; 面向对象初步 # 1. 实验目的 # 掌握 Java 环境配置 使⽤ CMD 编译运⾏ Java 程序 使⽤ IDE 编译运⾏ Java 应⽤程序 理解 Java 语⾔中的关键字、标识符并能灵活使⽤ 理解、掌握 Java 语⾔的简单数据类型并能灵活使⽤（重点强制类型转换） 理解引⽤数据类型，理解简单数据类型和引⽤数据类型的特点 理解、掌握 Java 语⾔中的运算符并能灵活使⽤ 理解、掌握常量与变量的概念并能灵活使⽤ 理解、掌握 Java 语⾔的流程控制（重点 switch case break 语句）并能灵活使⽤ 理解、掌握 Java 语⾔的数组的声明、赋值及使⽤ 理解掌握面向对象思维方式，确定问题域，使用面向对象思维解决实际问题 2. Class 初步 # Question01 # 阅读下列 Java 源文件，并回答问题。\npublic class Person { void sayHello() { System.out.print(\u0026#34;您好，很高兴认识您\u0026#34;); System.out.println(\u0026#34;nice to meet you!\u0026#34;); } } class PersonTest { public static void main(String[] args) { Person rover = new Person(); rover.sayHello(); } } （a）上述源文件的名字是什么？\n（b）编译上述源文件将生成几个字节码文件？这些字节码文件的名字都是什么？\n（c）在命令行执行 java Person 得到怎样的错误提示？执行 java personTest 得到怎样的错误提示？执行 java PersonTest.class 得到怎样的错误提示？执行 java PersonTest 得到怎样的输出结果？\nQuestion02 # 编写程序输出自己的学号姓名，运行并截图。\n3. Unicode 编码 # Question03 # 看程序输出结果,并提交结果内容或截图\npublic class Unicode { public static void main(String[] args) { char c = \u0026#39;大\u0026#39;; System.out.println(\u0026#34;\u0026#39;\u0026#34; + c + \u0026#34;\u0026#39;的Unicode编码：\u0026#34; + (int) c); int num = 23398; System.out.println(\u0026#34;Unicode编码为\u0026#34; + num + \u0026#34;的字符是：\u0026#34; + (char) num); } } 4. 数组 # Question04 # 看程序输出结果,并提交结果内容或截图\npublic class UseIntArray { public static void main(String[] args) { int[] intArray = {8, 9, 12, 13, 14}; int sum = 0; for (int i : intArray) { sum += i; } for(int i = 0; i \u0026lt; intArray.length; i++) { System.out.println(\u0026#34;intArray[\u0026#34; + i + \u0026#34;]=\u0026#34; + intArray[i]); } System.out.println(); System.out.println(\u0026#34;sum=\u0026#34; + sum); } } Question05 # 看程序输出结果,并提交结果内容或截图\npublic class TwoDimensionArray { public static void main(String[] args) { int[][] b = {{11}, {21, 22}, {31, 32, 33}}; int sum = 0; b[0][0] = 1000; for(int[] ints : b) { for(int anInt : ints) { sum += anInt; } } System.out.println(\u0026#34;b[0][0]=\u0026#34; + b[0][0] + \u0026#39;\\n\u0026#39; + \u0026#34;sum=\u0026#34; + sum + \u0026#39;\\n\u0026#39; + \u0026#34;b.length=\u0026#34; + b.length); int[][] arr1 = new int[3][4]; int[][] arr2 = new int[3][]; int[][] arr3 = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; int i, j, k = 0; // arr1[][]赋值 for(i = 0; i \u0026lt; 3; i++) { // arr1为3行4列 for(j = 0; j \u0026lt; 4; j++) { arr1[i][j] = k++; } } // arr2[][]开辟内存空间 for(i = 0; i \u0026lt; 3; i++) { // arr2每一行是变长的，元素个数为3、4、5 arr2[i] = new int[i + 3]; } // arr2[][]赋值 for(i = 0; i \u0026lt; 3; i++) { for(j = 0; j \u0026lt; arr2[i].length; j++) { arr2[i][j] = k++; } } // 输出arr1 System.out.println(\u0026#34; arr1:\u0026#34;); for(i = 0; i \u0026lt; 3; i++) { for (j = 0; j \u0026lt; 4; j++) { System.out.print(\u0026#34; \u0026#34; + arr1[i][j]); } } System.out.println(); // 输出arr2 System.out.println(\u0026#34; arr2:\u0026#34;); for(i = 0; i \u0026lt; 3; i++) { for(j = 0; j \u0026lt; arr2[i].length; j++) { System.out.println(\u0026#34; \u0026#34; + arr2[i][j]); } } // 输出arr3 System.out.println(\u0026#34; arr3:\u0026#34;); for(i = 0; i \u0026lt; 3; i++) { // arr3为3行3列 for(j = 0; j \u0026lt; 3; j++) { System.out.print(\u0026#34; \u0026#34; + arr3[i][j]); } } } } 5. switch # Question06 # 阅读下面程序，给出程序的输出结果，为什么？\npublic class SwitchTest { public static void main (String[] args) { char c = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt;= 4; i++) { switch(i) { case 1: c = \u0026#39;J\u0026#39;; System.out.print(c); case 2: c = \u0026#39;e\u0026#39;; System.out.print(c); break; case 3: c = \u0026#39;p\u0026#39;; System.out.print(c); default: System.out.print(\u0026#34;好\u0026#34;); } } } } 6. 循环 # Question07 # 请实现程序输出以下 5*5 数字方格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 需要在 main 函数的输入参数中设置 5，输出 5*5 的数字方格。如果是输入 7，则是 7*7 的数字方格。需要提交代码及运行结果截图。\nQuestion08 # 请实现程序输出以下星塔\n需要在 main 函数的输入参数中设置 5，输出 5 层星塔。如果是输入 7，则输出 7 层星塔。假设输入参数都是奇数，且都大于等于 5，小于等于 11，提交代码及运行结果截图。\n* *** ***** *** * Question09 # 编写静态方法 double getPi(int n)，利用公式 $$ \\pi = 4\\sum_{i=0}^{n}{\\frac{\\left(-1\\right)^{i}}{2i+1}} $$ 求 pi 的近似值，需求如下\n/** * 利用公式求指定精度的圆周率 * 如果n是负数，视其为0 * @param n 公式中的i的上限 * @return 圆周率的近似值 */ public static double getPi(int n); 题外话：\n如果 n 是负数，视其为 0\n有穷求和的区间是闭区间，上限 n 对应的级数项也是要被计算的。\nQuestion10 # 快速排序\n编写静态方法int[] qsort(int[] arr)，需求如下：\n/** * 对一个int数组进行快速排序，结果是升序的，并且不会开辟额外的数组空间 * @param arr 待排序的数组 * @return 升序排列好的arr，如果arr==null，则返回null */ public static int[] qsort(int[] arr); 约束：\n返回值必须是原数组，即 return arr。\n可以任意次创建指向原数组的引用，但是请不要在排序过程中创建新的数组。\n可以根据需要定义新的函数。\n如果数组是 null，返回 null。\n对于空数组(arr.length==0)，原样返回，而不是 null。\n这一次请不要使用 java.util.Array.sort()之类的操作。\nQuestion11 # 现有一组数据分别是：12,45,67,89,123,-45,67，实现以下两步：\n(1) 请对这组数据排序后，按照从小到大的顺序打印；\n(2) 从键盘输入任意整数，程序判断该整数是否存在该数组中；\nQuestion12 # 阅读下面代码并查看输出结果：\n增强for循环\npublic class ForPower { public static void main(String[] args) { for(char c : \u0026#34;An African Swallow\u0026#34;.toCharArray()) System.out.print(c + \u0026#34; \u0026#34;); } } 7. 引用 # Question13 # 阅读下面这段代码：\nclass Point { int x, y; void setArgs(int m, int n) { x = m; y = n; } } public class PointTest { public static void main(String[] args) { Point p1, p2; p1 = new Point(); p2 = new Point(); System.out.println(\u0026#34;p1的引用:\u0026#34; + p1); System.out.println(\u0026#34;p2的引用:\u0026#34; + p2); p1.setArgs(1111, 2222); p2.setArgs(-100, -200); System.out.println(\u0026#34;p1的x,y坐标:\u0026#34; + p1.x + \u0026#34;,\u0026#34; + p1.y); // 1 System.out.println(\u0026#34;p2的x,y坐标:\u0026#34; + p2.x + \u0026#34;,\u0026#34; + p2.y); // 2 p1 = p2; p1.setArgs(0, 0); System.out.println(\u0026#34;p1的引用:\u0026#34; + p1); System.out.println(\u0026#34;p2的引用:\u0026#34; + p2); System.out.println(\u0026#34;p1的x,y坐标:\u0026#34; + p1.x + \u0026#34;,\u0026#34; + p1.y); // 3 System.out.println(\u0026#34;p2的x,y坐标:\u0026#34; + p2.x + \u0026#34;,\u0026#34; + p2.y); // 4 } } 请指出代码中注释标注出的四行输出的内容会是什么。\n题外话：\n意在理解 Java 对象实例是作为引用存在的。\n如果你要为一个类实现 copy() 方法，思考如何避免引用间赋值导致的浅拷贝？或者说，如何确保进行的是深拷贝。你需要查一下什么是浅拷贝？什么是深拷贝？\n同样的问题也存在于 String 的 == 和 equals() 方法，对于不同的背景，相等的定义可能也不同。\nQuestion14 # 阅读下面程序，给出程序的输出结果，为什么？\npublic class ArrayTest { public static void main(String[] args) { int[] a = {1, 2, 3, 4}; int[] b = {100, 200, 300}; System.out.println(\u0026#34;数组a的元素个数=\u0026#34; + a.length); System.out.println(\u0026#34;数组b的元素个数=\u0026#34; + b.length); System.out.println(\u0026#34;数组a的引用=\u0026#34; + a); System.out.println(\u0026#34;数组b的引用=\u0026#34; + b); a = b; System.out.println(\u0026#34;数组a的元素个数=\u0026#34; + a.length); System.out.println(\u0026#34;数组b的元素个数=\u0026#34; + b.length); System.out.println(\u0026#34;a[0]=\u0026#34; + a[0] + \u0026#34;,a[1]=\u0026#34; + a[1] + \u0026#34;,a[2]=\u0026#34; + a[2]); System.out.print(\u0026#34;b[0]=\u0026#34; + b[0] + \u0026#34;,b[1]=\u0026#34; + b[1] + \u0026#34;,b[2]=\u0026#34; + b[2]); } } 8. 可变参数 # Question15 # 看程序输出结果,并提交结果内容或截图:\npublic class VarArgs { public static void main(String[] args) { f(1, 2); f(-1, -2, -3, -4); //给参数传值时，实参的个数很灵活 f(9, 7, 6); } public static void f(int... x) { //x是可变参数的代表，代表若干个int型参数 for (int i = 0; i \u0026lt; x.length; i++) { //x.length是x代表的参数的个数 System.out.println(x[i]); //x[i]是x代表的第i个参数(类似数组) } } } Question16 # 编写静态方法String strscat(String... args)，需求如下：\n/** * 将任意个字符串顺序连接，不应该改变任意一个原有参数 * @param args 字符串们 * @return args中的字符串顺序连接组成的新字符串 */ public static String strscat(String... args); 样例：\n调用方法 返回值 strscat(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;e\u0026rdquo;) \u0026ldquo;abce\u0026rdquo; strscat(\u0026ldquo;str\u0026rdquo;) \u0026ldquo;str\u0026rdquo; 回答：\n请尝试理解 Java 可变参数的实现机制。\n调用strscat(new String[]{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;})能通过编译吗？\n如果还有静态方法String strscat(String[] args)同时存在，代码能编译通过吗？这时传入的参数是什么？又会返回什么？\n如果我们声明的是String strscat(String[] args)，strscat()这样的调用还能通过编译吗？如果能，这时传入参数和返回值的情况和String strscat(String... args)通过相同吗？\n9. 面向对象（复习并完成课堂知识点） # Question17 # 减肥。小王本来体重 70Kg，经过减肥，体重降到 45Kg，试从这个问题领域中识别对象、类、属性、行为、状态，和状态变化。尝试将你抽象出来的类用 Java 代码实现出来，并编写一个测试类，来描述上述过程。\nQuestion18 # 制作一桌丰盛的年夜饭。定义采购员类和厨师类的属性和行为，在测试类中产生采购员的对象：姑姑，妈妈和你，在测试类中产生出厨师的对象：爸爸和婶婶，协同制作年夜饭。\n"},{"id":3,"href":"/Java-HomeWork/docs/OOP-LAB/LAB03/","title":"Lab03","section":"Oop Lab","content":" Java 程序设计 Lab03 # 实验目的 # 理解并掌握类的概念 理解并掌握对象的概念 理解类与对象的关系 理解面向对象中抽象过程 理解面向对象中的消息 理解 Java 程序的基本结构并能灵活使用 理解并掌握 Java 类的定义（成员变量、成员方法和方法重载） 理解并掌握 Java 类的构造函数（默认构造函数、带参数构造函数），理解重 载的构造函数并灵活使用 理解 Java 垃圾内存自动回收机制 理解并掌握 Java 类变量和类方法 实验题目 # Question1: 简答题 # 编译下面这个类：\npublic class Sample { int x; // 1 long y = x; // 2 public void f(int n) { int m; // 3 int t = n + m; // 4 } public static void main(String[] args) { Sample t=new Sample(); t.f(5); System.out.println(t.x); } } 注释标记的哪些行会导致编译错误，为什么?\nQuestion2: 简答题 overload # 阅读下面代码：\npublic class Overload{ Overload(int m){} Overload(double m){} int Overload(int m){return 23;} void Overload(double m){} } 对于Overload类，下面哪些叙述是错误的，为什么错？\na. Overload(int m)与Overload(double m)互为重载的构造方法。 b. int Overload(int m)与void Overload(double m)互为重载的非构造方法。 c. Overload类有 2 个构造方法，尝试调用默认构造方法Overload()会无法通过编译。 d. Overload类有 3 个构造方法。 Question3: 编程题 overload2 # 创建一个Dog类，不编写构造方法，在main()中new一个Dog实例，验证编译器是否自动添加了无参构造方法。 在上面的Dog类的基础上，编写一个构造方法Dog(int age)，在其中输出狗有age岁的信息，并测试此时能否调用无参的构造方法。 在上面的Dog类的基础上，编写一个构造方法Dog(int age, String name)，输出狗的姓名为name的信息，并在该构造方法中调用另一个构造方法this(age)，避免代码复用。 在上面的Dog类的基础上，编写重载的bark()方法，此方法根据类型进行重载，根据被调用的版本，打印出不同类型的狗吠（barking），咆哮（howling）等信息，调用所有不同版本的方法进行测试。 在上面的Dog类的基础上，再编写两个重载的bark()方法，各自接受两个不同类型的参数，只是两个bark()的参数接受顺序相反，在main()中验证是否工作。 你需要在 answer.md 中说明如下内容\n目录名为：Question3 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置) Question4: 简答题 overload3 # 阅读下面这段代码：\npublic class Overload2 { int a,b; int c=-1; public Overload2(){a=-2;} public Overload2(int p1,int p2){a=p1; b=p2;} public Overload2(int p1,int p2,int p3){ this(p1,p2); c=p3; } @Override public String toString(){ return String.format(\u0026#34;(a,b,c)=(%d,%d,%d)\u0026#34;,a,b,c); } public static void main(String args[]){ Overload2 s = new Overload2(); System.out.println(s); System.out.println(new Overload2(5,6)); System.out.println((new Overload2(2,3,4)).toString()); } } 运行java Overload2，程序的输出是什么？\n题外话：\n根据void java.io.PrintStream.print()系列函数的实现，当传入的 String 或 Object 是 null 时，最后都会导致输出字符串”null”，而不是什么都不输出。\n进行字符串连接时也一样：\u0026quot; \u0026quot; + null 的结果是 \u0026quot;null\u0026quot;。\n因此当涉及相关操作时需要稍微注意一下。\n具体原因参见java.io.PrintStream、java.lang.String的源代码。\nQuestion5: 简答题 finalize # 阅读下面这段代码：\npublic class User { public static int userCount = 0; public User() { ++userCount; } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\u0026#34;bye\u0026#34;); --userCount; } public static void main(String[] args) { System.out.println(User.userCount); // 1 User u = new User(); System.out.println(User.userCount); // 2 u = null; System.out.println(User.userCount); // 3 System.gc(); System.out.println(User.userCount); // 4 } } 注意代码中用注释标出的四行System.out.println(User.userCount)，某些行的输出结果有多种可能。\n运行java User，程序的输出可能是什么？\n你需要在 answer.md 中说明如下内容\n注释标记行 可能的输出内容 1 2 3 4 有什么办法可以让finalize()在main()结束前一定被调用吗？\n题外话：\n和 C++不同，在 Java 中显式重写 finalize() 通常是不必要的。\njava.lang.System.gc()只会在需要的时候执行垃圾收集，你的调用只是一个“建议”。\nQuestion6: 编程题 # 写一个音乐类，并编写测试类显示音乐信息（音乐名称、音乐类型）。\n写一个手机类，并编写测试类显示手机信息（手机品牌、手机型号）\n你需要在 answer.md 中说明如下内容\n目录名为：Question6 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置) 唠叨两句：\n手机类和音乐类都需要完成 “显示信息” 这样的功能，那我们能否将这一功能封装起来实现呢？\n比如我们可以让手机类和音乐类都实现一个 IMessage 接口， 他们就有了统一的测试方法：\nclass Test { public static void main(String args[]) { IMessage music = new Music(); IMessage mobile = new Mobile(); music.print() mobile.print() } } 当然，在这个题中，使用这样的实现方式未免有点 “过度封装”。\n如果之后完成个人 / 团队大作业时遇到了类似的场景，不妨在想一想能否应用上述的模式进行设计。\nQuestion7: 编程题 # 编写程序,在其中定义两个类：\nPerson 类： 属性有 name、age 和 sex 提供你认为必要的构造方法 方法 setAge() 设置人的合法年龄 (0~130) 方法 getAge() 返回人的年龄 方法 work() 输出字符串“working” 方法 showAge() 输出 age 值 TestPerson 类： 创建 Person 类的对象，设置该对象的 name、age 和 sex 属性 调用 setAge() 和 getAge() 方法，体会 Java 的封装性。 创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。 你需要在 answer.md 中说明如下内容\n目录名为：Question7 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置) Question8: 编程题 # 编写一个 Java 命令行程序，只从标准输入读取一行用户输入，判断这行输入是否是一个没有前导 0 的无符号整数；如果是，则还要判断该数字是否是一个回文数。输出你的判断和执行结果。\n对于“没有前导 0 的无符号整数”的定义：\n是一个字符串 s s 的长度至少是 1，没有上限要求 s 的字符集 Σ={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}，其他所有字符都不应该出现在 s 中 当 s 的长度大于 1 时，若从其首部开始有若干个连续字符 0，那么这些字符 0 都叫做 s 的“前导 0” 比如数字串 00010020，有三个前导 0 比如数字串 01，有 1 个前导 0 比如数字串 102030，没有前导 0 比如数字串 0，没有前导 0 本题对于回文数的定义：\n是一个字符串 s s 的长度至少是 1，没有上限要求 s 的字符集 Σ={0, 1, 2, 3, 4, 5, 6, 7, 8, 9}，其他所有字符都不应该出现在 s 中 将 s 中的字符逆序排列并去除前导 0 得到的数字串 r，有 s 和 r 完全相同 s=123 时，r=321，不相同，s 和 r 都不是回文数 s=12321 时，r=12321，相同，s 是回文数 s=12100 时，r=121，不相同，s 不是回文数，但 r 是回文数 s=1 时，r=1，相同，s 是回文数 s=0 时，r=0，相同，s 是回文数 本题将输入的一行字符视为一个完整的字符串，如果输入的是诸如“121 121”这样包含空格的串，虽然 121 是回文数，但是整个串不应该被认为是回文数。如果将字符集扩充为包含空格的其他字符集，那么“121 121”就是一个该字符集下的回文串，不过本题的字符集限定为由 0~9 这十个数字组成的字符集。\n你需要在 answer.md 中说明如下内容\n目录名为：Question8 文件名有：(如果你放了一个项目进来，则说明你的项目结构以及入口位置) "},{"id":4,"href":"/Java-HomeWork/docs/OOP-LAB/LAB04/","title":"Lab04","section":"Oop Lab","content":" Java 程序设计 LAB04 # 实验目的 # 理解封装含义 理解信息隐藏的必要性 掌握访问控制修饰符的使用 私有成员（变量和方法）的理解和使用 共有成员的理解和使用 保护成员的理解和使用 使用不加任何权限修饰符的成员 加深对“类和对象”的理解 注意事项 # 建议建立一个自己的统一且良好的代码风格，比如命名风格（camelCase、snake_case 等）、缩进方式（空格数量、switch-case 缩不缩进等）、开闭大括号换不换行等容易引发战 争（迫真）的东西，以养成良好的编程习惯。\n编程题最好为每一个类编写一个完备的测试类，覆盖尽可能多的输入、函数调用、输出，以证明代码正确实现了功能。\n如果编程题使用了 package 语句，应当确保提交时目录结构和 package 语句表达的包结构相同。（IDE 很多时候会帮你做）\n编程题在给出了具体需求的情况下，可以根据自己的需要添加额外的方法。\n实验题目 # 初始化 I # 阅读下面这段代码，尝试理解 Java 中初始化的顺序：\nclass A { int value; static A a1 = new A(1); public A(int i) { System.out.println(\u0026#34;initialize A\u0026#34;+i); value = i; } public A(A a) { System.out.println(\u0026#34;copy from A\u0026#34;+a.value); value = a.value; } static A a2 = new A(2); } class B { A a8; // A a7 = new A(a6); A a6 = new A(6); static A a3 = new A(3); static A a4; static { a4 = new A(4); } static A a5 = new A(5); public B(int i) { System.out.println(\u0026#34;initialize B\u0026#34;+i); a8 = new A(8); } A a7 = new A(a6); } public class Initialization { static B b1 = new B(1); static B b2; public static void main(String[] args) { System.out.println(\u0026#34;main begins\u0026#34;); A a9 = new A(9); b2 = new B(2); System.out.println(\u0026#34;main ends\u0026#34;); } } Question1 # 阅读这段代码，请问程序的输出是什么？\nQuestion2 # 对于非静态属性，它的初始化方法有两种：\n在属性定义处显式初始化（如本例中的 a6）； 在构造方法或非静态方法中初始化（如本例中的 a8）； 这段代码能够证明“在属性定义处初始化的属性，比在方法中初始化的属性先被初始化”吗？\n这段代码能够证明“在属性定义处初始化的属性，初始化顺序等同于他们在类定义中出现的顺序”吗？\nQuestion3 # 请尝试仿照 Q2 的内容，描述静态属性的初始化方式和实际初始化时的顺序。\nQuestion4 # 已知 static 属性的初始化、static 块的执行，只在 JVM 进行类加载的时候执行。这段代码能够证明 “在类的实例第一次被构造、或类的静态属性和静态方法第一次被访问时，JVM 会执行类加载”吗？如果不能，请尝试修改代码并证明。\n题外话 # 懒加载：lazy load，对某资源只在需要时才寻找其存在并初始化；对立面是预加载。\n预加载：提前加载好所有资源，等待使用资源的那一刻。\n对于一些使用频率较低但初始化开销很大的资源，懒加载可以避免他们给程序的初始化增加过多的负担。\nJVM 的类加载是懒加载，只有在程序第一次使用到某个类时才去尝试读取其.class 文件。类加载只会进行一次，这一次类加载会完成所有的静态初始化工作。更多内容会在后续课程讲解 RTTI 和反射的时候提到。\n在游戏编程中，当某一个类的所有实例都使用同一批贴图文件时，可以将贴图资源声明为 static 属性并直接（或在 static 块）初始化。让类的贴图属性引用这些静态资源，这样就可以避免为每一个对象构造单独的贴图文件导致的内存浪费和时间浪费。\n单例模式 # 阅读下面这段代码，它实现了经典设计模式之一————单例模式（singleton pattern）：\n/** * Singleton 一个最简单的单例模式的实现 */ public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return uniqueInstance; } public void foo() { System.out.println(\u0026#34;Aha!\u0026#34;); } } Question5 # 其他的外部类可以通过new Singleton()来构造一个新的Singleton变量吗？\nQuestion6 # 本题给出的 Singleton 类的写法被称为单例模式，是因为这个类最多只可能有 1 个实例同时存在。为什么只可能有 1 个？这个唯一的实例在什么时候被构造？\nQuestion7 # 请写出任意一种外部类调用 Singleton 类的 foo()的方法。\n题外话 # 这里的 uniqueInstance 初始化方法不是懒加载（lazy load）的，因为 uniqueInstance 在类加载时就被初始化了，虽然我们可能最终并用不到它。你可以思考一下如何实现一个懒加载的单例模式。\n"},{"id":5,"href":"/Java-HomeWork/docs/OOP-LAB/LAB05/","title":"Lab05","section":"Oop Lab","content":" Java 程序设计 LAB05 # 实验目的 # 理解继承的必要性 理解继承的基本概念：单继承，多继承 掌握继承的使用 子类属性、构造方法和一般成员方法的书写的编写 变量隐藏 this 和 super 的使用 向上映射 在继承的基础上加深理解权限控制符的使用 保护成员的使用 方法覆盖（初步，重点放在多态一章） 复合与继承的区别及使用 注意事项 # 建议建立一个自己的统一且良好的代码风格，比如命名风格（camelCase、snake_case等）、缩进方式（空格数量、switch-case 缩不缩进等）、开闭大括号换不换行等容易引发战争（迫真）的东西，以养成良好的编程习惯。编程题最好为每一个类编写一个完备的测试类，覆盖尽可能多的输入、函数调用、输出，以证明代码正确实现了功能。如果编程题使用了 package 语句，应当确保提交时目录结构和 package 语句表达的包结构相同。（IDE 很多时候会帮你做）编程题在给出了具体需求的情况下，可以根据自己的需要添加额外的方法。\n大家可以在 vscode、IDEA 等 IDE 上找到对应的代码风格检查工具，也可以自己设置自己的代码风格文件，可自行搜索了解 例如： vscode 插件 checkstyle\n实验题目 # Question1. Package # 浏览 Code 文件夹中的 Question01 目录，不允许变更目录结构和文件位置，只允许在文件中添加 package 和 import 语句，使根目录下 build 和 test 文件中的指令可以无报错顺利执行。\n建议通过右键 Question01 文件夹以 vscode、IDEA等IDE打开，或直接在IDE内打开 Question01 文件夹，以确保构建正确的项目结构，下同。\nQuestion2. 权限 # 阅读 Code 文件夹中的 Question02 目录，根据你对访问权限的理解。将文件中所有无法通过编译的语句注释掉。\n你遇到的问题可能会集中在 protected 和默认访问权限。 从这次实验和上一次实验，可以引申出几个问题：\nLAB03 中的单例模式，或者说所有构造方法都是 private 时，可能有子类吗？ final 类可以视为所有构造方法都是 private 的类吗？ 简单谈谈你的见解。\nQuestion3. Hide \u0026amp; Override # 阅读：\nclass Parent { int num = 4; protected void foo() { System.out.println(\u0026#34;foo() of Parent\u0026#34;); } static protected void bar() { System.out.println(\u0026#34;bar() of Parent\u0026#34;); } } class Child extends Parent { int num = 5; protected void foo() { System.out.println(\u0026#34;foo() of Child\u0026#34;); } static protected void bar() { System.out.println(\u0026#34;bar() of Child\u0026#34;); } } public class Test { public static void main(String[] args) { Parent f1 = new Parent(); System.out.println(f1.num); Parent f2 = new Child(); System.out.println(f2.num); Child c = new Child(); System.out.println(c.num); f1.foo(); f2.foo(); c.foo(); f1.bar(); f2.bar(); c.bar(); } } a. 执行 java Test，程序的运行结果是什么？ b. 如果将子类的 protected void foo()改为默认访问权限，程序还能通过编译吗？ c. 如果将子类的 protected void bar()改为默认访问权限，程序还能通过编译吗？ d. foo 和 bar 的测试输出结果表现一致吗？ e. 属性、静态方法、非静态方法，哪些可以覆盖（重写、override），哪些可以隐藏？\n在想要覆盖的时候，主动写一个@Override 注解，可以提高代码可读性，也可以防止你想要覆盖但是写成了重载的情况发生。不想让父类方法在子类中被覆盖的时候，将父类方法声明为 final 的\nQuestion4. 组队副本 # 定义一个 Room 类，在其中声明一个属性代表这个房间的最大组队人数，提供对这个属性的 setter。创建一个 Room 的派生类：SpiralAbyss（即SpiralAbyss继承于 Room）。\nSpiralAbyss类需增加一个ArrayList\u0026lt;Person\u0026gt;类型的属性：partner，表示当前组队同伴列表，并使得列表类型最长不超过最大组队人数。并增加你觉得合适的方法。\n定义一个Person类，加入你觉得合适的属性和方法（至少有人物名字），用于生成多个不同的对象加入组队同伴列表，结合SpiralAbyss试图实现以下场景：\n生成SpiralAbyss的实例以及多于最大组队人数的Person的实例。 将Person的实例逐一加入SpiralAbyss的实例的组队同伴列表中，直到超过最大组队人数，添加失败并打印提示信息。 打印当前组队同伴列表中所有同伴的名字。 Question5. shape # 阅读下面的二维形状类 Shape 的描述：\npublic abstract class Shape { protected double a; protected double b; public Shape() { this(0.0, 0.0); } public Shape(double a, double b) { this.a = a; this.b = b; } /** calcArea * 计算形状的面积 * @return 面积 */ abstract public double calcArea(); /* 其他必要的方法，比如 getter 和 setter */ } 你的任务是：\n编写 Rectangle 类，a 和 b 分别代表矩形两条边的长度（长和宽）； 编写 Rhombus 类，a 和 b 分别代表两条菱形对角线的长度； 编写 Ellipse 类，a 和 b 分别代表椭圆两个半轴（半长轴和半短轴）的长度； 编写一个测试类，构造子类对象并测试 注意：\n上述三个类都继承自 Shape 类，都必须要 override 方法 calcArea； a 和 b 都不能是负数，当通过 constructor 或者 setter 设定为负数时，将对应的值 置为 0.0，或 throw 异常； a 和 b 的大小关系没有任何约束，没有“a 必须不小于 b”的说法。 我们知道属性不设置为 public 是为了保护数据，如果 a 和 b 在 Shape 中的访问权限被设置为 private，在不添加新的属性的情况下，子类想要实现自己的 calcArea()该怎么办？\nQuestion6. 其实 OOP Lab 里面也可以写操作系统 # 操作系统中，有一个概念叫做文件系统。以 Windows 为例，其文件系统中的文件可以粗略地分为以下四种：\n文件夹（包含一个子目录） 快捷方式（打开它等价于打开其所指向的文件） 可执行文件（.exe 这种不需要借助其他程序就能直接运行的文件） 不可执行文件（本身无法运行，需要借助其他程序（打开方式）才能正确使用） 以上四种，都是“文件”。所有文件的属性都有：\n名称（不能为空，字符集是 ASCII 可打印字符） 创建时间（年月日时分秒） 大小（以 byte 为单位，是整数） 内容（字节序列） 位置（直接包含此文件的文件夹） 文件夹：\n不考虑 OS 层面的内存对齐，文件夹的大小等于其内部所有文件的大小的加和； 文件夹的额外属性是，他的直接子目录中包含的文件夹数和其他文件数； 打开文件夹，会切换当前的工作路径到该文件夹下，初始工作路径我们认为是 C 盘； 可以在文件夹中添加新的文件；\n快捷方式：\n本质是一个类型为.lnk 的文件； 快捷方式的额外属性是其指向的文件（可以是任何文件，包括快捷方式和文件夹）； 打开快捷方式，等价于打开其指向的文件；指向的文件被删除后，无法打开快捷方式； 注意，快捷方式的所有属性，都代表其本身，不代表其指向的文件；\n可执行文件：\n打开就是运行其内容。\n不可执行文件：\n没有给出打开方式的情况下，无法被正确打开。\n任务：\n抽象出上述文本中的属性、方法、继承和组合信息，编写多个类描述上述关系。 不用实现很具体的功能，甚至不用实现可以交互的程序，仅需写一些方法调用的示例代码运行，打印相关信息并截图。但是不能有逻辑硬伤和编译错误。\n你可能需要回忆一下 C 中的结构体，学习一下 Java 中的 enum 类\n考虑建立一个文件类包含它们共有的属性和方法，再通过继承文件类来优化代码。\n"},{"id":6,"href":"/Java-HomeWork/docs/OOP-LAB/LAB06/","title":"Lab06","section":"Oop Lab","content":" Java 程序设计 LAB06 # 实验目的 # 理解静多态和动多态的概念 理解多态的必要性和实现机制 理解并灵活使用方法重载和方法覆盖 理解并灵活使用抽象类和抽象方法 理解接口的必要性（将接口用作 API） 掌握如何定义接口、实现接口 将接口用作类型、使用接口回调 理解并掌握接口的继承 面向接口的编程 简单了解 Object 类 掌握良好重写 Object 类中方法的能力 实验题目 # Question01 多态 1 输出/简答题 # 阅读下面这段代码：\n// Test.java class PrivateOverride { private void f() { System.out.println(\u0026#34;private f()\u0026#34;); } public static void main(String[] args) { PrivateOverride po = new Derived(); po.f(); } } class Derived extends PrivateOverride { public void f() { System.out.println(\u0026#34;public f()\u0026#34;); } } public class Test { public static void main(String[] args) { PrivateOverride.main(args); } } 运行 java Test，程序的输出是什么？ 如果将父类中的方法声明为 public，而子类为 private，编译能通过吗？如果能，最后 会输出什么？ 题外话 # private 方法被默认是 final 的\nQuestion02 多态 2 输出/简答题 # 阅读下面这段代码：\n// Test.java class Super { public int field = 0; public int getField() { return field; } } class Sub extends Super { public int field = 1; public int getField() { return field; } public int getSuperField() { return super.field; } } public class Test { public static void main(String[] args) { Super sup = new Sub(); // Upcast System.out.println(\u0026#34;sup.field = \u0026#34; + sup.field + \u0026#34;, sup.getField() = \u0026#34; + sup.getField()); Sub sub = new Sub(); System.out.println(\u0026#34;sub.field = \u0026#34; + sub.field + \u0026#34;, sub.getField() = \u0026#34; + sub.getField() + \u0026#34;, sub.getSuperField() = \u0026#34; + sub.getSuperField()); } } 运行 java Test，程序的输出是什么？ 类的非静态属性能体现多态性吗？ Question03 多态 3 输出/简答题 # 阅读下面这段代码：\n// Test.java class StaticSuper { public static String staticGet() { return \u0026#34;Base staticGet()\u0026#34;; } public String dynamicGet() { return \u0026#34;Base dynamicGet()\u0026#34;; } } class StaticSub extends StaticSuper { public static String staticGet() { return \u0026#34;Derived staticGet()\u0026#34;; } public String dynamicGet() { return \u0026#34;Derived dynamicGet()\u0026#34;; } } public class Test { public static void main(String[] args) { StaticSuper sup = new StaticSub(); // Upcast System.out.println(StaticSuper.staticGet()); System.out.println(sup.dynamicGet()); } } 运行 java Test，程序的输出是什么？ 类的静态属性和静态方法能体现多态性吗？ Question04 多态 4 输出/简答题 # 阅读下面这段代码：\n// Test.java class A { void draw() { System.out.println(\u0026#34;A.draw()\u0026#34;); } A() { System.out.println(\u0026#34;A() before draw()\u0026#34;); draw(); System.out.println(\u0026#34;A() after draw()\u0026#34;); } } class B extends A { private int b = 1; B(int b) { this.b = b; System.out.println(\u0026#34;B(), b = \u0026#34; + this.b); } void draw() { System.out.println(\u0026#34;B.draw(), b = \u0026#34; + this.b); } } public class Test { public static void main(String[] args) { new B(5); } } 运行 java Test，程序的输出是什么？ 结合之前实验的初始化顺序和多态，给出程序这样输出的解释。 Question05 ShapeFactory 1 编程题 # 在 LAB04 的 Shape 的基础上，实现一个满足如下需求的 ShapeFactory 类：\n提供一个 ShapeType 的枚举类，其中有表示矩形、菱形、椭圆的枚举量； 具有方法 public Shape makeShape(ShapeType type, double a, double b) ，返回 一个由 type 指定类型，a 和 b 指定大小的形状； 参数不合法时，返回 null 或抛出异常 具有方法 public Shape randomNextShape() ，返回一个随机类型，随机大小的形状； 随机得到的形状要合法 不能随机出来 null 编写测试类：\n使用以上的两种生成形状的方式，分别随机生成五个形状并存储到 Shape 类型的 数组（或其他容器）中，最后使用 foreach 循环将他们的面积输出 注意：不能修改上一次的 Shape。\n题外话 # 这题不是设计模式中的工厂方法模式（factory method pattern）。本题中的工厂，如果你为 Shape 添加了一个新的子类（比如直角三角形类），那么你就需要给 ShapeType 添加新的枚举量，还要重新写 makeShape 和 randomNextShape。\nQuestion06 Overload？Override？ 简答题 # 阅读下面这段代码：\n// Test.java interface I0 { void f(); // 默认是 abstract public 的 } interface I1 { void f(); } interface I2 { int a = 2; // 默认是 static public final 的 int f(); } interface I3 { int a = 3; int f(int i); } interface I4 { void f(int i); } class Test01 implements I0, I1 { @Override void f() { } } class Test02 implements I0, I2 { @Override void f() { } @Override int f() { return 0; } } class Test23 implements I2, I3 { @Override int f() { return a; } @Override int f(int i) { return i; } } 这段程序是无法通过编译的，都有哪些原因呢？尝试从继承、覆盖、重载的角度考虑。 如果 I1 extends I0，会引入新的错误吗？I2、I3 也 extends I0 呢？ 题外话 # 在任何支持多重继承的语言中，多个父类拥有相同的函数名都会带来误会，如果不是万不得已，千万不要这么做。 还有更多复杂的情况： 比如 class B extends A implements I 比如 class A implements I1，class B extends A implements I2 更多情况请自行尝试并理解。 附加题 # 附加题可以在时间不充足时先略过，但请务必在完成作业期间或者完成后完成一遍，附加题包括的知识点并不重复，甚至更为重要，放到附加题不代表这些题是不重要的\n话句话说， 你在提交实验报告的时候， 可以不完成下面的题目。\n只要完成了基础的 6 个题目，即可拿到本次实验的全部分数\nExtra 1 策略模式（Strategy Pattern） 编程题 # 如果一些方法只保留了业务中逻辑固定不变的部分，只依据参数的不同来产生不同的行为，符合这样的方法，就是符合策略模式（Strategy Pattern）。\n接口经常用于策略模式。定义 interface ITextProcess：\n具有方法 String process(String s) 利用 interface ITextProcess 完成几个类：\nclass Splitter，其 process 方法将 s 中的所有空格都去掉。 class UpperCaseProcessor，其 process 方法将 s 中的所有字符都变为大写的。 class SnakeCaseProcessor，其 process 方法将 s 转变为 snake_case snake_case 指的是不用空格而用下划线分隔单词 I hate ddl -\u0026gt; I_hate_ddl have a good time -\u0026gt; have_a_good_time 编写测试类：\n提供方法public static void process(ITextProcess p, String s)，在其中使用 p 处理 s，并输出处理结果 在 main 中测试你的功能 题外话 # 本题中，业务逻辑不变的是使用一个文本处理器处理文本，变化的是使用的处理器和文本内容。测试类的 process 方法是符合策略模式的。这样可以保证也实现了 ITextProcess 的类在添加到系统时，无需对原有代码产生影响，在这种情况下，保证了原有代码的可复用性。interface 在这里的作用，就是定义一个标准，定义一种框架。如果没有 interface，那么我们就需要像第五题的 ShapeFacotry 一样，通过参数指定处 理器的类型，为原有代码增加更多的特殊情况判断。\n使用 interface 而不使用继承的另一个原因是：现实场景下，Splitter 等可能需要继承其他类，而 TextProcess 并没有必须要有的属性，所以没有必要让他们都继承一个 abstract class TextProcessor。如果出现了不得不同时继承多个类的情况，后续实验会提到装饰器模式（Decorator Pattern），也可以通过拆解类结构来化继承为组合。\nExtra 2 真·工厂方法模式 编程题 # 在 LAB05 的 Shape 的基础上，定义一个满足如下需求的 IShapeFactory 接口：\n具有方法 Shape makeShape(double a, double b) ，返回一个由 a 和 b 指定大小的形状； 参数不合法时，返回 null 或抛出异常 为每一种形状编写它的工厂类：\n比如生成矩形的工厂类 RectangleFactory 要 implements 接口 IShapeFactory。 编写测试类 ShapeFactoriesTest：\n具有 static 方法 Shape makeShape(IShapeFactory factory, double a, double b) ，在其中使用 factory.makeShape(a, b)方法生成形状并返回 在 main 方法中声明所有 3 种工厂，将他们存入一个 IShapeFactory 类型的数组（或其他容器） 对工厂数组（或容器）使用 foreach 循环遍历，利用 ShapeFactories.makeShape方法生成所有种类的形状并输出他们的面积 题外话 # 这题才是设计模式中的工厂方法模式（factory method pattern），第五题虽然也是比较常用的“工厂”，但并不是工厂方法模式，甚至不是一个专门的设计模式。\n工厂方法模式将实例化延迟到子类，由专门的工厂类生成特定类型的产品（比如 Shape）。本次实验没有关于 Random 的需求，主要是因为设计上的问题，他和本题的初衷“简单了解工厂方法模式”不符，它不是特定的，它需要知道所有的类型信息，类似本题中的 ShapeFactoriesTest 的地位。\n第五题中的方法，需要使用诸如 ShapeType 的标准来指定类型，这就导致了如果有新的需求（新的形状种类）出现，整个 ShapeFactory 类都要重新编写并编译。而使用工厂方法模式，你需要做的是编写一个新的工厂类并编译这个新的类，对原有的工厂代码无需进行修改（重构过的同学应该能体会到“不用修改代码”是一种多么幸福的事）。编写的时候可能觉得引入过多的类比较反人类，但是程序不是开发出来就完事了，还有维护和迭代更新。提倡在开工之前的设计环节为未来做足打算，但是也不要因此变成设计狂魔。上机题是为了在比较小的工作量下让大家了解基础内容，所以才会抽象出各种各样不现实的场景。如果像某次实验的“文件”那样，在工作量上并不友好。本题的 ShapeFactories.makeShape 也是策略模式的应用。\nExtra 3 匿名类的 ShapeFactory 编程题 # 在前面实验的 Shape 的基础上，定义一个满足如下需求的 IShapeFactory 接口：\n具有方法 Shape makeShape(double a, double b) ，返回一个由 a 和 b 指定大小的 形状； 参数不合法时，返回 null 或抛出异常 用单例模式+工厂方法模式的思想修改矩形、椭圆、菱形类：\n每一个类都增设一个 private static IShapeFactory factory 字段 类中的 factory 用于生成该类的形状对象 比如 Rectangle 类中的 factory，其 makeShape 方法返回 Rectangle 对象 直接使用匿名类为 factory 进行静态初始化，不允许像 ShapeFactory2 那样定义工厂类 进行其他的修改，使外界的其他类能够获取到 factory 并成功构造形状对象 选择你认为合适的方式编写测试类：\n你的测试类应该能够覆盖到所有等价类。 测试形式可以是单元测试，被测对象的形式可以参考之前实验中的 ShapeFactoriesTest.makeShape 方法。 在代码注释中（或者与代码一起提交一个 readme），描述你的测试计划 题外话 # 使用匿名类，依然是为每一个形状创建了一个对应的工厂，因此本质上依然是工厂方法模式，区别在于不用显式定义新的类（据说编码过程中，起名字是最麻烦的事情）。\n工厂方法模式的应用中，每一种工厂通常只有一个实例，因此它经常和单例模式一起被使用。\nExtra 4 命令模式 编程题 # 我们来模拟一个酒吧的点餐过程\n实现一个酒吧类 Bar：柜台上可以点炒饭（为了防止测试工程师炸掉酒吧），啤酒，伏特加。\n实现一个测试工程师类 Engineer：有很多很多钱可以用来点炒饭。\n实现一个满足如下需求的 interface ICommand：\n具有方法 void execute() 利用 interface ICommand，实现如下四个具体命令类：\n买炒饭 BuyEggFriedRice(Bar bar, int num) 含义是在酒吧 bar 中点 num 份炒饭， 该命令在执行时需要调用 bar 的相关方法， 下同 买啤酒 BuyBeer(Bar bar, int num) 买伏特加 BuyVodka(Bar bar, int num) 消费 x 元 SpendMoney(Engineer engineer, double money) 实现一个执行类 Executor 负责接收并执行上述命令\n具有方法： void add(ICommand command) 含义是添加一个命令 具有方法： void run() 含义是执行所有命令 最终，你应该可以跑通下面的测试函数，当然你也可以自行设计其他的测试代码\npublic static void main(String[] args) { Bar bar = new Bar(); Engineer engineer1 = new Engineer(); Engineer engineer2 = new Engineer(); // 点一份炒饭 + 啤酒， 花费 30 元 Executor executor1 = new Executor(); executor1.add(new BuyBeer(bar, 1)); executor1.add(new BuyEggFriedRice(bar, 1)); executor1.add(new SpendMoney(engineer1, 50)); executor1.run(); // 点两份炒饭， AA，每人 20 元 Executor executor2 = new Executor(); executor2.add(new BuyBeer(bar, 2)); executor2.add(new SpendMoney(engineer1, 50)); executor2.add(new SpendMoney(engineer2, 50)); executor2.run(); } "},{"id":7,"href":"/Java-HomeWork/docs/OOP-LAB/LAB07/","title":"Lab07","section":"Oop Lab","content":" Java 程序设计 LAB07 # 实验目的 # 简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类 实验题目 # 本实验假设你明白：\n涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。 本次实验不会涉及以下内部类的常用技巧：\n回调与闭包 事件与控制框架 也不会涉及以下内部类的边角情况：\n内部类的继承与覆盖 多重嵌套的内部类 Question01 InnerClass1 代码填空 # 阅读下面这段代码：\nclass Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(/*???*/); System.out.println(/*???*/); System.out.println(/*???*/); } } } public class Test { public static void main(String[] args) { Outer.Inner oi = /*???*/; oi.show(); } } 在 Code/Question01/Test.java 中的注释部分填代码，使程序先后输出 30、20、10。 注意： 不允许修改已经有的代码。 考察的是内部类的构造以及访问外部类的方法，请不要用加减运算这种操作。 Question02 InnerClass2 代码填空 # 阅读下面这段代码：\ninterface Inter { void show(); } class Outer { /*???*/ } public class Test { public static void main(String[] args) { Outer.method().show(); } } 在 Code/Question02/Test.java 中的注释部分填代码，使程序输出\u0026quot;DuluDulu\u0026quot;。 注意： 不允许修改已经有的代码。 考察的是匿名类，但是用内部类也可以实现 Question03 匿名类的 ShapeFactory 编程题|旧题 # 在前面实验的 Shape 的基础上，定义一个满足如下需求的 IShapeFactory 接口：\n具有方法 Shape makeShape(double a, double b) ，返回一个由 a 和 b 指定大小的 形状； 参数不合法时，返回 null 或抛出异常 用单例模式+工厂方法模式的思想修改矩形、椭圆、菱形类：\n每一个类都增设一个 private static IShapeFactory factory 字段 类中的 factory 用于生成该类的形状对象 比如 Rectangle 类中的 factory，其 makeShape 方法返回 Rectangle 对象 直接使用匿名类为 factory 进行静态初始化，不允许像 ShapeFactory2 那样定义工厂类 进行其他的修改，使外界的其他类能够获取到 factory 并成功构造形状对象 选择你认为合适的方式编写测试类，：\n你的测试类应该能够覆盖到所有等价类。 测试形式可以是单元测试，被测对象的形式可以参考之前实验中的 ShapeFactoriesTest.makeShape 方法。 在代码注释中（或者与代码一起提交一个 readme），描述你的测试计划 题外话 # 使用匿名类，依然是为每一个形状创建了一个对应的工厂，因此本质上依然是工厂方法模式，区别在于不用显式定义新的类（据说编码过程中，起名字是最麻烦的事情）。 工厂方法模式的应用中，每一种工厂通常只有一个实例，因此它经常和单例模式一起被使用。\nQuestion04 ShapeSequence 编程题 # 这是一个主动要求大家造轮子的题，因此不允许继承或组合任何 java 自带的容器（除了数组）。 本题假设大家在算法上机时能够较为熟练的使用 C++中 STL 容器，并至少对变长容器的迭代访问有一定了解。\n定义一个迭代器接口IIterator具有下述抽象方法：\nboolean isEnd() Shape current() void moveNext() boolean equals(Object o) 在 Shape 的基础上，定义一个满足如下需求的 ShapeSequence 类：\n具有属性 private Shape[] shapes 构造方法 ShapeSequence(int size) size 用于指定 shapes 的最大长度，如果 size 是负数，那么按照 0 来处理。 构造方法中应当对 shapes 进行初始化赋值，在其他过程中 shapes 的大小不 应该被改变 方法 public void add(Shape shape) 向 shapes 中添加一个新的元素 当 shapes 被填满时，什么都不做 方法 public String toString() 返回这个容器的字符串表达，格式为 [Type, Type,...] 格式中的 Type 是形状类型的全小写英文单词，比如 rectangle、ellipse 方法 public IIterator iterator() {return new SequenceIterator();} 具有内部类 private class SequenceIterator implements IIterator，它用于序列遍历的迭代器 自定义必要的属性。 默认构造方法，在被构造时，迭代器指向的位置代表数组下标 0 方法 public boolean isEnd()，迭代器完成遍历时，返回 true 完成遍历不代表迭代器指向了最后一个元素，而是指向了最后一个元素的下一个位置 方法 public Shape current()，返回当前迭代器指向位置的 Shape 对象 isEnd()是 true 时，访问 current 是非法操作 方法 public void moveNext()，使迭代器移动到下一个元素的位置 isEnd()是 true 时，什么都不做 方法 public boolean equals(Object o)，当 o 是 SequenceItetator 类型的、且 o 和 this 的外部类对象相同、且 o 和 this 的位置相同时，返回 true 编写测试类并描述你的测试计划\n注意 # toString 和 equals 是 override 继承自 Object 的方法，尽量避免出现诸如 ToString、 equals 的参数类型不是 Object（这种情况会算作 overload）等情况\n题目中省略了一些实现上必要但是方式不唯一的属性：比如你可以在 ShapeSequence 类中声明一个 int 属性来表示当前容器被填充到了什么位置；给 SequenceIterator 一个 int 属性表示当前迭代器指向的位置，当使用 isEnd 时，判断迭代器位置和外部类容器的填充位置进行比较。\n题外话 # 在实现本题的 toString 时，推荐使用 StringBuilder或StringJoiner。 你可以考虑一下不使用内部类时要如何实现迭代器，内部类为这种数据访问是否带来了足够的便利？ 为什么 SequenceIterator 被限定为了 private "},{"id":8,"href":"/Java-HomeWork/docs/OOP-LAB/Lab08/","title":"Lab08","section":"Oop Lab","content":"\rJava 程序设计 LAB08 # 实验目的 # 理解集合框架的设计思路\n了解 Java 常用的数据结构类及其使用，重点迭代器(Iterator) 、线性表（List、ArrayList、LinkedList）、HashMap 类、HashSet 类及枚举类在企业级软件编写中经常用到，要求在理解的基础上，熟练掌握\n理解泛型的概念、必要性并能够灵活使用\n实验题目 # Question1 简述ArrayList和LinkedList的区别 简答 # Question2 写出以下程序的输出 简答 # //Animal.java public class Animal { public Animal(){ System.out.println(\u0026#34;I am an animal\u0026#34;); } } //Dog.java public class Dog extends Animal{ public Dog(){ System.out.println(\u0026#34;I am a dog\u0026#34;); } } //AnimalTest.java public class AnimalTest { public \u0026lt;T,S extends T\u0026gt; T testDemo(T t,S s){ System.out.println(\u0026#34;I am type T and my type is \u0026#34;+t.getClass().getName()); System.out.println(\u0026#34;I am type S and my type is \u0026#34;+s.getClass().getName()); return t; } public static void main(String[] args){ AnimalTest test=new AnimalTest(); Dog dog=new Dog(); Animal animal=new Animal(); Animal animal1=test.testDemo(animal,dog); } } Question3 写出以下程序的输出(注意通配符的使用) 简答 # //Animal.java public class Animal { public Animal(){ System.out.println(\u0026#34;I am an animal\u0026#34;); } } //Dog.java public class Dog extends Animal{ public Dog(){ System.out.println(\u0026#34;I am a dog\u0026#34;); } } //AnimalTest1.java import java.util.List; import java.util.ArrayList; public class AnimalTest1 { public void testDemo(List\u0026lt;?\u0026gt; s){ for(Object obj:s){ System.out.println(\u0026#34;My type is \u0026#34;+obj.getClass().getName()); } } public static void main(String[] args){ AnimalTest1 test=new AnimalTest1(); Dog dog=new Dog(); Animal animal=new Animal(); List\u0026lt;Animal\u0026gt; s=new ArrayList\u0026lt;Animal\u0026gt;(); s.add(dog); s.add(animal); test.testDemo(s); } } Question4 编写程序完成以下要求 编程 # 请用 LinkedList 实现一个支持泛型的栈 MyStack，并在 main 函数中测试\n//MyStack.java import java.util.LinkedList; public class MyStack\u0026lt;T\u0026gt; { private LinkedList\u0026lt;T\u0026gt; values=new LinkedList\u0026lt;T\u0026gt;(); public void push(T t){ //Your code here } public T pull(){ //Your code here } public T peek(){ //Your code here } public static void main(String[] args){ /* Your test code here */ } } Question5 编写程序完成以下要求 编程 # 假如有以下 email 数据 aa@sohu.com, bb@163.com, cc@sina.com, ... 现需要把 email 中的用户名和邮件地址部分分离(例如 aa@sohu.com 分离为 aa 和 sohu.com )，分离后以键值对应的方式放入 HashMap 。 给定 email 数据为： String str = \u0026quot;aa@sohu.com,bb@163.com,cc@sina.com\u0026quot;;\nimport java.util.HashMap; import java.util.Map; public class EmailSplit { public static void main(String[] args) { String str = \u0026#34;aa@sohu.com,bb@163.com,cc@sina.com\u0026#34;; Map\u0026lt;String, String\u0026gt; emailMap = new HashMap\u0026lt;String, String\u0026gt;(); /* Your code here */ System.out.println(emailMap.toString()); } } Question6 编写程序完成以下要求 编程 # 双色球规则：双色球每注投注号码由 6 个红色球号码和 1 个蓝色球号码组成。红色球号码从 1—33 中选择；蓝色球号码从 1—16 中选择；请随机生成一注双色球号码，并输出到控制台。（要求同色号码不重复） 举例如下，双色球号码一注：\n红球 8 红球 20 红球 17 红球 1 红球 28 蓝球 6 红球 32\npublic class TwoColorBall { public static void main(String[] args) { /* Your code here */ } } "},{"id":9,"href":"/Java-HomeWork/docs/OOP-LAB/TEMPLATE/","title":"Template","section":"Oop Lab","content":" Lab XX Assignment # 班级：\n学号：\n姓名：\n提交要求（以下内容在最终提交的作业中可以删除，仅作参考） # 目录格式\n-- 班级-学号-姓名-LabXX.zip |-- answer.pdf |-- solution |-- Question1 |-- 题1的代码文件(如果需要) |-- Question2 |-- 题2的代码文件(如果需要) |-- ... "},{"id":10,"href":"/Java-HomeWork/docs/MySCS/","title":"My Scs","section":"Docs","content":" MySCS # 迭代作业，第三周开始，每次迭代作业会开放两周时间来完成 如果你对软院的云平台（scs）感到不满意？那不妨自己来完成一个简易的云平台吧~\n"},{"id":11,"href":"/Java-HomeWork/docs/MySCS/MySCS-1/","title":"My Scs 1","section":"My Scs","content":" MySCS -1 # 同学们，从这周开始，我们会迭代完成一个MySCS，即从零开发的软件学院云平台（青春版）。\n我们每两周会增加一次新的需求，如，MySCS-1需要大家完成账号注册和登录系统，MySCS-2需要大家在1的基础上添加课程系统或其它系统等。\n编写好的代码需要大家用patpat评测，所有测试点都通过以后即可上传到云平台完成本次实验。希望大家认真完成哦！请勿抄袭，抄袭会被查到的（盯\n题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全自主知识产权，有极大的使用价值和收藏价值。\nMySCS分为教师端和学生端，可以实现传统scs的大部分功能，如教师端对课程的增删改查，对课程所属的实验的增删改查，教师还可以为课程添加学生和助教，学生可以查看参与的课程并提交实验作业，助教可以协同老师管理课程等。\n命令概览 # 命令行 功能 输出 QUIT 系统关机 \u0026mdash;\u0026ndash; Good Bye! \u0026mdash;\u0026ndash; register 学工号 名 姓 邮箱 密码 确认密码 注册 register success\nalready logged in\nuser id illegal\nuser id duplication\nuser name illegal\nemail address illegal\npassword illegal\npasswords inconsistent login 学工号 密码 登录 Hello 名~\nHello Professor 姓~\nalready logged in\nuser id illegal\nuser id not exist\nwrong password printInfo 打印本人信息 Name: 名 姓ID: xxxType: Student（或Professor）Email: xxx\nlogin first printInfo 学号 打印其他人信息 Name: 名 姓ID: xxxType: Student（或Professor）Email: xxx\nlogin first\nuser id illegal\nuser id not exist\npermission denied logout 退出当前用户 Bye~\nnot logged in 功能描述 # 1.开关机 # 实现最基本的命令读入和退出功能\n首先，你的任务是编写一个Test类：\n当程序启动，进入main方法，并连续读入输入的命令行，命令行的基本格式为： 命令 [参数1] [参数2] [参数3] 其中参数数目为不定项；命令和参数，参数和参数之间由一个或多个空白符分隔；命令之前和最后一个参数之后可以没有或有若干个空白符。\n当输入的某一行只有空白符，什么都不会输出。\n当终端输入 QUIT 时，系统退出（程序退出状态为0），并在终端打印一行字符： ----- Good Bye! ----- 2.用户注册 # 用户需要注册账号并登录后才能使用MySCS。\n用户注册时，需要提供学工号，名，姓，邮箱，密码和确认密码。\n学号 # 对学生而言，一般情况下学号为8位数字，从高向低数，最高两位代表入学年份，随后的两位代表学院编号，随后的一位代表大班号，最低3位代表班内编号。 其中，入学年份取值范围为$[17,22]$，学院编号取值范围为$[01,43]$，大班号取值为$[1,6]$，最低三位没有特殊要求，取值范围为$[001,999]$。\n如，$19375030$代表19年入学，在序号为37的学院，第五大班。\n有些情况下，学号为2位大写字母+7位数字，SY开头代表学术型硕士研究生，ZY开头 代表专业型硕士研究生，BY开头代表博士研究生。\n由于本科生和博士生最多读6年，硕士生最多读4年将被退学，所以硕士生的入学年份取值为$[19,22]$ ，博士生的入学年份取值为$[17,22]$，且硕士和博士研究生的班内编号只有2位，取值范围为$[01,99]$，其他要求相同。\n如，$SY2021118$代表硕士研究生，20年入学，21系，第1大班。\n合法的学生学号实例：\n19375030 19375168 BY2215201 SY2021118\n对教师而言，工号为5位数字，没有特殊限制，取值范围为$[00001,99999]$。 姓，名 # 姓和名都应该只由字母组成，其中首字母大写，非首字母小写，姓和名的长度都在1个字符到20个字符之间。\n邮箱 # 一个合法的邮箱地址由 用户名 + @ + 服务器域名 组成。\n本题要求中，用户名应为长度$\\geq1$的字符串，只能由大小写字母，下划线和数字中的一种或几种组 成。\n服务器域名的规律为“[N级域名.]\u0026hellip;[三级域名.]二级域名.顶级域名”，比如如“qq.com”、 “mp.weixin.qq.com”、“buaa.edu.cn”，\u0026ldquo;T_T.QAQ.cn\u0026quot;等，域名同样只能由大小写字母，下划线和数字中的一种或几种组成。（即最少有两级域名，最多不限）\n密码 # 密码应该为8-16位，只能由大小写字母，下划线和数字中的一种或几种组成，要求以字母开头。\n确认密码 # 确认密码必须与密码一致才能成功注册。\n成功输出 # 当学工号，姓名，邮箱，密码和确认密码都符合上述要求时，注册成功，系统输出：\nregister success 失败输出 # 当系统目前有用户登录时，输出 already logged in （MySCS只允许同时有一位用户处于登录状态，此时不可以执行登录或注册命令）。\n学号不合法时，输出 user id illegal 学号已被注册时，输出 user id duplication 姓或名不合法时，输出 user name illegal 邮箱不合法时，输出 email address illegal 密码不合法时，输出： password illegal 两次密码不一致时，输出： passwords inconsistent 3.用户登录 # 成功输出 # 当当前没有用户登录，学工号已经注册且密码正确，登录成功，\n如果当前为学生登录，系统输出： Hello 名~ 如果当前为教师登录，系统输出： Hello Professor 姓~ 失败输出 # 当系统目前有用户登录时，输出 already logged in 学号不合法时，输出 user id illegal 学号未被注册时，输出 user id not exist 密码错误时，输出 wrong password 3. 用户登出 # 成功输出 # 当当前有用户登录，则登出成功，系统输出：\nBye~ 失败输出 # 当系统目前未有用户登录时，输出 not logged in 4.打印信息 # 建议同学们重写Object类的toString()方法完成这项功能。\n当命令为 printInfo 时，按以下格式打印本人个人信息。（教师与学生均可使用） Name: 名 姓 ID: xxx Type: Student/Professor Email: xxxxxx 老师有权查看其他老师和学生的个人信息，所以当当前登录用户为教师时，当命令为 printInfo 学号 时，按上述格式打印该人个人信息。 失败输出 # 当前未有用户登录，输出 login first 当学生调用有参数的 printInfo ，输出 permission denied 当作为参数的学号不合法，输出 user id illegal 当学号对应的用户未注册，输出 user id not exist 输出优先级 # 首先，当输入的命令未定义时，输出\ncommand \u0026#39;命令\u0026#39; not found 例如： 输入： loggin 19375030 123456\n由于命令 loggin 未定义，所以输出 command 'loggin' not found\n其次，当输入的命令有定义，但是参数的个数不符合要求时，输出\narguments illegal 输入： login 19375030 123456 haha 和 login 19375030 都对应着 arguments illegal\n当命令有定义，参数个数正确时，才会输出 Bye~ 或者 user id illegal 等成功或失败输出。\n当一句命令存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n例如，注册时学号和姓名均非法，按上述顺序，输出 user id illegal，而不是user name illegal\nHINT # 在判断姓名，邮箱和密码等的合法与否时，非常建议利用正则表达式来实现，这是一个非常方便实用常用的技巧，希望同学们趁这个机会学习一二，菜鸟教程的Java正则表达式教程就是个不错的小教程。\n例如，想判断19375030@buaa.edu.cn是否满足题目中的条件，用一行代码即可：\npublic class Demo { public static void main(String[] args) { String st = \u0026#34;19375030@buaa.edu.cn\u0026#34;; boolean res = st.matches(\u0026#34;\\\\w+@\\\\w+(\\\\.\\\\w+)+\u0026#34;); System.out.println(res);//true } } 同样地，想要快速便捷地判断密码是否合法，姓名是否合法，甚至处理一行输入中的空白符，都可以考虑利用正则表达式这个好工具。\n当然，同学们可以用能想到的任何合理方法解决（不合理方法：打表等）。\n测试样例 # register 19375030 Xinlei Bao 3499475017@qq.com a7ki7kibangbang a7ki7kibangbang register success login 19375030 a7ki7kibangbang Hello Xinlei~ register 10086 Alex Herbert 10086@buaa.edu.cn 123 123 already logged in logout Bye~ register 10086 Alex Herbert 10086@buaa.edu.cn a12345678 a12345678 register success login 10086 a12345678 Hello Professor Herbert~ printInfo Name: Alex Herbert ID: 10086 Type: Professor Email: 10086@buaa.edu.cn printInfo 19375030 Name: Xinlei Bao ID: 19375030 Type: Student Email: 3499475017@qq.com logout Bye~ QUIT ----- Good Bye! ----- "},{"id":12,"href":"/Java-HomeWork/docs/MySCS/MySCS-2/","title":"My Scs 2","section":"My Scs","content":" MySCS-2 # 同学们，我们用了两周时间完成了MySCS的部分功能，已经实现了老师端和学生端的登录注册。\n我们每两周会增加一次新的需求，MySCS-2需要大家在MySCS-1的基础上完成管理端的基础命令，MySCS-3需要大家在2的基础上添加学生操作以及其他功能等。（挖坑\n编写好的代码需要大家用patpat评测，所有测试点都通过以后即可上传到云平台完成本次实验。希望大家认真完成哦！请勿抄袭，抄袭会被查到的（盯\n题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全的自主知识产权，有极大的使用价值和收藏价值。\nMySCS分为管理端（老师端和助教端）和学生端，可以实现传统的scs的大部分功能。本此实验将完成管理端的基础操作，需要基于MySCS-1编写（建议备份一下MySCS-1，然后拷贝一下来搭MySCS-2）。\n命令概览 # 命令行 功能 输出 addCourse 课程号 课程名称 添加课程（老师端） add course success removeCourse 课程号 移除课程（老师端） remove course success listCourse 列出课程（老师端） [ID:课程编号] [Name:课程名称] [TeacherNum:老师人数] [AssistantNum:助教人数] [StudentNum:学生人数] selectCourse 课程号 选择课程（管理端） select course success addAdmin 学工号 学工号 \u0026hellip; 添加课程管理端成员（老师端） add admin success removeAdmin 学工号 移除课程管理端成员（老师端） remove admin success listAdmin 列出课程管理端成员（管理端） [ID:学工号] [Name:姓 名] [Type:用户身份(Professor/Assistant)] [Email:电子邮箱] changeRole 有助教身份的学生切换身份 change into Assistant success\nchange into Student success addWare 资料编号 资料名称 添加课程资料（老师端） add ware success removeWare 资料编号 移除课程资料（老师端） remove ware success listWare 列出课程资料（管理端） [ID:课程资料编号] [Name:课程资料名称] addTask 作业编号 作业名称 作业开始时间 作业截至时间 添加课程作业（管理端） add task success removeTask 作业编号 移除课程作业（管理端） remove task success listTask 列出课程作业（管理端） [ID:课程作业编号] [Name:课程作业名称] [ReceiveNum:接收作业份数] [StartTime:开始时间] [EndTime:截止时间] addStudent 学工号 学工号 \u0026hellip; 添加课程学生（管理端） add student success removeStudent 学工号 移除课程学生（管理端） remove student success listStudent 列出课程学生（管理端） [ID:学工号] [Name:姓 名] [Email:电子邮箱] 功能描述 # 0.功能说明 # 对于以下每个命令在无特殊说明的情况下，只有使用对象能够成功使用，非使用对象调用时均优先返回permission denied，其中部分命令在后续会支持学生端的使用，但在本次迭代中无需考虑。\n1.添加课程 # addCourse 课程号 课程名称\n使用对象：老师端 # 当老师成功登录MySCS时即可添加课程，创建课程时该老师即为本课程管理员，管理员可含多个老师和多个助教（后面会有对应指令），课程仅有管理员可见。\n老师添加课程时，需要提供课程号，课程名称。\n课程号 # 课程号共有5位，是一个由C开头，剩下四位都是数字的字符串，其中数字的前两位为课程开设年份，取值范围为$[17,22]$，低两位没有特殊要求，取值范围为$[01,99]$。 合法的课程号实例 # C2102 C2293 C1721\n课程名称 # 课程名称是由字母大小写、数字和下划线组成的字符串，长度在6个字符到16个字符之间。 合法的课程名称实例 # aaawa_1ea 12004___\n成功输出 # 当课程号，课程名称都合法时，添加课程成功，系统输出： add course success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当课程号不合法时，输出： course id illegal 当课程号被注册时，输出： course id duplication 当课程名称不合法时，输出 course name illegal 2.移除课程 # removeCourse 课程号\n使用对象：老师端 # 当老师成功登录MySCS时即可移除课程，每个老师所属课程相对独立。\n只要是该课程的管理员均可移除课程，移除课程后所有跟课程相关的资料、作业、学生信息等都会被删除（彻底remove）。\n老师移除课程时，需要提供课程号。\n若移除的是当前选择课程则需注意在移除后清除当前选择课程。\n成功输出 # 当课程号合法要求且在自己的名下存在时，移除课程成功，系统输出： remove course success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当课程号不合法要求时，系统输出： course id illegal 当课程号不存在或不在自己名下时，系统输出： course id not exist 3.列出课程 # listCourse\n使用对象：老师端（注意，因为目前没有做学生端相关内容，需要预留接口嗷，助教端的课程列表和学生端会在后续添加） # 当老师成功登录MySCS时即可列出课程列表，每个老师所属课程相对独立，即只能看见自己所管理的课程。\n成功输出 # 当老师调用此命令时，成功输出课程列表，即输出老师名下所有课程，每个课程及属性对应一行： 顺序由课程编号字典序从小到大排列\nHint：可以考虑使用 TreeMap 来存储课程实例。\n[ID:课程编号] [Name:课程名称] [TeacherNum:老师人数] [AssistantNum:助教人数] [StudentNum:学生人数] 成功输出实例 # [ID:C2021] [Name:oop_spring] [TeacherNum:1] [AssistantNum:2] [StudentNum:200] [ID:C2121] [Name:oop_autumn] [TeacherNum:2] [AssitantNum:4] [StudentNum:200] 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当老师名下没有课程时，输出： course not exist 4.选择课程 # selectCourse 课程号\n使用对象：管理端（注意，因为目前没有做学生端相关内容，需要预留接口嗷） # 当老师或助教成功登录MySCS时即可选择课程，用以做课程之下的对应操作。\n成功输出 # 当老师或助教调用此命令，课程号合法要求且课程在自己名下时，系统输出： select course success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当课程号不合法要求时，系统输出： course id illegal 当课程号不存在或不在自己名下时，系统输出： course id not exist Hint：在退出登录时注意清空当前选择课程。\n5.添加课程管理端成员 # addAdmin 学工号 学工号 ...\n使用对象：老师端 # 当老师成功登录MySCS时并且选中课程时即可添加管理端成员，可以添加老师和助教。\n我们期望模拟一次性添加多个管理端成员，为了给后面文件导入挖坑（\n正确输入实例 # addAdmin 10001 20373252 19376054 19375030 19376110 10086\n成功输出 # 如果参数学工号已经在课程内，可以视为正确参数\n当老师调用此命令，所有学工号合法要求的话，系统输出： add admin success Hint：重复添加管理员被视为合法行为，输出成功命令但不进行任何操作。\n失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当参数学工号出现不合法（以第一个出错的参数为准）的情况时，系统不接受这条指令的所有参数，系统输出： user id illegal 当参数学工号出现未被注册（以第一个出错的参数为准）的情况时，系统不接受这条指令的所有参数，系统输出： user id not exist 6.移除课程管理端成员 # removeAdmin 学工号\n使用对象：老师端 # 当老师成功登录MySCS并且选中课程时即可移除管理端成员。\n默认老师不会移除自己。\n成功输出 # 当老师登录，选择了课程，且参数都合法时，系统输出： remove admin success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当参数学工号不合法时，系统输出： user id illegal 当参数学工号未被注册或不在课程管理端成员中时，系统输出： user id not exist 7.列出课程管理端成员 # listAdmin\n使用对象：管理端 # 当老师或助教成功登录MySCS并且选中课程时可以列出管理端成员列表。\n成功输出 # 当老师或助教成功登录MySCS，并且想要查看课程管理端成员时，成功输出管理端成员列表，每个用户及属性对应一行： 顺序为学工号字典序从小到大排列\n[ID:学工号] [Name:姓 名] [Type:用户身份(Professor/Assistant)] [Email:电子邮箱] 成功输出实例 # [ID:2037252] [Name:Fl Rover] [Type:Assistant] [Email:20373252@buaa.edu.cn]\n失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 8.切换助教端和学生端 # changeRole\n使用对象：助教端和学生端 # 当有助教身份的学生成功登录MySCS时，默认在学生端，使用此指令可以在助教端和学生端之间切换。\n注意，设计成可以切换的目的是复用界面功能，但是功能返回的结果可能不同。比如助教如果在助教端，使用listCourse的指令会返回自己担任助教的课程，但是如果助教在学生端，就会显示自己所学的课程。\n成功输出 # 当有助教身份的学生成功登录MySCS时，使用此指令可以在助教端和学生端之间切换 切换成助教成功时输出： change into Assistant success 切换成学生成功时输出： change into Student success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是有助教身份的学生或是老师时，输出： permission denied 9.添加课程资料 # addWare 资料编号 资料名称\n使用对象：老师端 # 当老师成功登录MySCS并且选中课程时即可添加课程资料，一次可以上传一个课程资料。\n课程资料编号 # 课程号共有7位，是一个由W开头，剩下六位都是数字的字符串，其中数字的前四位为课程号的后四位，低两位没有特殊要求，取值范围为$[01,99]$。 合法的课程资料编号实例 # W210201 W191743 W182930\n课程资料名称 # 课程资料名称是由字母大小写、数字、下划线（仅出现在点的左边）和点（有且仅有一个点，且不在字符串首尾）组成的字符串，长度在6个字符到16个字符之间。 合法的课程资料名称示例 # aaaw.jpg a_1ea.png 12004___.abc\n不合法的课程资料名称示例 # aaaw.j_pg a_1ea. abc\n成功输出 # 当老师调用此命令，资料编号合法的话，系统输出： add ware success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当课程资料号不合法时，输出： ware id illegal 当课程资料号被注册时，输出： ware id duplication 当课程资料名称不合法时，输出： ware name illegal 10.移除课程资料 # removeWare 资料编号\n使用对象：老师端 # 当老师成功登录MySCS并且选中课程时即可移除课程资料。\n老师移除课程资料时，需要提供课程资料号。\n成功输出 # 当课程资料号合法且在自己的名下存在时，移除课程资料成功，系统输出： remove ware success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当课程资料号不合法时，系统输出： ware id illegal 当课程资料号未被注册或不在课程中时，系统输出： ware id not exist 11.列出课程资料 # listWare\n使用对象：管理端（注意，因为目前没有做学生端相关内容，需要预留接口嗷） # 当老师或助教成功登录MySCS并且选中课程时可以列出课程资料列表。\n成功输出 # 当老师和助教成功登录MySCS，并且想要查看课程资料时，成功输出课程资料列表，每个课程资料及属性对应一行： 顺序由课程资料编号字典序从小到大排列\n[ID:课程资料编号] [Name:课程资料名称] 成功输出实例 # [ID:W193701] [Name:Test1.pdf] [ID:W193702] [Name:Test2.pdf] 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 12.添加课程作业 # addTask 作业编号 作业名称 作业开始时间 作业截至时间\n使用对象：管理端 # 当老师或助教成功登录MySCS并且选中课程时即可添加课程作业，一次可以上传一个课程作业。\n课程作业编号 # 课程号共有7位，是一个由T开头，剩下六位都是数字的字符串，其中数字的前四位为课程号的后四位，低两位没有特殊要求，取值范围为$[01,99]$。 合法的课程作业编号实例 # T210201 T191743 T182930\n课程作业名称 # 课程作业名称是由字母大小写、数字、下划线（仅出现在点的左边）和点（有且仅有一个点，且不在字符串首尾）组成的字符串，长度在6个字符到16个字符之间。 合法的课程作业名称示例 # aaaw.jpg a_1ea.png 12004___.abc\n不合法的课程作业名称示例 # aaaw.j_pg a_1ea. abc\n时间 # 时间格式为xxxx-xx-xx-xx:xx:xx，分别对应年、月、日、时、分、秒，不够补前导零，需要满足真实时间（闰年、12个月等基本日期格式要求，年份范围为$[1900,9999]$），注意截至时间需要在开始时间之后 时间示例 # 2022-02-02-00:03:19\n成功输出 # 当老师或助教调用此命令，作业编号合法要求的话，系统输出： add task success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当课程作业号不合法时，输出： task id illegal 当课程作业号被注册时，输出： task id duplication 课程作业名称不合法时，输出： task name illegal 课程作业时间不合法时，输出： task time illegal 13.移除课程作业 # removeTask 作业编号\n使用对象：管理端 # 当老师或助教成功登录MySCS并且选中课程时即可移除课程作业。\n老师或助教移除课程作业时，需要提供课程作业号。\n成功输出 # 当课程作业号合法要求且在自己的名下存在时，移除课程作业成功，系统输出： remove task success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当课程作业号不合法时，系统输出： task id illegal 当课程作业号未被注册或不在课程中时，系统输出： task id not exist 14.列出课程作业 # listTask\n使用对象：管理端（注意，因为目前没有做学生端相关内容，需要预留接口嗷） # 当老师或助教成功登录MySCS并且选中课程时可以列出课程作业列表。\n成功输出 # 当老师和助教成功登录MySCS，并且想要查看课程作业时，成功输出课程作业列表，每个课程作业及属性对应一行： 顺序由课程作业编号字典序从小到大排列\n[ID:课程作业编号] [Name:课程作业名称] [ReceiveNum:接收作业份数] [StartTime:开始时间] [EndTime:截止时间] 成功输出实例 # [ID:T193701] [Name:Test1.pdf] [ReceiveNum:100] [StartTime:2022-09-17-00:00:01] [EndTime:2022-09-18-00:00:01] [ID:T193702] [Name:Test2.pdf] [ReceiveNum:50] [StartTime:2022-09-17-00:00:01] [EndTime:2022-09-18-00:00:01] 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 15.添加课程学生 # addStudent 学工号 学工号 ...\n使用对象：管理端 # 当老师或助教成功登录MySCS时并且选中课程时即可添加学生，可以添加课程学生。\n我们期望模拟一次性添加多个课程学生，为了给后面文件导入挖坑（\n正确输入实例 # addStudent 20373252 19376054 19375030 19376110\n成功输出 # 如果参数学工号已经在课程内，可以视为正确参数\n当老师或助教调用此命令，学工号合法要求的话，系统输出： add student success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当参数学工号出现不合法（以第一个出错的参数为准）的情况时，系统不接受这条指令的所有参数，系统输出： user id illegal 当参数学工号出现未被注册（以第一个出错的参数为准）的情况时，系统不接受这条指令的所有参数，系统输出： user id not exist 当参数学工号出现老师的学工号（以第一个出错的参数为准）时，系统不接受这条指令的所有参数，系统输出： I\u0026#39;m professor rather than student! 16.移除课程学生 # removeStudent 学工号\n使用对象：管理端 # 当老师或助教成功登录MySCS并且选中课程时即可移除学生。\n成功输出 # 当老师或助教登录，选择了课程，且参数都合法时，系统输出： remove student success 失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 当参数学工号不合法时，系统输出： user id illegal 当参数学工号未被注册或未在课程中时，系统输出： user id not exist 17.列出课程学生 # listStudent\n使用对象：管理端 # 当老师或助教成功登录MySCS并且选中课程时可以列出学生列表。\n成功输出 # 当老师或助教成功登录MySCS，并且想要查看课程学生时，成功输出学生列表，每个用户及属性对应一行： 顺序为学工号字典序从小到大排列\n[ID:学工号] [Name:姓 名] [Email:电子邮箱] 成功输出实例 # [ID:2037252] [Name:Fl Rover] [Email:20373252@buaa.edu.cn]\n失败输出 # 当系统目前没有用户登录时，输出： not logged in 当系统目前登录用户不是老师或助教时，输出： permission denied 当用户没有选择课程时，输出： no course selected 输出优先级 # 首先，当输入的命令未定义时，输出\ncommand \u0026#39;命令\u0026#39; not found 例如： 输入： loggin 19375030 123456\n由于命令 loggin 未定义，所以输出 command 'loggin' not found\n其次，当输入的命令有定义，但是参数的个数不合法要求时，输出\narguments illegal 输入： login 19375030 123456 haha 和 login 19375030 都对应着 arguments illegal\n当命令有定义，参数个数正确时，才会输出 Bye~ 或者 user id illegal 等成功或失败输出。\n当一句命令存在多种非法情况，按上述顺序只输出最先发生的非法信息。\n例如，注册时学号和姓名均非法，按上述顺序，输出 user id illegal，而不是user name illegal\n测试样例 # register 20373252 Yixiao Li 20373252@buaa.edu.cn x12345678 x12345678 register success register 19376054 Hongxi Zhou 19376054@buaa.edu.cn x12345678 x12345678 register success register 10001 Xueping Shen 10001@buaa.edu.cn x12345678 x12345678 register success login 10001 x12345678 Hello Professor Shen~ addCourse C2101 oop_autumn add course success listCourse [ID:C2101] [Name:oop_autumn] [TeacherNum:1] [AssistantNum:0] [StudentNum:0] selectCourse C2101 select course success addAdmin 20373252 add admin success listAdmin [ID:10001] [Name:Shen Xueping] [Type:Professor] [Email:10001@buaa.edu.cn] [ID:20373252] [Name:Li Yixiao] [Type:Assistant] [Email:20373252@buaa.edu.cn] addTask T210101 autumn_task1.txt 2020-02-29-00:00:00 2024-02-29-00:00:00 add task success listTask [ID:T210101] [Name:autumn_task1.txt] [ReceiveNum:0] [StartTime:2020-02-29-00:00:00] [EndTime:2024-02-29-00:00:00] addWare W210101 autumn_ware1.txt add ware success listWare [ID:W210101] [Name:autumn_ware1.txt] addStudent 19376054 add student success listStudent [ID:19376054] [Name:Zhou Hongxi] [Email:19376054@buaa.edu.cn] logout Bye~ login 20373252 x12345678 Hello Yixiao~ changeRole change into Assistant success selectCourse C2101 select course success listAdmin [ID:10001] [Name:Shen Xueping] [Type:Professor] [Email:10001@buaa.edu.cn] [ID:20373252] [Name:Li Yixiao] [Type:Assistant] [Email:20373252@buaa.edu.cn] listTask [ID:T210101] [Name:autumn_task1.txt] [ReceiveNum:0] [StartTime:2020-02-29-00:00:00] [EndTime:2024-02-29-00:00:00] listWare [ID:W210101] [Name:autumn_ware1.txt] listStudent [ID:19376054] [Name:Zhou Hongxi] [Email:19376054@buaa.edu.cn] logout Bye~ QUIT ----- Good Bye! ----- "},{"id":13,"href":"/Java-HomeWork/docs/MySCS/MySCS-3/","title":"My Scs 3","section":"My Scs","content":" MySCS-3 # 同学们，在上一次的迭代中，我们已经完成了管理端的命令开发，接下来我们需要完成学生端的命令了。\n编写好的代码需要使用patpat进行评测，AC后即可上传到云平台以完成本次的实验内容。希望大家认真且保质保量的完成，请勿抄袭，如有发现抄袭现象将取消迭代作业成绩。\n题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全的自主知识产权，有极大的使用价值和收藏价值。本平台模拟一台操作机上的命令行，所有操作均在本地进行，不支持联网操作，同一时间的使用者有且仅有一个。\nMySCS分为管理端（老师端和助教端）和学生端，可以实现传统的scs的大部分功能。本次迭代需要完成的内容为学生端命令的开发，请尽可能直接基于AC后的MySCS-2代码编写，否则可能发生其他异常情况，另外注意此前迭代AC了也不能确保你的程序是完全正确的。\n注意在这次的迭代中修改了部分输出格式，同时也为部分之前的命令增添了新的功能。\n整体约束 # 当输入的命令未定义时，输出\ncommand \u0026#39;$命令\u0026#39; not found 例如： 输入 loggin 19375030 123456\n由于命令 loggin 未定义，所以输出 command 'loggin' not found\n若以下 功能描述中有明确给出输出顺序，则以它为准\n若不满足第二条，则保持原输出顺序不改变\n当输入的命令有定义，但是参数的个数不合法要求时，输出\narguments illegal 输入： login 19375030 123456 haha 和 login 19375030 都对应着 arguments illegal\n当命令有定义，参数个数正确时，才会输出 Bye~ 或者 user id illegal 等成功或失败输出\n当一句命令存在多种非法情况，按上述顺序只输出最先发生的非法信息\n例如，注册时学号和姓名均非法，按上述顺序，输出 user id illegal，而不是user name illegal\n评测时，请将所有文件放到patpat可执行文件相同路径下。例如：\nMySCS\\example ├─LAB1.md ├─Lesson1.txt ├─19376054.task ├─T191743.ans ├─patpat.exe ├─3-学号-姓名 │ ├─out │ └─src │ └─Test.java └─test ├─test.yaml └─judge.yaml 提交代码时，请保持以上目录结构\n不要使用word，vsc等软件修改文件，可能会导致格式混乱\n请注意：PatPat仅支持单个Scanner对象，使用Scanner读入文件可能导致测评结果错误，请采用其他方式读入！\n总体说明 # 仅提到的需要修改的命令才需要修改，其余未提到的命令均保持不变 当你涉及文件的操作评测时出现行数问题的时候，可以试试把 println() 的输出结果 trim() 一下，去掉多余的换行 每次评测之后记得把生成的文件夹删掉以还原最初的评测环境（比如在 QUIT 之后增加一个删除 ./data/ 的逻辑再退出程序） 输出顺序即为优先级 命令中的 [] 代表可选项，该项可出现，也可空缺 命令中的 ... 表示省略的语义，紧跟的前一项（若存在）可重复出现任意次数 命令中的 | 代表或的语义 命令中的 () 代表这是一个整体 命令中的 \u0026lt; 和 \u0026gt; 代表重定向输入/输出，特别地，\u0026gt; 表示覆盖，\u0026gt;\u0026gt; 表示追加，重定向的意思可以简单的理解为将原本需要 System.out.println() 的内容转而写入到指定的文件中，倘若指定的文件不存在默认新建一个 在示例中看到的 $variable 和 ${variable} 表示这是一个变量，需要替换成实际值 在示例中看到的 ... 表示省略的语义，并不是实际输出 在示例中看到 $ 命令 格式，表示这是你在IDEA的运行窗口中输入的命令，输入内容不应包括 $ 和紧跟其后的空格 命令概览 # 需求 命令 功能描述 修改 listCourse 列出所有课程 修改 selectCourse 课程编号 选择课程 修改 listAdmin 列出课程管理端成员 修改 addWare 资料编号 资料路径地址 添加课程资料 修改 removeWare 资料编号 移除课程资料 修改 listWare 列出课程资料 修改 addTask 作业编号 作业名称 作业开始时间 作业截至时间 添加课程作业 修改 removeTask 作业编号 移除课程作业 修改 listTask 列出课程作业 新增 downloadFile [保存路径地址] 文件编号 [(\u0026gt; | \u0026gt;\u0026gt;) 路径地址] 下载课程文件 新增 openFile [路径地址] | [\u0026lt; 路径地址] 打开文件 新增 submitTask [作业路径地址] 课程作业编号 [\u0026lt; 作业路径地址] 提交课程作业 新增 addAnswer [答案路径地址] 课程作业编号 [\u0026lt; 答案路径地址] 添加作业答案 新增 queryScore 课程作业编号 [学号] 查询作业成绩 功能描述 # 列出所有课程 # 命令 listCourse 使用对象：所有人 功能：列出与自己相关的所有课程，学生使用列出学生加入的课程，助教和老师使用列出其名下管理的课程 前置条件：已登录 其余不变\n选择课程 # 命令 参数1 selectCourse 课程编号 使用对象：所有人 功能：选择当前需要操作的课程 前置条件：已登录 更新：学生可以使用该命令来选择当前需要操作的课程 其余不变\nHint：\n注意在切换身份以及退出登录时清空选择课程。 列出课程管理端成员 # 命令 listAdmin 使用对象：所有人\n功能：查询当前课程的所有管理员信息，包括老师和助教\n前置条件：已登录、已选择课程\n成功输出变更\n注意：按照 ID 字符串的字典序排序输出，特殊的是，当学生使用此功能时，为了保护老师和助教的信息安全，需隐去学工号，即输出：\n[Name:$姓 $名] [Type:$身份] [Email:$邮箱] ... 顺序不变\n其余不变\n添加课程资料 # 命令 参数1 参数2 addWare 资料编号 资料路径地址 使用对象：老师端、助教端\n功能：管理端可以为课程添加资料，添加的资料会统一存放在 ./data/$课程编号/wares/ 中（需要复制路径地址的文件到指定文件夹下，若存在非本次命令添加的同资料编号文件，则覆盖），并重命名为 $资料编号_$资料名称 ，其中资料名称被定义为文件名称（不是路径而是文件名，且包含后缀名，思考用什么方法获得）\n前置条件：已登录、已选择课程\n更新：助教也可以添加资料，且涉及文件操作\n失败输出变更\nware id duplication 从原来的失败原因中剔除，因为可以通过添加同ID的资料来修改原资料（对资料名是否相同没有限制，但要注意删除旧的资料，保证同ID的资料仅有一个） 以下新增的失败输出的判定均在原有判定之后，新增的失败输出的输出顺序即为下文中从上往下出现的顺序\n新增 ware file does not exist 当且仅当资料路径地址指向的文件不存在时输出 新增 ware file operation failed 当且仅当文件操作失败时输出 新增 unexpected error 当且仅当其他异常抛出时输出 其余不变\nHint：\n你需要通过路径地址获取文件，然后使用原来的方法判断资料编号与文件名是否合法，并记录失败原因，最后在执行文件操作的时候仍需要try-catch，对捕获的异常进行记录并输出 考虑使用 java.io.File 来进行文件查看，考虑使用 java.nio.file.Files 进行文件操作，或者利用文件流进行操作 举例说明：\n将提供的压缩包中的文件解压缩到当前目录下（patpat评测则在patpat同级目录下，IDE运行则在项目文件夹下）。\n./ 表示当前目录，因此实际参数中的资料路径地址只会有例如\u0026quot;a.txt\u0026quot;和\u0026quot;./a.txt\u0026quot;两种情况，如果判断出是后者，我们需要你从中提取出文件名\u0026quot;a.txt\u0026quot;。\n例如此时选择课程的编号为 C2101，执行指令:\naddWare W210101 ./a.txt\n若指令执行成功，则需要你将 a.txt 文件拷贝到 ./data/C2101/wares/ 文件夹下（这些文件夹是由你在程序运行时自动创建），并命名为 W210101_a.txt。\n移除课程资料 # 此项改动较小，仅指出不同部分。\n使用对象：老师端、助教端 更新：移除课程资料的时候会同步删除对应文件，部分输出格式变更 失败输出（这就是全部的失败输出了，因为下面没写其余不变）： 当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当系统目前登录用户不是使用对象时，输出：\npermission denied 当系统目前没有用户选择课程时，输出：\nno course selected 当课程资料编号未被注册或不在课程中时，系统输出：\nware not found 当删除文件失败时，系统输出：\ndelete file failed Hint:\n注意在删除文件前确保文件未在被使用（例如关闭文件IO流，类似于在电脑上你不能删除你正在打开的文件），最好在删除文件后获取其方法返回值来检验文件是否成功被删除，若未被删除则手动报错。 成功输出不变\n列出课程资料 # 命令 listWare 使用对象：所有人\n功能：列出当前课程的所有资料\n前置条件：已登录、已选择课程\n更新：助教端和学生端可以使用此命令\n失败输出\n当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当用户没有选择课程时，输出：\nno course selected 特殊情况\n当课程中没有资料时，输出：\ntotal 0 ware 添加课程作业 # 此项改动较小，仅指出不同部分。\n命令更新：作业名称变更为作业路径地址，可参考 添加课程资料\n使用对象：管理端\n功能：管理端可以为课程添加作业，添加的作业会统一存放在 ./data/$课程编号/tasks/$作业编号/ 中（需要复制路径地址的文件到指定文件夹下，若存在非本次命令添加的同作业编号文件，则覆盖），命名为 $作业名称 ，其中作业名称被定义为文件名称（包含后缀名）\n前置条件：已登录、已选择课程\n功能更新：涉及文件操作，部分输出变更\n失败输出变更\ntask id duplication 移除，当作业编号重复时，系统会覆盖旧的作业 以下新增的失败输出的判定均在原有判定之后，新增的失败输出的输出顺序即为下文中从上往下出现的顺序\n如果文件并不存在，系统输出：\ntask file not found 最后，如果文件操作失败，系统输出：\nfile operation failed 其余输出不变，输出顺序不变\n移除课程作业 # 此项改动较小，仅指出不同部分。\n使用对象：管理端 更新：移除课程作业的时候会同步删除对应文件（指添加课程作业中添加的文件，不包括后续上传的答案、学生提交的作业以及成绩），部分输出格式变更 失败输出（这就是全部的失败输出了）： 当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当系统目前登录用户不是老师或助教时，输出：\npermission denied 当系统目前没有用户选择课程时，输出：\nno course selected 当课程作业编号未被注册或不在课程中时，系统输出：\ntask not found 当删除文件失败时，系统输出：\ndelete file failed 成功输出不变\n列出课程作业 # 命令 listTask 使用对象：所有人\n功能：列出当前课程的所有作业\n前置条件：已登录、已选择课程\n更新：助教端和学生端可以使用此命令\n成功输出\n助教端和老师端\n[ID:$课程作业编号] [Name:$课程作业名称] [SubmissionStatus:$接收作业份数/$课程总人数] [StartTime:$开始时间] [EndTime:$截止时间] ... 学生端\n[ID:$课程作业编号] [Name:$课程作业名称] [Status:undone/done] [StartTime:$开始时间] [EndTime:$截止时间] ... 补充：作业已经提交过，则状态为done，否则为undone，提交命令见 提交课程作业 失败输出\n当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当用户没有选择课程时，输出：\nno course selected 特殊情况\n当课程中没有作业时，输出：\ntotal 0 task 下载课程文件 # 命令 可选参数1 参数2 可选重定向符号 可选重定向路径 downloadFile [保存路径地址] 文件编号 [\u0026gt; | \u0026gt;\u0026gt;] [路径地址] 使用对象：所有人\n功能：下载当前课程的指定文件编号文件（资料或作业）到保存路径地址下，默认覆盖同名文件，并输出文件内容，可选择将输出文件内容重定向到另一路径地址文件中，此时可选择不保存文件（Hint：本质复制/写入或追加写入）；可选参数1和重定向可同时使用，不冲突，但是两者必须有至少一个\n前置条件：已登录、已选择课程\n备注：评测会保证仅操作文本文件\n成功Example\n$ # temp.txt 内容为 this is a temp $ downloadFile temp.txt T210201 # 下载文件到当前目录下的temp.txt this is a temp $ downloadFile T210201 \u0026gt; temp.txt # 同上，但没有输出 $ downloadFile T210201 \u0026gt;\u0026gt; temp.txt # 追加写入到temp.txt $ downloadFile temp.txt T210201 \u0026gt; result.md # 下载文件到当前目录下的temp.txt，并把输出写入到result.md $ downloadFile temp.txt T210201 \u0026gt;\u0026gt; result.md # 同上，但追加写入到result.md 失败Example\n$ downloadFile # 参数数量不正确 arguments illegal $ downloadFile T210201 # 参数数量不正确 arguments illegal $ downloadFile 1 1 1 # 参数数量不正确 arguments illegal $ downloadFile \u0026gt; please input the path to redirect the file $ downloadFile temp.txt T210201 \u0026gt; temp.txt input file is output file $ downloadFile 114514 \u0026gt; 9m.c # 不存在的文件编号 $ # 9m.c 内容为 file not found 成功输出\n未使用重定向时\n$文件内容 使用重定向时，输出到指定文件中，控制台无输出\n失败输出\n使用重定向且成功时，输出到指定文件中，控制台无输出\n其他情况\n当使用了重定向时缺失重定向文件路径，输出：\nplease input the path to redirect the file 当可选参数1和重定向同时使用，且两者路径相同时，输出：\ninput file is output file 当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当用户没有选择课程时，输出：\nno course selected 当文件编号不合法或不存在时，输出：\nfile not found 当文件操作失败时，输出：\nfile operation failed Hint：\n仅供参考，后面命令同理：在考虑参数数量时，优先判断重定向是否存在，若不存在则参数数量固定；若存在则判断其位置，若是最后一个则缺失重定向路径，倒数第二个则考虑其他，若都不是则参数数量错误（重定向符号后面至多跟着一个参数）。 打开文件 # 命令 可选参数1 可选重定向符号 可选重定向路径 openFile [路径地址] [\u0026lt;] [路径地址] 使用对象：所有人\n功能：打开指定文件并输出文件内容，可选择搭配可选参数1来指定要打开的文件，也可以选择使用重定向来指定打开哪个文件（两种效果一致，后续涉及指定打开文件的命令同理），如果使用可选参数1同时使用重定向输入，忽略重定向输入，下同\n前置条件：无\n备注：评测会保证仅操作文本文件， \u0026lt; 后不会出现超过1个参数的情况（这种情况比较复杂，本次不要求实现，故评测不涉及此情景，无需考虑，感兴趣的可以用 cat 命令来实验一下各种情况的结果），更不会出现有多个 \u0026lt; 的情况\n成功Example\n$ openFile test.txt # 打开当前目录下的test.txt this is a test $ openFile \u0026lt; test.txt # 同上 this is a test $ openFile test.txt \u0026lt; another.txt # 同上，但忽略重定向 this is a test 成功输出\n$文件内容 失败输出\n当未使用重定向时缺失文件路径，输出：\nplease input the path to open the file 当使用了重定向时缺失重定向文件路径，输出：\nplease input the path to redirect the file 当参数数量不正确时，输出：\narguments illegal 当文件打开失败时，输出：\nfile open failed 提交课程作业 # 命令 可选参数1 参数2 可选重定向符号 可选重定向路径 submitTask [作业路径地址] 课程作业编号 [\u0026lt;] [作业路径地址] 使用对象：学生端\n功能：提交指定作业并进行评测，作业需要保存到 ./data/$课程编号/tasks/$作业编号/ 文件夹下（需要复制路径地址的文件到指定文件夹下），并重命名为 $学号.task，如果作业已经存在，则询问是否覆盖。如果使用可选参数1同时使用重定向输入，忽略重定向输入\n前置条件：已登录、已选择课程\n简化条件：为了减轻大家的负担，本平台的作业仅为选择题、填空题、判断题，每题的答案可为任意字符，且不区分大小写，题号即为行号，答案即为行中的字母；分数的计算按百分制，每题分数均等，得分保留到小数点后一位\n限制 你的文件应为如下格式：\n[答案1] [答案2] ... Example：\nT F T T a G d Z Y 114514 1919810 69 996 007 have a nice day! ~/Desktop/submitTask 1 特殊需求：当助教还未上传答案时，分数暂填None，当 查询得分时，如果助教已上传答案，则重新评分，否则不变\n成功输出\nsubmit success your score is: $分数 失败输出\n当使用了重定向时缺失重定向文件路径，输出：\nplease input the path to redirect the file 当参数数量不正确时，输出：\narguments illegal Hint：因为该命令不同于 openFile只有一个可选参数1，所以当只有一个参数的时候并不方便判断这个参数到底是路径还是课程作业编号（需要用到正则，考点重复，这里就不再增加不必要的工作量），所以这里不再特化一个单独的错误输出，直接将所有参数缺失或参数过多相关的问题归为 arguments illegal 。提供一种解题思路：通过有无 \u0026lt; 来分别，若有，则 \u0026lt; 前只接受1-2个参数的情况， \u0026lt; 后缺失参数的情况上一条中已经判断过了， \u0026lt; 后不会出现超过1个参数的情况（这种情况比较复杂，本次不要求实现，故评测不涉及此情景，无需考虑，感兴趣的可以用 cat 命令来实验一下各种情况的结果），更不会出现有多个 \u0026lt; 的情况； 若无 \u0026lt; ，则只接受2个参数的情形；其余情况一律报 arguments illegal ，下面的命令可以用相同的思路考虑\n当系统目前没有用户登录时，输出：\nnot logged in 当系统用户不在使用对象中时，输出：\noperation not allowed 当用户没有选择课程时，输出：\nno course selected 当课程作业编号不合法或不存在时，输出：\ntask not found 当文件操作失败时，输出：\nfile operation failed 特殊情况\n当作业已经存在时，先询问：\ntask already exists, do you want to overwrite it? (y/n) 对于输入的非 yY\\n 的字符，认为是 n，输出：\nsubmit canceled 否则进行文件操作，然后给出成功/文件操作失败输出\nHint：\n建议为学生维护一个例如： 作业编号-\u0026gt;作业文件路径 的映射集合，通过判断对应作业编号的作业文件路径是否存在来判断文件是否存在，若通过文件判断则可能被其他数据点生成的文件影响，则需在每次程序 QUIT 时删除所有提交的作业文件（简单点直接递归删除 data 文件夹）。 添加作业答案 # 命令 可选参数1 参数2 可选重定向符号 可选重定向路径 addAnswer [答案路径地址] 课程作业编号 [\u0026lt;] [答案路径地址] 使用对象：管理端\n功能：为指定作业添加答案，答案需要保存到 ./data/$课程编号/answers/ 文件夹下（需要复制路径地址的文件到指定文件夹下），并重命名为 $作业编号.ans，重复添加答案时，覆盖原有答案。如果使用可选参数1同时使用重定向输入，忽略重定向输入\n前置条件：已登录、已选择课程\n简化条件：同 提交课程作业\n限制：同 提交课程作业\n成功输出\nadd answer success Example\n$ openFile ans.txt B B C $ addAnswer ans.txt T212101 add answer success $ # 这里省略执行了登出命令并登录了所在课程下的学生账号 $ openFile \u0026lt; 1.md B A C $ submitTask T212101 \u0026lt; 1.md submit success your score is: 66.7 $ # 这里假定同学经过思考后修改了答案 $ openFile \u0026lt; 1.md B B C $ submitTask T212101 \u0026lt; 1.md task already exists, do you want to overwrite it? (y/n) y submit success your score is: 100.0 失败输出\n当使用了重定向时缺失重定向文件路径，输出：\nplease input the path to redirect the file 当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当系统用户不在使用对象中时，输出：\npermission denied 当用户没有选择课程时，输出：\nno course selected 当课程作业编号不合法或不存在时，输出：\ntask not found 当文件操作失败时，输出：\nfile operation failed 查询作业成绩 # 命令 可选参数1 可选参数2 queryScore [课程作业编号] [学号] 使用对象：所有人 功能：查询作业的成绩，如果不指定作业编号，则查询该课程下所有作业的成绩；指定学号功能仅管理端可用，可以查询指定学号学生的成绩；同一个作业的成绩仅显示最高分；对于得分为None的作业，如果助教已上传答案，则重新评分，否则不变；顺序为课程作业编号按照字典序升序排列，课程作业编号相同按成绩分数降序排列，分数相同则按照学号字典序升序排列 合法查询：\n管理端：\n不指定 → 查询所有作业的所有学生的成绩\n指定学号 → 查询对应学生下所有作业的成绩\n指定作业编号 → 查询对应作业下所有学生的成绩\n指定作业编号和学号 → 查询对应作业下对应学生的成绩\n学生端：\n不指定 → 查询自己所有作业的成绩\n指定作业编号 → 查询自己在对应作业的成绩\n前置条件：已登录、已选择课程\n成功输出\ntotal $查询到的结果数量 results [1] [ID:$学号] [Name:$姓 $名] [Task_ID:$课程作业编号] [Score:$成绩] ... 失败输出\n当参数数量不正确时，输出：\narguments illegal 当系统目前没有用户登录时，输出：\nnot logged in 当用户没有选择课程时，输出：\nno course selected 当学生指定学号查询时，输出：\npermission denied 当在可选参数1号位识别到课程作业编号且不合法或不存在时，或有两个参数时第一个课程作业编号参数不合法或不存在时，输出：\ntask not found 对于其他情况将参数视为学号，当学号不合法或不存在时，输出：\nstudent not found 特殊情况\n当查询到的结果数量为0时，输出：\ntotal 0 result 当查询到的结果数量为1时，输出第一行变更为：\ntotal 1 result Hint:\n实际上并不会出现 None 和分数比较的情况，因为对于同一个作业，有分数说明助教已经上传答案，此时就会重新评判，原本 None 的也会得到相应分数。 "},{"id":14,"href":"/Java-HomeWork/docs/Q-A/","title":"Q \u0026 A","section":"Docs","content":" Q \u0026amp; A # 助教们会总结大家的一些共性问题，并在此做出解答，不定期更新。\n"},{"id":15,"href":"/Java-HomeWork/docs/Q-A/%E7%AC%AC%E4%B8%80%E6%9C%9F/","title":"第一期","section":"Q \u0026 A","content":" OOP实验猪脚说——第一期 # 前言 # 因为同学们的共性问题非常多，所以各位助教（猪脚）总结并写了下来方便各位查阅，不定期更新，希望能帮到大家。\n迭代实验 # 前置步骤 # Windows用户 # 下载群内提供的patpat示例教程.zip并解压，使用方式在其中的README.md中有详细说明。为了防止大家懒得看，也可以看接下来的步骤；\npatpat-windows-amd64.exe需要重新命名为patpat.exe；\n在patpat示例教程下打开终端（命令行）运行如下命令：\n./patpat reg -sid your_sid -pwd your_password # 如./patpat reg -sid 18373722 -pwd buaa-se-oop 账号创建后，密码不支持修改。如需修改，请联系助教。\nmacOS或Linux用户 # 下载群内提供的patpat示例教程.zip并解压，使用方式在其中的README.md中有详细说明。为了防止大家懒得看，也可以看接下来的步骤；\n下载群内提供的patpat各版本.zip并解压，选择正确的版本移入patpat示例教程文件夹中，替换并删除掉原有的patpat-windows-amd64.exe；\n替换后的文件需要重新命名为patpat；\n在patpat示例教程下打开终端（命令行）运行chmod +x patpat，使评测机程序具有可执行权限；\n在patpat示例教程下打开终端（命令行）运行如下命令：\n./patpat reg -sid your_sid -pwd your_password # 如./patpat reg -sid 18373722 -pwd buaa-se-oop 账号创建后，密码不支持修改。如需修改，请联系助教。\n实验具体流程 # 编写完迭代作业的代码；\n建立一个n-学号-姓名的文件夹在patpat示例教程下，其内建立out文件夹（out是n-学号-姓名文件夹的子孙）；\n把你idea中的src文件夹直接复制粘入n-学号-姓名中 （src是out的兄弟）；\n终端（命令行）中运行\n./patpat ta -judge 1-学号-姓名 -pwd your_pwd -tag 随意打一些文字，可以用来标注第几次尝试 # 线上测试命令 命令（不是stu命令不是stu命令不是stu命令，自己编写测试文件和stu自测基本上用不到，只是提供了这么个功能，完全没必要用，我上次就没用过）；\npatpat给出所有测试点AC（重要！！不满足ta命令全AC你的迭代作业不会有分数）；\n打包n-学号-姓名文件夹交到云平台对应实验中。\n常见错误 # 编码格式有误，最简单粗暴的方法：删除中文注释或改成英文注释。或者调整文件编码与默认编码格式一致。\n已知 JDK 18 版本主要集中在 9 个增强功能上，其中之一即是将 UTF-8 设置为标准 Java API 的默认字符集。在 JDK 17 及更早版本中，默认字符集要在 Java 虚拟机运行时才能确定，所以取决于不同的操作系统、语言环境等因素，在实现和处理方面存在着一些问题。而从Java 18开始，依赖于默认字符集的 API 会在所有实现、操作系统、语言环境和配置中保持一致。\n项目结构有误，所有Java文件应直接放在src文件夹下，此时应没有任何package语句。\n文件路径有误，在涉及文件读写时注意文件路径，在使用patpat运行时目录是在patpat所在目录，例如访问src文件夹应./1-学号-姓名/src这样去访问，建议在访问或创建文件/文件夹时逐级判断文件夹是否存在，若不存在则创建或抛出异常。\n关于TLE：我们没有特别限制迭代任务的时长，如果有这种情况一定是有BUG的，请自查。不过还有一种特殊情况会导致TLE，那就是你的代码中new了多个Scanner实例，patpat仅支持单一Scanner实例，这点非常重要，请检查。\n关于RE：只要exit code不为0，那一定是发生了异常但是你没有try-catch，导致异常直接被抛出，程序终止运行。这种情况你的程序是一定存在bug的，通用的做法是使用try-catch包裹可能会抛出异常的代码段，并用println打印出异常信息，这样你就可以知道是哪里出了问题了，即使是在patpat评测中，发生了异常你的输出也会被打印在“实际输出行”中，方便debug。大致的检查方向是：NPE、IO异常、数组越界、除0异常、类型转换异常、NumberFormatException(Integer.parseInt)等等。\n基础知识 # 关于javac和java命令 # Java执行class文件是根据CLASSPATH指定的地方来找，而非当前目录。如果希望它查询当前目录，需要在CLASSPATH中加入.;，代表当前目录，分号用于隔开不同查询目录。\n可以使用 -cp . 来临时设置CLASSPATH为当前目录，只对本次执行有效。\n在使用例如javac -d out ./src/test/*.java进行打包编译后，在运行时需要带上包名，例如：\ncd out java test.Test // 假定Test为主类 从String类型了解引用数据类型 # Java基础之String类型详解_阿星_Alex的博客-CSDN博客_javastring类型\nJava的引用与C的指针比较 # Java中的“引用类型”和C中的“指针”区别_chengwei1128的博客-CSDN博客_c语言指针和java引用区别\n类变量的初始化顺序 # Java语法专题2: 类变量的初始化顺序 - Milton - 博客园 (cnblogs.com)\n"},{"id":16,"href":"/Java-HomeWork/docs/Resource/Java8-17%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/","title":"Java8 17语法新特性总结","section":"Resource","content":" Java8-17语法新特性总结 # 班级：202115\n学号：19377054\n姓名：周洪熙\nJava 8 # Interface # interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，interface 修改的时候，实现它的类也必须跟着改。\n为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用 default 或 static 修饰，这样就可以有方法体，实现类也不必重写此方法。\n一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。\ndefault 修饰的方法，是普通实例方法，可以用this调用，可以被子类继承、重写。\nstatic 修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用Interface调用。 我们来看一个实际的例子。\npublic interface InterfaceNew { static void sm() { System.out.println(\u0026#34;interface提供的方式实现\u0026#34;); } static void sm2() { System.out.println(\u0026#34;interface提供的方式实现\u0026#34;); } default void def() { System.out.println(\u0026#34;interface default方法\u0026#34;); } default void def2() { System.out.println(\u0026#34;interface default2方法\u0026#34;); } //须要实现类重写 void f(); } public interface InterfaceNew1 { default void def() { System.out.println(\u0026#34;InterfaceNew1 default方法\u0026#34;); } } 如果有一个类既实现了 InterfaceNew 接口又实现了 InterfaceNew1 接口，它们都有 def() ，并且 InterfaceNew 接口和 InterfaceNew1 接口没有继承关系的话，这时就必须重写 def() 。不然的话，编译的时候就会报错。\npublic class InterfaceNewImpl implements InterfaceNew , InterfaceNew1{ public static void main(String[] args) { InterfaceNewImpl interfaceNew = new InterfaceNewImpl(); interfaceNew.def(); } @Override public void def() { InterfaceNew1.super.def(); } @Override public void f() { } } Lambda 表达式 # (parameters) -\u0026gt; expression 或 (parameters) -\u0026gt;{ statements; } Example: 替代匿名内部类\nList\u0026lt;Integer\u0026gt; strings = Arrays.asList(1, 2, 3); //以前 Collections.sort(strings, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2;} }); //Lambda Collections.sort(strings, (Integer o1, Integer o2) -\u0026gt; o1 - o2); //分解开 Comparator\u0026lt;Integer\u0026gt; comperator = (Integer o1, Integer o2) -\u0026gt; o1 - o2; Collections.sort(strings, comperator); Example: 集合迭代\nvoid lamndaFor() { List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;); //传统foreach for (String s : strings) { System.out.println(s); } //Lambda foreach strings.forEach((s) -\u0026gt; System.out.println(s)); //or strings.forEach(System.out::println); //map Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.forEach((k,v) -\u0026gt; System.out.println(v)); } Example: 访问变量\nint i = 0; Collections.sort(strings, (Integer o1, Integer o2) -\u0026gt; o1 - i); lambda 表达式可以引用外部变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。\n方法的引用 # Java 8 允许使用 :: 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。\npublic class LambdaClassSuper { LambdaInterface sf(){ return null; } } public class LambdaClass extends LambdaClassSuper { public static LambdaInterface staticF() { return null; } public LambdaInterface f() { return null; } void show() { //1.调用静态函数，返回类型必须是functional-interface LambdaInterface t = LambdaClass::staticF; //2.实例方法调用 LambdaClass lambdaClass = new LambdaClass(); LambdaInterface lambdaInterface = lambdaClass::f; //3.超类上的方法调用 LambdaInterface superf = super::sf; //4. 构造方法调用 LambdaInterface tt = LambdaClassSuper::new; } } Optional # 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：\n1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。\n反例：public int f() { return Integer 对象 }， 如果为 null，自动解箱抛 NPE。\n2） 数据库的查询结果可能为 null。\n3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。\n4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。\n5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。\n6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。\n正例：使用 JDK8 的 Optional 类来防止 NPE 问题。\n如何创建一个 Optional # /** * Common instance for {@code empty()}. 全局EMPTY对象 */ private static final Optional\u0026lt;?\u0026gt; EMPTY = new Optional\u0026lt;\u0026gt;(); /** * Optional维护的值 */ private final T value; /** * 如果value是null就返回EMPTY，否则就返回of(T) */ public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value) { return value == null ? empty() : of(value); } /** * 返回 EMPTY 对象 */ public static\u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; empty() { Optional\u0026lt;T\u0026gt; t = (Optional\u0026lt;T\u0026gt;) EMPTY; return t; } /** * 返回Optional对象 */ public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; of(T value) { return new Optional\u0026lt;\u0026gt;(value); } /** * 私有构造方法，给value赋值 */ private Optional(T value) { this.value = Objects.requireNonNull(value); } /** * 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题 */ public static \u0026lt;T\u0026gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } ofNullable 方法和 of 方法唯一区别就是当 value 为 null 时， ofNullable 返回的是EMPTY， of 会抛出 NullPointerException 异常。如果需要把 NullPointerException 暴露出来就用 of ，否则就用 ofNullable 。\nmap()相关方法 # /** * 如果value为null，返回EMPTY，否则返回Optional封装的参数值 */ public\u0026lt;U\u0026gt; Optional\u0026lt;U\u0026gt; map(Function\u0026lt;? super T, ? extends U\u0026gt; mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Optional.ofNullable(mapper.apply(value)); } } /** * 如果value为null，返回EMPTY，否则返回Optional封装的参数值，如果参数值返回null会抛 NullPointerException */ public\u0026lt;U\u0026gt; Optional\u0026lt;U\u0026gt; flatMap(Function\u0026lt;? super T, Optional\u0026lt;U\u0026gt;\u0026gt; mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Objects.requireNonNull(mapper.apply(value)); } } flatMap() 参数返回值如果是 null 会抛 NullPointerException ，而 map() 返回EMPTY。\n判断 value 是否为 null # /** * value是否为null */ public boolean isPresent() { return value != null; } /** * 如果value不为null执行consumer.accept */ public void ifPresent(Consumer\u0026lt;? super T\u0026gt; consumer) { if (value != null) consumer.accept(value); } 获取 value # /** * Return the value if present, otherwise invoke {@code other} and return * the result of that invocation. * 如果value != null 返回value，否则返回other的执行结果 */ public T orElseGet(Supplier\u0026lt;? extends T\u0026gt; other) { return value != null ? value : other.get(); } /** * 如果value != null 返回value，否则返回T */ public T orElse(T other) { return value != null ? value : other; } /** * 如果value != null 返回value，否则抛出参数返回的异常 */ public \u0026lt;X extends Throwable\u0026gt; T orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier) throws X { if (value != null) { return value; } else { throw exceptionSupplier.get(); } } /** * value为null抛出NoSuchElementException，不为空返回value。 */ public T get() { if (value == null) { throw new NoSuchElementException(\u0026#34;No value present\u0026#34;); } return value; } 过滤值 # /** * 1. 如果是empty返回empty * 2. predicate.test(value)==true 返回this，否则返回empty */ public Optional\u0026lt;T\u0026gt; filter(Predicate\u0026lt;? super T\u0026gt; predicate) { Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty(); } Date-Time API # 这是对 java.util.Date 强有力的补充，解决了 Date 类的大部分痛点：\n非线程安全 时区处理麻烦 各种格式化、和时间计算繁琐 设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。 我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用 java.util.Date 的代码该改改了。\njava.time 主要类 # LocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS LocalDate.class //日期 format: yyyy-MM-dd LocalTime.class //时间 format: HH:mm:ss 格式化 # public void newFormat() { //format yyyy-MM-dd LocalDate date = LocalDate.now(); System.out.println(String.format(\u0026#34;date format : %s\u0026#34;, date)); //format HH:mm:ss LocalTime time = LocalTime.now().withNano(0); System.out.println(String.format(\u0026#34;time format : %s\u0026#34;, time)); //format yyyy-MM-dd HH:mm:ss LocalDateTime dateTime = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); String dateTimeStr = dateTime.format(dateTimeFormatter); System.out.println(String.format(\u0026#34;dateTime format : %s\u0026#34;, dateTimeStr)); } 字符串转日期格式 # LocalDate date = LocalDate.of(2021, 1, 26); LocalDate.parse(\u0026#34;2021-01-26\u0026#34;); LocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22); LocalDateTime.parse(\u0026#34;2021-01-26 12:12:22\u0026#34;); LocalTime time = LocalTime.of(12, 12, 22); LocalTime.parse(\u0026#34;12:12:22\u0026#34;); 日期计算 # public void pushWeek() { //一周后的日期 LocalDate localDate = LocalDate.now(); //方法1 LocalDate after = localDate.plus(1, ChronoUnit.WEEKS); //方法2 LocalDate after2 = localDate.plusWeeks(1); System.out.println(\u0026#34;一周后日期：\u0026#34; + after); //算两个日期间隔多少天，计算间隔多少年，多少月 LocalDate date1 = LocalDate.parse(\u0026#34;2021-02-26\u0026#34;); LocalDate date2 = LocalDate.parse(\u0026#34;2021-12-23\u0026#34;); Period period = Period.between(date1, date2); System.out.println(\u0026#34;date1 到 date2 相隔：\u0026#34; + period.getYears() + \u0026#34;年\u0026#34; + period.getMonths() + \u0026#34;月\u0026#34; + period.getDays() + \u0026#34;天\u0026#34;); //打印结果是 “date1 到 date2 相隔：0年9月27天” //这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数 //如果要获取纯粹的总天数应该用下面的方法 long day = date2.toEpochDay() - date1.toEpochDay(); System.out.println(date2 + \u0026#34;和\u0026#34; + date2 + \u0026#34;相差\u0026#34; + day + \u0026#34;天\u0026#34;); //打印结果：2021-12-23和2021-12-23相差300天 } 获取指定日期 # public void getDayNew() { LocalDate today = LocalDate.now(); //获取当前月第一天： LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); // 取本月最后一天 LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); //取下一天： LocalDate nextDay = lastDayOfThisMonth.plusDays(1); //当年最后一天 LocalDate lastday = today.with(TemporalAdjusters.lastDayOfYear()); //2021年最后一个周日，如果用Calendar是不得烦死。 LocalDate lastMondayOf2021 = LocalDate.parse(\u0026#34;2021-12-31\u0026#34;).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY)); } 时区 # //当前时区时间 ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(\u0026#34;当前时区时间: \u0026#34; + zonedDateTime); //东京时间 ZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get(\u0026#34;JST\u0026#34;)); ZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId); System.out.println(\u0026#34;东京时间: \u0026#34; + tokyoTime); // ZonedDateTime 转 LocalDateTime LocalDateTime localDateTime = tokyoTime.toLocalDateTime(); System.out.println(\u0026#34;东京时间转当地时间: \u0026#34; + localDateTime); //LocalDateTime 转 ZonedDateTime ZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault()); System.out.println(\u0026#34;本地时区时间: \u0026#34; + localZoned); //打印结果 当前时区时间: 2021-01-27T14:43:58.735+08:00[Asia/Shanghai] 东京时间: 2021-01-27T15:43:58.735+09:00[Asia/Tokyo] 东京时间转当地时间: 2021-01-27T15:43:58.735 当地时区时间: 2021-01-27T15:53:35.618+08:00[Asia/Shanghai] Java 9 # JShell # JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。 可以在终端使用 jshell 命令进入。\n模块化系统 # 什么是模块系统？ 简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（module-info.java）。 任意一个 jar 文件，只要加上一个模块描述文件（module-info.java），就可以升级为一个模块。\n在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlinkopen in new window 工具 (Jlink 是随 Java 9 一起发布的新命令行工具。它允许开发人员为基于模块的 Java 应用程序创建自己的轻量级、定制的 JRE)，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。\n在JDK 9中，您可以如下声明这两个模块：\nmodule policy { exports pkg1; } module claim { requires policy; } 我们可以通过 exports 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。\nmodule my.module { //exports 公开指定包的所有公共成员 exports com.my.package.name; } module my.module { //exports…to 限制访问的成员范围 export com.my.package.name to com.specific.package; } 具体地，参考： Java 9 揭秘（2. 模块化系统）\n快速创建不可变集合 # List.of(\u0026#34;Java\u0026#34;, \u0026#34;C++\u0026#34;); Set.of(\u0026#34;Java\u0026#34;, \u0026#34;C++\u0026#34;); Map.of(\u0026#34;Java\u0026#34;, 1, \u0026#34;C++\u0026#34;, 2); 接口私有方法 # public interface MyInterface { private void methodPrivate(){ } } try-with-resources 增强 # 在 Java 9 之前，我们只能在 try-with-resources 块中声明变量：\ntry (Scanner scanner = new Scanner(new File(\u0026#34;testRead.txt\u0026#34;)); PrintWriter writer = new PrintWriter(new File(\u0026#34;testWrite.txt\u0026#34;))) { // omitted } 在 Java 9 之后，在 try-with-resources 语句中可以使用 effectively-final 变量。\nfinal Scanner scanner = new Scanner(new File(\u0026#34;testRead.txt\u0026#34;)); PrintWriter writer = new PrintWriter(new File(\u0026#34;testWrite.txt\u0026#34;)) try (scanner;writer) { // omitted } 什么是 effectively-final 变量？ 简单来说就是没有被 final 修饰但是值在初始化后从未更改的变量。\n正如上面的代码所演示的那样，即使 writer 变量没有被显示声明为 final ，但它在第一次被赋值后就不会改变了，因此，它就是 effectively-final 变量。\nStream \u0026amp; Optional 增强 # // Stream // ofNullable() Stream\u0026lt;String\u0026gt; stringStream = Stream.ofNullable(\u0026#34;Java\u0026#34;); System.out.println(stringStream.count());// 1 Stream\u0026lt;String\u0026gt; nullStream = Stream.ofNullable(null); System.out.println(nullStream.count());//0 // takeWhile() List\u0026lt;Integer\u0026gt; integerList = List.of(11, 33, 66, 8, 9, 13); integerList.stream().takeWhile(x -\u0026gt; x \u0026lt; 50).forEach(System.out::println);// 11 33 // dropWhile() List\u0026lt;Integer\u0026gt; integerList2 = List.of(11, 33, 66, 8, 9, 13); integerList2.stream().dropWhile(x -\u0026gt; x \u0026lt; 50).forEach(System.out::println);// 66 8 9 13 // iterate() public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; iterate(final T seed, final UnaryOperator\u0026lt;T\u0026gt; f) { } // 新增加的重载方法 public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; iterate(T seed, Predicate\u0026lt;? super T\u0026gt; hasNext, UnaryOperator\u0026lt;T\u0026gt; next) { } // 使用原始 iterate() 方法输出数字 1~10 Stream.iterate(1, i -\u0026gt; i + 1).limit(10).forEach(System.out::println); // 使用新的 iterate() 重载方法输出数字 1~10 Stream.iterate(1, i -\u0026gt; i \u0026lt;= 10, i -\u0026gt; i + 1).forEach(System.out::println); // Optional // ifPresentOrElse() public void ifPresentOrElse(Consumer\u0026lt;? super T\u0026gt; action, Runnable emptyAction) Optional\u0026lt;Object\u0026gt; objectOptional = Optional.empty(); objectOptional.ifPresentOrElse(System.out::println, () -\u0026gt; System.out.println(\u0026#34;Empty!!!\u0026#34;));// Empty!!! // or() public Optional\u0026lt;T\u0026gt; or(Supplier\u0026lt;? extends Optional\u0026lt;? extends T\u0026gt;\u0026gt; supplier) Optional\u0026lt;Object\u0026gt; objectOptional = Optional.empty(); objectOptional.or(() -\u0026gt; Optional.of(\u0026#34;java\u0026#34;)).ifPresent(System.out::println);//java 进程 API # // java.lang.ProcessHandle // 获取当前正在运行的 JVM 的进程 ProcessHandle currentProcess = ProcessHandle.current(); // 输出进程的 id System.out.println(currentProcess.pid()); // 输出进程的信息 System.out.println(currentProcess.info()); Java 10 # 局部变量类型推断(var) # var id = 0; var codefx = new URL(\u0026#34;https://mp.weixin.qq.com/\u0026#34;); var list = new ArrayList\u0026lt;\u0026gt;(); var list = List.of(1, 2, 3); var map = new HashMap\u0026lt;String, String\u0026gt;(); var p = Paths.of(\u0026#34;src/test/java/Java9FeaturesTest.java\u0026#34;); var numbers = List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); for (var n : list) System.out.print(n+ \u0026#34; \u0026#34;); var count=null; //❌编译不通过，不能声明为 null var r = () -\u0026gt; Math.random();//❌编译不通过,不能声明为 Lambda表达式 var array = {1,2,3};//❌编译不通过,不能声明数组 var 并不会改变 Java 是一门静态类型语言的事实，编译器负责推断出类型。\n集合增强 # // List，Set，Map 提供了静态方法copyOf()返回入参集合的一个不可变拷贝 static \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; copyOf(Collection\u0026lt;? extends E\u0026gt; coll) { return ImmutableCollections.listCopy(coll); } // java.util.stream.Collectors 中新增了静态方法，用于将流中的元素收集为不可变的集合 var list = new ArrayList\u0026lt;\u0026gt;(); list.stream().collect(Collectors.toUnmodifiableList()); list.stream().collect(Collectors.toUnmodifiableSet()); Optional 增强 # // Optional 新增了orElseThrow()方法来在没有值时抛出指定的异常 Optional.ofNullable(cache.getIfPresent(key)) .orElseThrow(() -\u0026gt; new PrestoException(NOT_FOUND, \u0026#34;Missing entry found for key: \u0026#34; + key)); Java 11 # HTTP Client 标准化 # 这里建议使用第三方库 com.squareup.okhttp3 ，这里就不再过多介绍原生API。\nString 增强 # //判断字符串是否为空 \u0026#34; \u0026#34;.isBlank();//true //去除字符串首尾空格 \u0026#34; Java \u0026#34;.strip();// \u0026#34;Java\u0026#34; //去除字符串首部空格 \u0026#34; Java \u0026#34;.stripLeading(); // \u0026#34;Java \u0026#34; //去除字符串尾部空格 \u0026#34; Java \u0026#34;.stripTrailing(); // \u0026#34; Java\u0026#34; //重复字符串多少次 \u0026#34;Java\u0026#34;.repeat(3); // \u0026#34;JavaJavaJava\u0026#34; //返回由行终止符分隔的字符串集合。 \u0026#34;A\\nB\\nC\u0026#34;.lines().count(); // 3 \u0026#34;A\\nB\\nC\u0026#34;.lines().collect(Collectors.toList()); Optional 增强 # // 新增了empty()方法来判断指定的 Optional 对象是否为空 var op = Optional.empty(); System.out.println(op.isEmpty());//判断指定的 Optional 对象是否为空 Lambda 参数的局部变量语法 # // Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明 // 下面两者是等价的 Consumer\u0026lt;String\u0026gt; consumer = (var i) -\u0026gt; System.out.println(i); Consumer\u0026lt;String\u0026gt; consumer = (String i) -\u0026gt; System.out.println(i); Java 12 # String 增强 # // indent() 方法可以实现字符串缩进 String text = \u0026#34;Java\u0026#34;; // 缩进 4 格 text = text.indent(4); System.out.println(text); text = text.indent(-10); System.out.println(text); // output Java Java // transform() 方法可以用来转变指定字符串 String result = \u0026#34;foo\u0026#34;.transform(input -\u0026gt; input + \u0026#34; bar\u0026#34;); System.out.println(result); // foo bar Files 增强（文件比较） # // mismatch() 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L Path filePath1 = Files.createTempFile(\u0026#34;file1\u0026#34;, \u0026#34;.txt\u0026#34;); Path filePath2 = Files.createTempFile(\u0026#34;file2\u0026#34;, \u0026#34;.txt\u0026#34;); Files.writeString(filePath1, \u0026#34;Java 12 Article\u0026#34;); Files.writeString(filePath2, \u0026#34;Java 12 Article\u0026#34;); long mismatch = Files.mismatch(filePath1, filePath2); assertEquals(-1, mismatch); // 不相同 Path filePath3 = Files.createTempFile(\u0026#34;file3\u0026#34;, \u0026#34;.txt\u0026#34;); Path filePath4 = Files.createTempFile(\u0026#34;file4\u0026#34;, \u0026#34;.txt\u0026#34;); Files.writeString(filePath3, \u0026#34;Java 12 Article\u0026#34;); Files.writeString(filePath4, \u0026#34;Java 12 Tutorial\u0026#34;); long mismatch = Files.mismatch(filePath3, filePath4); assertEquals(8, mismatch); 数字格式化工具类 # // NumberFormat 新增了对复杂的数字进行格式化的支持 NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT); String result = fmt.format(1000); System.out.println(result); // output 1K Java 13 # SocketAPI 重构 # Java 13 将 Socket API 的底层进行了重写， NioSocketImpl 是对 PlainSocketImpl 的直接替代，它使用 java.util.concurrent 包下的锁而不是同步方法。如果要使用旧实现，请使用 -Djdk.net.usePlainSocketImpl=true 。\n并且，在 Java 13 中是默认使用新的 Socket 实现。\npublic final class NioSocketImpl extends SocketImpl implements PlatformSocketImpl { } FileSystems # FileSystems 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：\nnewFileSystem(Path) newFileSystem(Path, Map\u0026lt;String, ?\u0026gt;) newFileSystem(Path, Map\u0026lt;String, ?\u0026gt;, ClassLoader) Java 14 # 空指针异常精准提示 # 通过 JVM 参数中添加 -XX:+ShowCodeDetailsInExceptionMessages ，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。\na.b.c.i = 99; // 假设这段代码会发生空指针 // 增加参数后提示的异常中很明确的告知了哪里为空导致 Exception in thread \u0026#34;main\u0026#34; java.lang.NullPointerException: Cannot read field \u0026#39;c\u0026#39; because \u0026#39;a.b\u0026#39; is null. at Prog.main(Prog.java:5) switch 的增强 # // 传统的 switch 语法存在容易漏写 break 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复 // Java12 增强了 swtich 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break switch (day) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; System.out.println(6); case TUESDAY -\u0026gt; System.out.println(7); case THURSDAY, SATURDAY -\u0026gt; System.out.println(8); case WEDNESDAY -\u0026gt; System.out.println(9); } // Java 13 中 Switch 表达式中多了一个关键字用于跳出 Switch 块的关键字 yield，主要用于返回一个值 // yield和 return 的区别在于：return 会直接跳出当前循环或者方法，而 yield 只会跳出当前 Switch 块，同时在使用 yield 时，需要有 default 条件 // ex1 String result = switch (day) { case \u0026#34;M\u0026#34;, \u0026#34;W\u0026#34;, \u0026#34;F\u0026#34; -\u0026gt; \u0026#34;MWF\u0026#34;; case \u0026#34;T\u0026#34;, \u0026#34;TH\u0026#34;, \u0026#34;S\u0026#34; -\u0026gt; \u0026#34;TTS\u0026#34;; default -\u0026gt; { if (day.isEmpty()) yield \u0026#34;Please insert a valid day.\u0026#34;; else yield \u0026#34;Looks like a Sunday.\u0026#34;; } }; System.out.println(result); // ex2 private static String descLanguage(String name) { return switch (name) { case \u0026#34;Java\u0026#34;: yield \u0026#34;object-oriented, platform independent and secured\u0026#34;; case \u0026#34;Ruby\u0026#34;: yield \u0026#34;a programmer\u0026#39;s best friend\u0026#34;; default: yield name +\u0026#34; is a good language\u0026#34;; }; } Java 15 # CharSequence # // CharSequence 接口添加了一个默认方法 isEmpty() 来判断字符序列为空，如果是则返回 true public interface CharSequence { default boolean isEmpty() { return this.length() == 0; } } TreeMap # TreeMap 新引入了下面这些方法：\nputIfAbsent() computeIfAbsent() computeIfPresent() compute() merge() EdDSA(数字签名算法) # // 新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。 // 虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。 KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;Ed25519\u0026#34;); KeyPair kp = kpg.generateKeyPair(); byte[] msg = \u0026#34;test_string\u0026#34;.getBytes(StandardCharsets.UTF_8); Signature sig = Signature.getInstance(\u0026#34;Ed25519\u0026#34;); sig.initSign(kp.getPrivate()); sig.update(msg); byte[] s = sig.sign(); String encodedString = Base64.getEncoder().encodeToString(s); System.out.println(encodedString); 文本块 # 解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入三重双引号来定义多行文本。 Java 13 支持两个 \u0026quot;\u0026quot;\u0026quot; 符号中间的任何内容都会被解释为字符串的一部分，包括换行符。\nString json = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;name\u0026#34;:\u0026#34;mkyong\u0026#34;, \u0026#34;age\u0026#34;:38 } \u0026#34;\u0026#34;\u0026#34;; String query = \u0026#34;\u0026#34;\u0026#34; SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB` WHERE `CITY` = \u0026#39;INDIANAPOLIS\u0026#39; ORDER BY `EMP_ID`, `LAST_NAME`; \u0026#34;\u0026#34;\u0026#34;; 另外， String 类新增加了 3 个新的方法来操作文本块：\nformatted(Object... args) ：它类似于 String 的 format() 方法。添加它是为了支持文本块的格式设置。 stripIndent() ：用于去除文本块中每一行开头和结尾的空格。 translateEscapes() ：转义序列如 “\\t” 转换为 “\\t” Java 14 中，为其引入了两个新的转义字符：\n\\ : 表示行尾，不引入换行符 \\s ：表示单个空格 String str = \u0026#34;凡心所向，素履所往，生如逆旅，一苇以航。\u0026#34;; String str2 = \u0026#34;\u0026#34;\u0026#34; 凡心所向，素履所往， \\ 生如逆旅，一苇以航。\u0026#34;\u0026#34;\u0026#34;; System.out.println(str2);// 凡心所向，素履所往， 生如逆旅，一苇以航。 String text = \u0026#34;\u0026#34;\u0026#34; java c++\\sphp \u0026#34;\u0026#34;\u0026#34;; System.out.println(text); // 输出： java c++ php Java 16 # 记录类型 # Java 14 引入 record 关键字， record 提供一种紧凑的语法来定义类中的不可变数据。\nrecord 关键字可以简化数据类（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 record 代替 class 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 toString() ， hashCode()， equals() 方法。\n类似于使用 class 定义类，同时使用了 lombok 插件，并打上了 @Getter , @ToString ， @EqualsAndHashCode 注解\n/** * 这个类具有两个特征 * 1. 所有成员属性都是final * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个） * 那么这种类就很适合使用record来声明 */ final class Rectangle implements Shape { final double length; final double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } double length() { return length; } double width() { return width; } } /** * 1. 使用record声明的类会自动拥有上面类中的三个方法 * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法 * 3. toString方法中包括所有成员属性的字符串表示形式及其名称 */ record Rectangle(float length, float width) { } Java 15 支持在局部方法和接口中使用 record 。\nJava 16 中非静态内部类可以定义非常量的静态成员。\npublic class Outer { class Inner { static int age; } } instanceof 模式匹配 # Java 12 首次引入 instanceof 模式匹配。\nJava 13, 14, 15 相比较上个版本无变化，继续收集更多反馈。\nJava 16 模式变量不再隐式为 final。\n新版的 instanceof 可以在判断是否属于具体的类型同时完成转换。\nObject obj = \u0026#34;我是字符串\u0026#34;; if(obj instanceof String str){ System.out.println(str); } // 从 Java SE 16 开始，你可以对 instanceof 中的变量值进行修改。 public void learn(Object obj) { if (obj instanceof String s) { System.out.println(s); s = \u0026#34;JavaGuide\u0026#34;; System.out.println(s); } } Java 17 # 密封类 # 密封类可以对继承或者实现它们的类进行限制。\n比如抽象类 Person 只允许 Employee 和 Manager 继承。\npublic abstract sealed class Person permits Employee, Manager { //... } 另外，任何扩展密封类的类本身都必须声明为 sealed 、 non-sealed 或 final 。\npublic final class Employee extends Person { } public non-sealed class Manager extends Person { } 如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。\n在 JDK 15 引入的 sealed class（密封类）在 JDK 16 得到了改进：更加严格的引用检查和密封类的继承关系。\nStream.toList() # 如果需要将 Stream 转换成 List ,需要通过调用 collect 方法使用 Collectors.toList() ，代码非常冗长。\n在Java 17中将会变得简单，可以直接调用 toList() 。\nprivate static void streamToList() { Stream\u0026lt;String\u0026gt; stringStream = Stream.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); List\u0026lt;String\u0026gt; stringList = stringStream.toList(); for(String s : stringList) { System.out.println(s); } } "},{"id":17,"href":"/Java-HomeWork/docs/Resource/","title":"Resource","section":"Docs","content":" 也许有用的资源 # Patpat 官方文档\n涛哥的 OMS， \\zht/\\zht/\\zht/\nJava8 API 文档\nJava17 API 文档\n（如果在完成作业的时候发现了有用的资源 / 写的不错的博客， 也可以联系 ZHX 加到这个页面上）\n"}]