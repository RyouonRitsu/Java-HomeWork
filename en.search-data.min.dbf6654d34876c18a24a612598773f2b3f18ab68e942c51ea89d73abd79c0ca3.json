[{"id":0,"href":"/Java-HomeWork/docs/OOP-LAB/","title":"Oop Lab","section":"Docs","content":" LAB -\u0026gt; 这个实验是每周都有的 # 不用太纠结于名字的问题，只需要知道这些东西每周都要写就行了\n（历史遗留\u0026hellip;）\n"},{"id":1,"href":"/Java-HomeWork/docs/OOP-LAB/LAB01/","title":"Lab01","section":"Oop Lab","content":" Lab01: 认识 Java # 1. 实验⽬的 # 掌握 Java 环境配置 使用 CMD 编译运行 Java 程序 使用 IDE 编译运行 Java 应用程序 理解 Java 语言中的关键字、标识符并能灵活使用 理解、掌握 Java 语言的简单数据类型并能灵活使用（重点强制类型转换） 理解引用数据类型，理解简单数据类型和引用数据类型的特点 理解、掌握 Java 语言中的运算符并能灵活使用 理解、掌握常量与变量的概念并能灵活使用 2. 编译与运行 # Question01 # 借助身边的工具，学习 java， javac 等命令的使用，并尝试通过命令行来编译并运行一个 Java 程序，输出 Hello, World!，提交你所使用的命令和运行结果截图。\nQuestion02 # 相信这一定难不倒聪明的你，接下来我们略微增加一点点难度 ~ 你需要输出很多 Hello, World!\n本题需要你实现一个 Test 类：\n程序开始运行，进入main方法，并输出你的学号和姓名\n当终端输入 QUIT 时，系统退出，并在终端打印一行字符：\n----- Good Bye! ----- 对于其他的输入，在终端中输出一行 Hello, World!，等待下一行输入 你需要提交运行时的截图。\n程序退出 # 和 C 语言的return 0类似，Java 程序也有其退出码，整个程序的正常的退出码应该为 0，而不应该为-1、1 等。\n在测评机中，退出状态非 0 则会被认为是程序未正常结束，很容易导致你的作业被错判，因此请务必注意若需要在循环等程序正在运行时的情况进行退出，应确保退出状态为 0\n下面给出 Java 中退出的一个例子：\nclass Example { public static void main(String[] args) { int x = 0; while (true) { x++; if (x \u0026gt; 10) { System.out.println(\u0026#34;----- Good Bye! -----\u0026#34;); System.exit(0); } } } } // 这只是退出程序的一种方法，当然，针对该例子，你也可以直接使用break，跳出while循环，直接到达整个程序的退出区域（默认退出状态为0） 参考实现 # Java 打印字符串与其他语言有所区别，不是直接调用 print 函数，可以用如下语句： String str = \u0026#34;Hello world!\u0026#34; System.out.println(str); Java 连续读取输入行的一种实现： Scanner in = new Scanner(System.in); String argStr; while (true) { argStr = in.nextLine(); } 留意 Java 的字符串比较的特殊之处\n3. IDE 的使用 # Question03 # (1). 编写以下程序，并运行。将运行结果截图提交。\n(2). 将断点设置在第八行，查看变量 a 的值，提交此刻的屏幕截图。\npublic class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello World!\u0026#34;); int a = 1; a=a+1; a=a+2; System.out.println(\u0026#34;a is \u0026#34; + a); a=a+3; //断点行 a=a+4; System.out.println(\u0026#34;a is \u0026#34; + a); } } 4. 基本数据类型 # Question04 # 看程序输出结果,并提交结果内容或截图\npublic class App1 { public static void main(String args[]) { // 定义整形变量a和双精度浮点变量b、c int a = 126; double b = 0.2; double c = 1.6; // 创建字符串对象 String str1 = \u0026#34;Hello World\u0026#34;; String str = new String(\u0026#34;字符串不是基本数据类型\u0026#34;); // 输出各个变量 System.out.println(\u0026#34;a=\u0026#34; + a); System.out.println(\u0026#34;b+c=\u0026#34; + (b + c)); System.out.println(\u0026#34;b+c=\u0026#34; + b + c); System.out.println(str); System.out.println(str1); System.out.println(str + str1); } } Question05 # 看程序输出结果,并提交结果内容或截图\npublic class VarDemo { public static void main(String[] args) { byte b = 0x55; boolean B = true; short s = 0x55ff; int i = 1000000; long l = 0xffffL; char c = \u0026#39;c\u0026#39;; float f = 0.23F; double d = 0.7E-3; String S = \u0026#34;This is a string\u0026#34;; System.out.println(\u0026#34;字节型变量 b = \u0026#34; + b); System.out.println(\u0026#34;短整型变量 s = \u0026#34; + s); System.out.println(\u0026#34;整型变量 i = \u0026#34; + i); System.out.println(\u0026#34;长整型变量 l = \u0026#34; + l); System.out.println(\u0026#34;字符型变量 c = \u0026#34; + c); System.out.println(\u0026#34;浮点型变量 f = \u0026#34; + f); System.out.println(\u0026#34;双精度变量 d = \u0026#34; + d); System.out.println(\u0026#34;布尔型变量 B = \u0026#34; + B); System.out.println(\u0026#34;字符串对象 S = \u0026#34; + S); } } Question06 # 运行下面这段代码，体会Integer与int的不同之处，并提供运行结果截图。\npublic class Test { static Integer a; static int b; public static void main(String[] args) { System.out.println(\u0026#34;a is \u0026#34; + a); System.out.println(\u0026#34;b is \u0026#34; + b); a = new Integer(\u0026#34;1\u0026#34;); System.out.println(\u0026#34;now a is \u0026#34; + a); Integer c = new Integer(\u0026#34;1\u0026#34;); System.out.println(a == c); System.out.println(a.compareTo(c)); // 0 is true } } Question07 # 编写一段代码验证 Java 中类的基本数据类型字段（成员变量）的默认初始化值，请按照对应类型的字面量填写。\n基本类型 默认值 基本类型 默认值 byte boolean short char int float long double 5. 短路 # Question08 # 阅读下面这段代码：\n// ShortCircuit.java public class ShortCircuit { static void print(String s) { System.out.println(s); } static boolean test1(int val) { print(\u0026#34;1\u0026#34;); return val \u0026lt; 1; } static boolean test2(int val) { print(\u0026#34;2\u0026#34;); return val \u0026lt; 2; } static boolean test3(int val) { print(\u0026#34;3\u0026#34;); return val \u0026lt; 3; } public static void main(String[] args) { boolean a = test1(0) \u0026amp;\u0026amp; test2(2) \u0026amp;\u0026amp; test3(2); boolean b = test1(1) || test2(1) || test3(1); print(\u0026#34;a is \u0026#34; + a); print(\u0026#34;b is \u0026#34; + b); } } 运行 java ShortCircuit，程序的输出是什么？\n请解释 Java 执行串联逻辑运算时的流程，可以用文字、流程图、伪代码描述。\n思考如何利用短路这个机制来优化程序。\n6. 三元运算符 # Question09 # 看程序输出结果,并提交结果内容或截图\npublic class FindMinMax{ public static void main(String []args) { double temp, max, min; double d1 = 0, d2 = -9.9, d3 = 9.9; temp = d1 \u0026gt; d2 ? d1 : d2; temp = temp \u0026gt; d3 ? temp : d3; max = temp; temp = d1 \u0026lt; d2 ? d1 : d2; temp = temp \u0026lt; d3 ? temp : d3; min = temp; System.out.println(\u0026#34;max = \u0026#34; + max); System.out.println(\u0026#34;min = \u0026#34; + min); } } 7. 局部变量 # Question10 # 看程序输出结果,并提交结果内容或截图\npublic class LocalVar { public static void main(String[] args) { LocalVar localVar = new LocalVar(); // System.out.println(\u0026#34;局部变量 a = \u0026#34; + localVar.a); 引用错误，下同 localVar.print(); // System.out.println(\u0026#34;局部变量变化后 a = \u0026#34; + localVar.a); } public void print() { int a = 10; // 局部变量，下同 double b = 20; System.out.println(\u0026#34;在print()中的局部变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); a = 30; System.out.println(\u0026#34;在print()中的局部变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); } } 8. 全局变量 # Question11 # 看程序输出结果,并提交结果内容或截图\npublic class GlobalVar { int a = 10; // 全局变量,下同 double b = 20; public static void main(String[] args) { GlobalVar globalVar = new GlobalVar(); System.out.println(\u0026#34;全局变量 a = \u0026#34; + globalVar.a); // System.out.println(\u0026#34;全局变量 a = \u0026#34; + a); 错误写法 globalVar.print(); System.out.println(\u0026#34;全局变量变化后 a = \u0026#34; + globalVar.a); } public void print() { System.out.println(\u0026#34;在print()中, 全局变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); a = 30; System.out.println(\u0026#34;在print()中, 全局变量　a = \u0026#34; + a + \u0026#34;, b = \u0026#34; + b); } } 思考程序中的错误写法，简要描述你的看法。\n"},{"id":2,"href":"/Java-HomeWork/docs/OOP-LAB/LAB02/","title":"Lab02","section":"Oop Lab","content":" Lab02: Java 语法 \u0026amp; 面向对象初步 # 1. 实验目的 # 掌握 Java 环境配置 使⽤ CMD 编译运⾏ Java 程序 使⽤ IDE 编译运⾏ Java 应⽤程序 理解 Java 语⾔中的关键字、标识符并能灵活使⽤ 理解、掌握 Java 语⾔的简单数据类型并能灵活使⽤（重点强制类型转换） 理解引⽤数据类型，理解简单数据类型和引⽤数据类型的特点 理解、掌握 Java 语⾔中的运算符并能灵活使⽤ 理解、掌握常量与变量的概念并能灵活使⽤ 理解、掌握 Java 语⾔的流程控制（重点 switch case break 语句）并能灵活使⽤ 理解、掌握 Java 语⾔的数组的声明、赋值及使⽤ 理解掌握面向对象思维方式，确定问题域，使用面向对象思维解决实际问题 2. Class 初步 # Question01 # 阅读下列 Java 源文件，并回答问题。\npublic class Person { void sayHello() { System.out.print(\u0026#34;您好，很高兴认识您\u0026#34;); System.out.println(\u0026#34;nice to meet you!\u0026#34;); } } class PersonTest { public static void main(String[] args) { Person rover = new Person(); rover.sayHello(); } } （a）上述源文件的名字是什么？\n（b）编译上述源文件将生成几个字节码文件？这些字节码文件的名字都是什么？\n（c）在命令行执行 java Person 得到怎样的错误提示？执行 java personTest 得到怎样的错误提示？执行 java PersonTest.class 得到怎样的错误提示？执行 java PersonTest 得到怎样的输出结果？\nQuestion02 # 编写程序输出自己的学号姓名，运行并截图。\n3. Unicode 编码 # Question03 # 看程序输出结果,并提交结果内容或截图\npublic class Unicode { public static void main(String[] args) { char c = \u0026#39;大\u0026#39;; System.out.println(\u0026#34;\u0026#39;\u0026#34; + c + \u0026#34;\u0026#39;的Unicode编码：\u0026#34; + (int) c); int num = 23398; System.out.println(\u0026#34;Unicode编码为\u0026#34; + num + \u0026#34;的字符是：\u0026#34; + (char) num); } } 4. 数组 # Question04 # 看程序输出结果,并提交结果内容或截图\npublic class UseIntArray { public static void main(String[] args) { int[] intArray = {8, 9, 12, 13, 14}; int sum = 0; for (int i : intArray) { sum += i; } for(int i = 0; i \u0026lt; intArray.length; i++) { System.out.println(\u0026#34;intArray[\u0026#34; + i + \u0026#34;]=\u0026#34; + intArray[i]); } System.out.println(); System.out.println(\u0026#34;sum=\u0026#34; + sum); } } Question05 # 看程序输出结果,并提交结果内容或截图\npublic class TwoDimensionArray { public static void main(String[] args) { int[][] b = {{11}, {21, 22}, {31, 32, 33}}; int sum = 0; b[0][0] = 1000; for(int[] ints : b) { for(int anInt : ints) { sum += anInt; } } System.out.println(\u0026#34;b[0][0]=\u0026#34; + b[0][0] + \u0026#39;\\n\u0026#39; + \u0026#34;sum=\u0026#34; + sum + \u0026#39;\\n\u0026#39; + \u0026#34;b.length=\u0026#34; + b.length); int[][] arr1 = new int[3][4]; int[][] arr2 = new int[3][]; int[][] arr3 = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}}; int i, j, k = 0; // arr1[][]赋值 for(i = 0; i \u0026lt; 3; i++) { // arr1为3行4列 for(j = 0; j \u0026lt; 4; j++) { arr1[i][j] = k++; } } // arr2[][]开辟内存空间 for(i = 0; i \u0026lt; 3; i++) { // arr2每一行是变长的，元素个数为3、4、5 arr2[i] = new int[i + 3]; } // arr2[][]赋值 for(i = 0; i \u0026lt; 3; i++) { for(j = 0; j \u0026lt; arr2[i].length; j++) { arr2[i][j] = k++; } } // 输出arr1 System.out.println(\u0026#34; arr1:\u0026#34;); for(i = 0; i \u0026lt; 3; i++) { for (j = 0; j \u0026lt; 4; j++) { System.out.print(\u0026#34; \u0026#34; + arr1[i][j]); } } System.out.println(); // 输出arr2 System.out.println(\u0026#34; arr2:\u0026#34;); for(i = 0; i \u0026lt; 3; i++) { for(j = 0; j \u0026lt; arr2[i].length; j++) { System.out.println(\u0026#34; \u0026#34; + arr2[i][j]); } } // 输出arr3 System.out.println(\u0026#34; arr3:\u0026#34;); for(i = 0; i \u0026lt; 3; i++) { // arr3为3行3列 for(j = 0; j \u0026lt; 3; j++) { System.out.print(\u0026#34; \u0026#34; + arr3[i][j]); } } } } 5. switch # Question06 # 阅读下面程序，给出程序的输出结果，为什么？\npublic class SwitchTest { public static void main (String[] args) { char c = \u0026#39;\\0\u0026#39;; for(int i = 1; i \u0026lt;= 4; i++) { switch(i) { case 1: c = \u0026#39;J\u0026#39;; System.out.print(c); case 2: c = \u0026#39;e\u0026#39;; System.out.print(c); break; case 3: c = \u0026#39;p\u0026#39;; System.out.print(c); default: System.out.print(\u0026#34;好\u0026#34;); } } } } 6. 循环 # Question07 # 请实现程序输出以下 5*5 数字方格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 需要在 main 函数的输入参数中设置 5，输出 5*5 的数字方格。如果是输入 7，则是 7*7 的数字方格。需要提交代码及运行结果截图。\nQuestion08 # 请实现程序输出以下星塔\n需要在 main 函数的输入参数中设置 5，输出 5 层星塔。如果是输入 7，则输出 7 层星塔。假设输入参数都是奇数，且都大于等于 5，小于等于 11，提交代码及运行结果截图。\n* *** ***** *** * Question09 # 编写静态方法 double getPi(int n)，利用公式 $$ \\pi = 4\\sum_{i=0}^{n}{\\frac{\\left(-1\\right)^{i}}{2i+1}} $$ 求 pi 的近似值，需求如下\n/** * 利用公式求指定精度的圆周率 * 如果n是负数，视其为0 * @param n 公式中的i的上限 * @return 圆周率的近似值 */ public static double getPi(int n); 题外话：\n如果 n 是负数，视其为 0\n有穷求和的区间是闭区间，上限 n 对应的级数项也是要被计算的。\nQuestion10 # 快速排序\n编写静态方法int[] qsort(int[] arr)，需求如下：\n/** * 对一个int数组进行快速排序，结果是升序的，并且不会开辟额外的数组空间 * @param arr 待排序的数组 * @return 升序排列好的arr，如果arr==null，则返回null */ public static int[] qsort(int[] arr); 约束：\n返回值必须是原数组，即 return arr。\n可以任意次创建指向原数组的引用，但是请不要在排序过程中创建新的数组。\n可以根据需要定义新的函数。\n如果数组是 null，返回 null。\n对于空数组(arr.length==0)，原样返回，而不是 null。\n这一次请不要使用 java.util.Array.sort()之类的操作。\nQuestion11 # 现有一组数据分别是：12,45,67,89,123,-45,67，实现以下两步：\n(1) 请对这组数据排序后，按照从小到大的顺序打印；\n(2) 从键盘输入任意整数，程序判断该整数是否存在该数组中；\nQuestion12 # 阅读下面代码并查看输出结果：\n增强for循环\npublic class ForPower { public static void main(String[] args) { for(char c : \u0026#34;An African Swallow\u0026#34;.toCharArray()) System.out.print(c + \u0026#34; \u0026#34;); } } 7. 引用 # Question13 # 阅读下面这段代码：\nclass Point { int x, y; void setArgs(int m, int n) { x = m; y = n; } } public class PointTest { public static void main(String[] args) { Point p1, p2; p1 = new Point(); p2 = new Point(); System.out.println(\u0026#34;p1的引用:\u0026#34; + p1); System.out.println(\u0026#34;p2的引用:\u0026#34; + p2); p1.setArgs(1111, 2222); p2.setArgs(-100, -200); System.out.println(\u0026#34;p1的x,y坐标:\u0026#34; + p1.x + \u0026#34;,\u0026#34; + p1.y); // 1 System.out.println(\u0026#34;p2的x,y坐标:\u0026#34; + p2.x + \u0026#34;,\u0026#34; + p2.y); // 2 p1 = p2; p1.setArgs(0, 0); System.out.println(\u0026#34;p1的引用:\u0026#34; + p1); System.out.println(\u0026#34;p2的引用:\u0026#34; + p2); System.out.println(\u0026#34;p1的x,y坐标:\u0026#34; + p1.x + \u0026#34;,\u0026#34; + p1.y); // 3 System.out.println(\u0026#34;p2的x,y坐标:\u0026#34; + p2.x + \u0026#34;,\u0026#34; + p2.y); // 4 } } 请指出代码中注释标注出的四行输出的内容会是什么。\n题外话：\n意在理解 Java 对象实例是作为引用存在的。\n如果你要为一个类实现 copy() 方法，思考如何避免引用间赋值导致的浅拷贝？或者说，如何确保进行的是深拷贝。你需要查一下什么是浅拷贝？什么是深拷贝？\n同样的问题也存在于 String 的 == 和 equals() 方法，对于不同的背景，相等的定义可能也不同。\nQuestion14 # 阅读下面程序，给出程序的输出结果，为什么？\npublic class ArrayTest { public static void main(String[] args) { int[] a = {1, 2, 3, 4}; int[] b = {100, 200, 300}; System.out.println(\u0026#34;数组a的元素个数=\u0026#34; + a.length); System.out.println(\u0026#34;数组b的元素个数=\u0026#34; + b.length); System.out.println(\u0026#34;数组a的引用=\u0026#34; + a); System.out.println(\u0026#34;数组b的引用=\u0026#34; + b); a = b; System.out.println(\u0026#34;数组a的元素个数=\u0026#34; + a.length); System.out.println(\u0026#34;数组b的元素个数=\u0026#34; + b.length); System.out.println(\u0026#34;a[0]=\u0026#34; + a[0] + \u0026#34;,a[1]=\u0026#34; + a[1] + \u0026#34;,a[2]=\u0026#34; + a[2]); System.out.print(\u0026#34;b[0]=\u0026#34; + b[0] + \u0026#34;,b[1]=\u0026#34; + b[1] + \u0026#34;,b[2]=\u0026#34; + b[2]); } } 8. 可变参数 # Question15 # 看程序输出结果,并提交结果内容或截图:\npublic class VarArgs { public static void main(String[] args) { f(1, 2); f(-1, -2, -3, -4); //给参数传值时，实参的个数很灵活 f(9, 7, 6); } public static void f(int... x) { //x是可变参数的代表，代表若干个int型参数 for (int i = 0; i \u0026lt; x.length; i++) { //x.length是x代表的参数的个数 System.out.println(x[i]); //x[i]是x代表的第i个参数(类似数组) } } } Question16 # 编写静态方法String strscat(String... args)，需求如下：\n/** * 将任意个字符串顺序连接，不应该改变任意一个原有参数 * @param args 字符串们 * @return args中的字符串顺序连接组成的新字符串 */ public static String strscat(String... args); 样例：\n调用方法 返回值 strscat(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;, \u0026ldquo;\u0026rdquo;, \u0026ldquo;e\u0026rdquo;) \u0026ldquo;abce\u0026rdquo; strscat(\u0026ldquo;str\u0026rdquo;) \u0026ldquo;str\u0026rdquo; 回答：\n请尝试理解 Java 可变参数的实现机制。\n调用strscat(new String[]{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;})能通过编译吗？\n如果还有静态方法String strscat(String[] args)同时存在，代码能编译通过吗？这时传入的参数是什么？又会返回什么？\n如果我们声明的是String strscat(String[] args)，strscat()这样的调用还能通过编译吗？如果能，这时传入参数和返回值的情况和String strscat(String... args)通过相同吗？\n9. 面向对象（复习并完成课堂知识点） # Question17 # 减肥。小王本来体重 70Kg，经过减肥，体重降到 45Kg，试从这个问题领域中识别对象、类、属性、行为、状态，和状态变化。尝试将你抽象出来的类用 Java 代码实现出来，并编写一个测试类，来描述上述过程。\nQuestion18 # 制作一桌丰盛的年夜饭。定义采购员类和厨师类的属性和行为，在测试类中产生采购员的对象：姑姑，妈妈和你，在测试类中产生出厨师的对象：爸爸和婶婶，协同制作年夜饭。\n"},{"id":3,"href":"/Java-HomeWork/docs/OOP-LAB/TEMPLATE/","title":"Template","section":"Oop Lab","content":" Lab XX Assignment # 班级：\n学号：\n姓名：\n提交要求（以下内容在最终提交的作业中可以删除，仅作参考） # 目录格式\n-- 班级-学号-姓名-LabXX.zip |-- answer.pdf |-- solution |-- Question1 |-- 题1的代码文件(如果需要) |-- Question2 |-- 题2的代码文件(如果需要) |-- ... "},{"id":4,"href":"/Java-HomeWork/docs/MySCS/","title":"My Scs","section":"Docs","content":" MySCS # 迭代作业，第三周开始，每次迭代作业会开放两周时间来完成 如果你对软院的云平台（scs）感到不满意？那不妨自己来完成一个简易的云平台吧~\n"},{"id":5,"href":"/Java-HomeWork/docs/Resource/","title":"Resource","section":"Docs","content":" 也许有用的资源 # Patpat 官方文档\n涛哥的 OMS， \\zht/\\zht/\\zht/\nJava8 API 文档\nJava17 API 文档\n（如果在完成作业的时候发现了有用的资源 / 写的不错的博客， 也可以联系 ZHX 加到这个页面上）\n"},{"id":6,"href":"/Java-HomeWork/docs/Resource/Java8-17%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/","title":"Java8 17语法新特性总结","section":"Resource","content":" Java8-17语法新特性总结 # 班级：202115\n学号：19377054\n姓名：周洪熙\nJava 8 # Interface # interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，interface 修改的时候，实现它的类也必须跟着改。\n为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用 default 或 static 修饰，这样就可以有方法体，实现类也不必重写此方法。\n一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。\ndefault 修饰的方法，是普通实例方法，可以用this调用，可以被子类继承、重写。\nstatic 修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用Interface调用。 我们来看一个实际的例子。\npublic interface InterfaceNew { static void sm() { System.out.println(\u0026#34;interface提供的方式实现\u0026#34;); } static void sm2() { System.out.println(\u0026#34;interface提供的方式实现\u0026#34;); } default void def() { System.out.println(\u0026#34;interface default方法\u0026#34;); } default void def2() { System.out.println(\u0026#34;interface default2方法\u0026#34;); } //须要实现类重写 void f(); } public interface InterfaceNew1 { default void def() { System.out.println(\u0026#34;InterfaceNew1 default方法\u0026#34;); } } 如果有一个类既实现了 InterfaceNew 接口又实现了 InterfaceNew1 接口，它们都有 def() ，并且 InterfaceNew 接口和 InterfaceNew1 接口没有继承关系的话，这时就必须重写 def() 。不然的话，编译的时候就会报错。\npublic class InterfaceNewImpl implements InterfaceNew , InterfaceNew1{ public static void main(String[] args) { InterfaceNewImpl interfaceNew = new InterfaceNewImpl(); interfaceNew.def(); } @Override public void def() { InterfaceNew1.super.def(); } @Override public void f() { } } Lambda 表达式 # (parameters) -\u0026gt; expression 或 (parameters) -\u0026gt;{ statements; } Example: 替代匿名内部类\nList\u0026lt;Integer\u0026gt; strings = Arrays.asList(1, 2, 3); //以前 Collections.sort(strings, new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { return o1 - o2;} }); //Lambda Collections.sort(strings, (Integer o1, Integer o2) -\u0026gt; o1 - o2); //分解开 Comparator\u0026lt;Integer\u0026gt; comperator = (Integer o1, Integer o2) -\u0026gt; o1 - o2; Collections.sort(strings, comperator); Example: 集合迭代\nvoid lamndaFor() { List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;); //传统foreach for (String s : strings) { System.out.println(s); } //Lambda foreach strings.forEach((s) -\u0026gt; System.out.println(s)); //or strings.forEach(System.out::println); //map Map\u0026lt;Integer, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.forEach((k,v) -\u0026gt; System.out.println(v)); } Example: 访问变量\nint i = 0; Collections.sort(strings, (Integer o1, Integer o2) -\u0026gt; o1 - i); lambda 表达式可以引用外部变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。\n方法的引用 # Java 8 允许使用 :: 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。\npublic class LambdaClassSuper { LambdaInterface sf(){ return null; } } public class LambdaClass extends LambdaClassSuper { public static LambdaInterface staticF() { return null; } public LambdaInterface f() { return null; } void show() { //1.调用静态函数，返回类型必须是functional-interface LambdaInterface t = LambdaClass::staticF; //2.实例方法调用 LambdaClass lambdaClass = new LambdaClass(); LambdaInterface lambdaInterface = lambdaClass::f; //3.超类上的方法调用 LambdaInterface superf = super::sf; //4. 构造方法调用 LambdaInterface tt = LambdaClassSuper::new; } } Optional # 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：\n1） 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。\n反例：public int f() { return Integer 对象 }， 如果为 null，自动解箱抛 NPE。\n2） 数据库的查询结果可能为 null。\n3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。\n4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。\n5） 对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。\n6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。\n正例：使用 JDK8 的 Optional 类来防止 NPE 问题。\n如何创建一个 Optional # /** * Common instance for {@code empty()}. 全局EMPTY对象 */ private static final Optional\u0026lt;?\u0026gt; EMPTY = new Optional\u0026lt;\u0026gt;(); /** * Optional维护的值 */ private final T value; /** * 如果value是null就返回EMPTY，否则就返回of(T) */ public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value) { return value == null ? empty() : of(value); } /** * 返回 EMPTY 对象 */ public static\u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; empty() { Optional\u0026lt;T\u0026gt; t = (Optional\u0026lt;T\u0026gt;) EMPTY; return t; } /** * 返回Optional对象 */ public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; of(T value) { return new Optional\u0026lt;\u0026gt;(value); } /** * 私有构造方法，给value赋值 */ private Optional(T value) { this.value = Objects.requireNonNull(value); } /** * 所以如果of(T value) 的value是null，会抛出NullPointerException异常，这样貌似就没处理NPE问题 */ public static \u0026lt;T\u0026gt; T requireNonNull(T obj) { if (obj == null) throw new NullPointerException(); return obj; } ofNullable 方法和 of 方法唯一区别就是当 value 为 null 时， ofNullable 返回的是EMPTY， of 会抛出 NullPointerException 异常。如果需要把 NullPointerException 暴露出来就用 of ，否则就用 ofNullable 。\nmap()相关方法 # /** * 如果value为null，返回EMPTY，否则返回Optional封装的参数值 */ public\u0026lt;U\u0026gt; Optional\u0026lt;U\u0026gt; map(Function\u0026lt;? super T, ? extends U\u0026gt; mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Optional.ofNullable(mapper.apply(value)); } } /** * 如果value为null，返回EMPTY，否则返回Optional封装的参数值，如果参数值返回null会抛 NullPointerException */ public\u0026lt;U\u0026gt; Optional\u0026lt;U\u0026gt; flatMap(Function\u0026lt;? super T, Optional\u0026lt;U\u0026gt;\u0026gt; mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Objects.requireNonNull(mapper.apply(value)); } } flatMap() 参数返回值如果是 null 会抛 NullPointerException ，而 map() 返回EMPTY。\n判断 value 是否为 null # /** * value是否为null */ public boolean isPresent() { return value != null; } /** * 如果value不为null执行consumer.accept */ public void ifPresent(Consumer\u0026lt;? super T\u0026gt; consumer) { if (value != null) consumer.accept(value); } 获取 value # /** * Return the value if present, otherwise invoke {@code other} and return * the result of that invocation. * 如果value != null 返回value，否则返回other的执行结果 */ public T orElseGet(Supplier\u0026lt;? extends T\u0026gt; other) { return value != null ? value : other.get(); } /** * 如果value != null 返回value，否则返回T */ public T orElse(T other) { return value != null ? value : other; } /** * 如果value != null 返回value，否则抛出参数返回的异常 */ public \u0026lt;X extends Throwable\u0026gt; T orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier) throws X { if (value != null) { return value; } else { throw exceptionSupplier.get(); } } /** * value为null抛出NoSuchElementException，不为空返回value。 */ public T get() { if (value == null) { throw new NoSuchElementException(\u0026#34;No value present\u0026#34;); } return value; } 过滤值 # /** * 1. 如果是empty返回empty * 2. predicate.test(value)==true 返回this，否则返回empty */ public Optional\u0026lt;T\u0026gt; filter(Predicate\u0026lt;? super T\u0026gt; predicate) { Objects.requireNonNull(predicate); if (!isPresent()) return this; else return predicate.test(value) ? this : empty(); } Date-Time API # 这是对 java.util.Date 强有力的补充，解决了 Date 类的大部分痛点：\n非线程安全 时区处理麻烦 各种格式化、和时间计算繁琐 设计有缺陷，Date 类同时包含日期和时间；还有一个 java.sql.Date，容易混淆。 我们从常用的时间实例来对比 java.util.Date 和新 Date 有什么区别。用 java.util.Date 的代码该改改了。\njava.time 主要类 # LocalDateTime.class //日期+时间 format: yyyy-MM-ddTHH:mm:ss.SSS LocalDate.class //日期 format: yyyy-MM-dd LocalTime.class //时间 format: HH:mm:ss 格式化 # public void newFormat() { //format yyyy-MM-dd LocalDate date = LocalDate.now(); System.out.println(String.format(\u0026#34;date format : %s\u0026#34;, date)); //format HH:mm:ss LocalTime time = LocalTime.now().withNano(0); System.out.println(String.format(\u0026#34;time format : %s\u0026#34;, time)); //format yyyy-MM-dd HH:mm:ss LocalDateTime dateTime = LocalDateTime.now(); DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); String dateTimeStr = dateTime.format(dateTimeFormatter); System.out.println(String.format(\u0026#34;dateTime format : %s\u0026#34;, dateTimeStr)); } 字符串转日期格式 # LocalDate date = LocalDate.of(2021, 1, 26); LocalDate.parse(\u0026#34;2021-01-26\u0026#34;); LocalDateTime dateTime = LocalDateTime.of(2021, 1, 26, 12, 12, 22); LocalDateTime.parse(\u0026#34;2021-01-26 12:12:22\u0026#34;); LocalTime time = LocalTime.of(12, 12, 22); LocalTime.parse(\u0026#34;12:12:22\u0026#34;); 日期计算 # public void pushWeek() { //一周后的日期 LocalDate localDate = LocalDate.now(); //方法1 LocalDate after = localDate.plus(1, ChronoUnit.WEEKS); //方法2 LocalDate after2 = localDate.plusWeeks(1); System.out.println(\u0026#34;一周后日期：\u0026#34; + after); //算两个日期间隔多少天，计算间隔多少年，多少月 LocalDate date1 = LocalDate.parse(\u0026#34;2021-02-26\u0026#34;); LocalDate date2 = LocalDate.parse(\u0026#34;2021-12-23\u0026#34;); Period period = Period.between(date1, date2); System.out.println(\u0026#34;date1 到 date2 相隔：\u0026#34; + period.getYears() + \u0026#34;年\u0026#34; + period.getMonths() + \u0026#34;月\u0026#34; + period.getDays() + \u0026#34;天\u0026#34;); //打印结果是 “date1 到 date2 相隔：0年9月27天” //这里period.getDays()得到的天是抛去年月以外的天数，并不是总天数 //如果要获取纯粹的总天数应该用下面的方法 long day = date2.toEpochDay() - date1.toEpochDay(); System.out.println(date2 + \u0026#34;和\u0026#34; + date2 + \u0026#34;相差\u0026#34; + day + \u0026#34;天\u0026#34;); //打印结果：2021-12-23和2021-12-23相差300天 } 获取指定日期 # public void getDayNew() { LocalDate today = LocalDate.now(); //获取当前月第一天： LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); // 取本月最后一天 LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth()); //取下一天： LocalDate nextDay = lastDayOfThisMonth.plusDays(1); //当年最后一天 LocalDate lastday = today.with(TemporalAdjusters.lastDayOfYear()); //2021年最后一个周日，如果用Calendar是不得烦死。 LocalDate lastMondayOf2021 = LocalDate.parse(\u0026#34;2021-12-31\u0026#34;).with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY)); } 时区 # //当前时区时间 ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(\u0026#34;当前时区时间: \u0026#34; + zonedDateTime); //东京时间 ZoneId zoneId = ZoneId.of(ZoneId.SHORT_IDS.get(\u0026#34;JST\u0026#34;)); ZonedDateTime tokyoTime = zonedDateTime.withZoneSameInstant(zoneId); System.out.println(\u0026#34;东京时间: \u0026#34; + tokyoTime); // ZonedDateTime 转 LocalDateTime LocalDateTime localDateTime = tokyoTime.toLocalDateTime(); System.out.println(\u0026#34;东京时间转当地时间: \u0026#34; + localDateTime); //LocalDateTime 转 ZonedDateTime ZonedDateTime localZoned = localDateTime.atZone(ZoneId.systemDefault()); System.out.println(\u0026#34;本地时区时间: \u0026#34; + localZoned); //打印结果 当前时区时间: 2021-01-27T14:43:58.735+08:00[Asia/Shanghai] 东京时间: 2021-01-27T15:43:58.735+09:00[Asia/Tokyo] 东京时间转当地时间: 2021-01-27T15:43:58.735 当地时区时间: 2021-01-27T15:53:35.618+08:00[Asia/Shanghai] Java 9 # JShell # JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。 可以在终端使用 jshell 命令进入。\n模块化系统 # 什么是模块系统？ 简单来说，你可以将一个模块看作是一组唯一命名、可重用的包、资源和模块描述文件（module-info.java）。 任意一个 jar 文件，只要加上一个模块描述文件（module-info.java），就可以升级为一个模块。\n在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlinkopen in new window 工具 (Jlink 是随 Java 9 一起发布的新命令行工具。它允许开发人员为基于模块的 Java 应用程序创建自己的轻量级、定制的 JRE)，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。\n在JDK 9中，您可以如下声明这两个模块：\nmodule policy { exports pkg1; } module claim { requires policy; } 我们可以通过 exports 关键词精准控制哪些类可以对外开放使用，哪些类只能内部使用。\nmodule my.module { //exports 公开指定包的所有公共成员 exports com.my.package.name; } module my.module { //exports…to 限制访问的成员范围 export com.my.package.name to com.specific.package; } 具体地，参考： Java 9 揭秘（2. 模块化系统）\n快速创建不可变集合 # List.of(\u0026#34;Java\u0026#34;, \u0026#34;C++\u0026#34;); Set.of(\u0026#34;Java\u0026#34;, \u0026#34;C++\u0026#34;); Map.of(\u0026#34;Java\u0026#34;, 1, \u0026#34;C++\u0026#34;, 2); 接口私有方法 # public interface MyInterface { private void methodPrivate(){ } } try-with-resources 增强 # 在 Java 9 之前，我们只能在 try-with-resources 块中声明变量：\ntry (Scanner scanner = new Scanner(new File(\u0026#34;testRead.txt\u0026#34;)); PrintWriter writer = new PrintWriter(new File(\u0026#34;testWrite.txt\u0026#34;))) { // omitted } 在 Java 9 之后，在 try-with-resources 语句中可以使用 effectively-final 变量。\nfinal Scanner scanner = new Scanner(new File(\u0026#34;testRead.txt\u0026#34;)); PrintWriter writer = new PrintWriter(new File(\u0026#34;testWrite.txt\u0026#34;)) try (scanner;writer) { // omitted } 什么是 effectively-final 变量？ 简单来说就是没有被 final 修饰但是值在初始化后从未更改的变量。\n正如上面的代码所演示的那样，即使 writer 变量没有被显示声明为 final ，但它在第一次被赋值后就不会改变了，因此，它就是 effectively-final 变量。\nStream \u0026amp; Optional 增强 # // Stream // ofNullable() Stream\u0026lt;String\u0026gt; stringStream = Stream.ofNullable(\u0026#34;Java\u0026#34;); System.out.println(stringStream.count());// 1 Stream\u0026lt;String\u0026gt; nullStream = Stream.ofNullable(null); System.out.println(nullStream.count());//0 // takeWhile() List\u0026lt;Integer\u0026gt; integerList = List.of(11, 33, 66, 8, 9, 13); integerList.stream().takeWhile(x -\u0026gt; x \u0026lt; 50).forEach(System.out::println);// 11 33 // dropWhile() List\u0026lt;Integer\u0026gt; integerList2 = List.of(11, 33, 66, 8, 9, 13); integerList2.stream().dropWhile(x -\u0026gt; x \u0026lt; 50).forEach(System.out::println);// 66 8 9 13 // iterate() public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; iterate(final T seed, final UnaryOperator\u0026lt;T\u0026gt; f) { } // 新增加的重载方法 public static\u0026lt;T\u0026gt; Stream\u0026lt;T\u0026gt; iterate(T seed, Predicate\u0026lt;? super T\u0026gt; hasNext, UnaryOperator\u0026lt;T\u0026gt; next) { } // 使用原始 iterate() 方法输出数字 1~10 Stream.iterate(1, i -\u0026gt; i + 1).limit(10).forEach(System.out::println); // 使用新的 iterate() 重载方法输出数字 1~10 Stream.iterate(1, i -\u0026gt; i \u0026lt;= 10, i -\u0026gt; i + 1).forEach(System.out::println); // Optional // ifPresentOrElse() public void ifPresentOrElse(Consumer\u0026lt;? super T\u0026gt; action, Runnable emptyAction) Optional\u0026lt;Object\u0026gt; objectOptional = Optional.empty(); objectOptional.ifPresentOrElse(System.out::println, () -\u0026gt; System.out.println(\u0026#34;Empty!!!\u0026#34;));// Empty!!! // or() public Optional\u0026lt;T\u0026gt; or(Supplier\u0026lt;? extends Optional\u0026lt;? extends T\u0026gt;\u0026gt; supplier) Optional\u0026lt;Object\u0026gt; objectOptional = Optional.empty(); objectOptional.or(() -\u0026gt; Optional.of(\u0026#34;java\u0026#34;)).ifPresent(System.out::println);//java 进程 API # // java.lang.ProcessHandle // 获取当前正在运行的 JVM 的进程 ProcessHandle currentProcess = ProcessHandle.current(); // 输出进程的 id System.out.println(currentProcess.pid()); // 输出进程的信息 System.out.println(currentProcess.info()); Java 10 # 局部变量类型推断(var) # var id = 0; var codefx = new URL(\u0026#34;https://mp.weixin.qq.com/\u0026#34;); var list = new ArrayList\u0026lt;\u0026gt;(); var list = List.of(1, 2, 3); var map = new HashMap\u0026lt;String, String\u0026gt;(); var p = Paths.of(\u0026#34;src/test/java/Java9FeaturesTest.java\u0026#34;); var numbers = List.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); for (var n : list) System.out.print(n+ \u0026#34; \u0026#34;); var count=null; //❌编译不通过，不能声明为 null var r = () -\u0026gt; Math.random();//❌编译不通过,不能声明为 Lambda表达式 var array = {1,2,3};//❌编译不通过,不能声明数组 var 并不会改变 Java 是一门静态类型语言的事实，编译器负责推断出类型。\n集合增强 # // List，Set，Map 提供了静态方法copyOf()返回入参集合的一个不可变拷贝 static \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; copyOf(Collection\u0026lt;? extends E\u0026gt; coll) { return ImmutableCollections.listCopy(coll); } // java.util.stream.Collectors 中新增了静态方法，用于将流中的元素收集为不可变的集合 var list = new ArrayList\u0026lt;\u0026gt;(); list.stream().collect(Collectors.toUnmodifiableList()); list.stream().collect(Collectors.toUnmodifiableSet()); Optional 增强 # // Optional 新增了orElseThrow()方法来在没有值时抛出指定的异常 Optional.ofNullable(cache.getIfPresent(key)) .orElseThrow(() -\u0026gt; new PrestoException(NOT_FOUND, \u0026#34;Missing entry found for key: \u0026#34; + key)); Java 11 # HTTP Client 标准化 # 这里建议使用第三方库 com.squareup.okhttp3 ，这里就不再过多介绍原生API。\nString 增强 # //判断字符串是否为空 \u0026#34; \u0026#34;.isBlank();//true //去除字符串首尾空格 \u0026#34; Java \u0026#34;.strip();// \u0026#34;Java\u0026#34; //去除字符串首部空格 \u0026#34; Java \u0026#34;.stripLeading(); // \u0026#34;Java \u0026#34; //去除字符串尾部空格 \u0026#34; Java \u0026#34;.stripTrailing(); // \u0026#34; Java\u0026#34; //重复字符串多少次 \u0026#34;Java\u0026#34;.repeat(3); // \u0026#34;JavaJavaJava\u0026#34; //返回由行终止符分隔的字符串集合。 \u0026#34;A\\nB\\nC\u0026#34;.lines().count(); // 3 \u0026#34;A\\nB\\nC\u0026#34;.lines().collect(Collectors.toList()); Optional 增强 # // 新增了empty()方法来判断指定的 Optional 对象是否为空 var op = Optional.empty(); System.out.println(op.isEmpty());//判断指定的 Optional 对象是否为空 Lambda 参数的局部变量语法 # // Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明 // 下面两者是等价的 Consumer\u0026lt;String\u0026gt; consumer = (var i) -\u0026gt; System.out.println(i); Consumer\u0026lt;String\u0026gt; consumer = (String i) -\u0026gt; System.out.println(i); Java 12 # String 增强 # // indent() 方法可以实现字符串缩进 String text = \u0026#34;Java\u0026#34;; // 缩进 4 格 text = text.indent(4); System.out.println(text); text = text.indent(-10); System.out.println(text); // output Java Java // transform() 方法可以用来转变指定字符串 String result = \u0026#34;foo\u0026#34;.transform(input -\u0026gt; input + \u0026#34; bar\u0026#34;); System.out.println(result); // foo bar Files 增强（文件比较） # // mismatch() 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L Path filePath1 = Files.createTempFile(\u0026#34;file1\u0026#34;, \u0026#34;.txt\u0026#34;); Path filePath2 = Files.createTempFile(\u0026#34;file2\u0026#34;, \u0026#34;.txt\u0026#34;); Files.writeString(filePath1, \u0026#34;Java 12 Article\u0026#34;); Files.writeString(filePath2, \u0026#34;Java 12 Article\u0026#34;); long mismatch = Files.mismatch(filePath1, filePath2); assertEquals(-1, mismatch); // 不相同 Path filePath3 = Files.createTempFile(\u0026#34;file3\u0026#34;, \u0026#34;.txt\u0026#34;); Path filePath4 = Files.createTempFile(\u0026#34;file4\u0026#34;, \u0026#34;.txt\u0026#34;); Files.writeString(filePath3, \u0026#34;Java 12 Article\u0026#34;); Files.writeString(filePath4, \u0026#34;Java 12 Tutorial\u0026#34;); long mismatch = Files.mismatch(filePath3, filePath4); assertEquals(8, mismatch); 数字格式化工具类 # // NumberFormat 新增了对复杂的数字进行格式化的支持 NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT); String result = fmt.format(1000); System.out.println(result); // output 1K Java 13 # SocketAPI 重构 # Java 13 将 Socket API 的底层进行了重写， NioSocketImpl 是对 PlainSocketImpl 的直接替代，它使用 java.util.concurrent 包下的锁而不是同步方法。如果要使用旧实现，请使用 -Djdk.net.usePlainSocketImpl=true 。\n并且，在 Java 13 中是默认使用新的 Socket 实现。\npublic final class NioSocketImpl extends SocketImpl implements PlatformSocketImpl { } FileSystems # FileSystems 类中添加了以下三种新方法，以便更容易地使用将文件内容视为文件系统的文件系统提供程序：\nnewFileSystem(Path) newFileSystem(Path, Map\u0026lt;String, ?\u0026gt;) newFileSystem(Path, Map\u0026lt;String, ?\u0026gt;, ClassLoader) Java 14 # 空指针异常精准提示 # 通过 JVM 参数中添加 -XX:+ShowCodeDetailsInExceptionMessages ，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。\na.b.c.i = 99; // 假设这段代码会发生空指针 // 增加参数后提示的异常中很明确的告知了哪里为空导致 Exception in thread \u0026#34;main\u0026#34; java.lang.NullPointerException: Cannot read field \u0026#39;c\u0026#39; because \u0026#39;a.b\u0026#39; is null. at Prog.main(Prog.java:5) switch 的增强 # // 传统的 switch 语法存在容易漏写 break 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复 // Java12 增强了 swtich 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break switch (day) { case MONDAY, FRIDAY, SUNDAY -\u0026gt; System.out.println(6); case TUESDAY -\u0026gt; System.out.println(7); case THURSDAY, SATURDAY -\u0026gt; System.out.println(8); case WEDNESDAY -\u0026gt; System.out.println(9); } // Java 13 中 Switch 表达式中多了一个关键字用于跳出 Switch 块的关键字 yield，主要用于返回一个值 // yield和 return 的区别在于：return 会直接跳出当前循环或者方法，而 yield 只会跳出当前 Switch 块，同时在使用 yield 时，需要有 default 条件 // ex1 String result = switch (day) { case \u0026#34;M\u0026#34;, \u0026#34;W\u0026#34;, \u0026#34;F\u0026#34; -\u0026gt; \u0026#34;MWF\u0026#34;; case \u0026#34;T\u0026#34;, \u0026#34;TH\u0026#34;, \u0026#34;S\u0026#34; -\u0026gt; \u0026#34;TTS\u0026#34;; default -\u0026gt; { if (day.isEmpty()) yield \u0026#34;Please insert a valid day.\u0026#34;; else yield \u0026#34;Looks like a Sunday.\u0026#34;; } }; System.out.println(result); // ex2 private static String descLanguage(String name) { return switch (name) { case \u0026#34;Java\u0026#34;: yield \u0026#34;object-oriented, platform independent and secured\u0026#34;; case \u0026#34;Ruby\u0026#34;: yield \u0026#34;a programmer\u0026#39;s best friend\u0026#34;; default: yield name +\u0026#34; is a good language\u0026#34;; }; } Java 15 # CharSequence # // CharSequence 接口添加了一个默认方法 isEmpty() 来判断字符序列为空，如果是则返回 true public interface CharSequence { default boolean isEmpty() { return this.length() == 0; } } TreeMap # TreeMap 新引入了下面这些方法：\nputIfAbsent() computeIfAbsent() computeIfPresent() compute() merge() EdDSA(数字签名算法) # // 新加入了一个安全性和性能都更强的基于 Edwards-Curve Digital Signature Algorithm （EdDSA）实现的数字签名算法。 // 虽然其性能优于现有的 ECDSA 实现，不过，它并不会完全取代 JDK 中现有的椭圆曲线数字签名算法( ECDSA)。 KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;Ed25519\u0026#34;); KeyPair kp = kpg.generateKeyPair(); byte[] msg = \u0026#34;test_string\u0026#34;.getBytes(StandardCharsets.UTF_8); Signature sig = Signature.getInstance(\u0026#34;Ed25519\u0026#34;); sig.initSign(kp.getPrivate()); sig.update(msg); byte[] s = sig.sign(); String encodedString = Base64.getEncoder().encodeToString(s); System.out.println(encodedString); 文本块 # 解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入三重双引号来定义多行文本。 Java 13 支持两个 \u0026quot;\u0026quot;\u0026quot; 符号中间的任何内容都会被解释为字符串的一部分，包括换行符。\nString json = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;name\u0026#34;:\u0026#34;mkyong\u0026#34;, \u0026#34;age\u0026#34;:38 } \u0026#34;\u0026#34;\u0026#34;; String query = \u0026#34;\u0026#34;\u0026#34; SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB` WHERE `CITY` = \u0026#39;INDIANAPOLIS\u0026#39; ORDER BY `EMP_ID`, `LAST_NAME`; \u0026#34;\u0026#34;\u0026#34;; 另外， String 类新增加了 3 个新的方法来操作文本块：\nformatted(Object... args) ：它类似于 String 的 format() 方法。添加它是为了支持文本块的格式设置。 stripIndent() ：用于去除文本块中每一行开头和结尾的空格。 translateEscapes() ：转义序列如 “\\t” 转换为 “\\t” Java 14 中，为其引入了两个新的转义字符：\n\\ : 表示行尾，不引入换行符 \\s ：表示单个空格 String str = \u0026#34;凡心所向，素履所往，生如逆旅，一苇以航。\u0026#34;; String str2 = \u0026#34;\u0026#34;\u0026#34; 凡心所向，素履所往， \\ 生如逆旅，一苇以航。\u0026#34;\u0026#34;\u0026#34;; System.out.println(str2);// 凡心所向，素履所往， 生如逆旅，一苇以航。 String text = \u0026#34;\u0026#34;\u0026#34; java c++\\sphp \u0026#34;\u0026#34;\u0026#34;; System.out.println(text); // 输出： java c++ php Java 16 # 记录类型 # Java 14 引入 record 关键字， record 提供一种紧凑的语法来定义类中的不可变数据。\nrecord 关键字可以简化数据类（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 record 代替 class 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 toString() ， hashCode()， equals() 方法。\n类似于使用 class 定义类，同时使用了 lombok 插件，并打上了 @Getter , @ToString ， @EqualsAndHashCode 注解\n/** * 这个类具有两个特征 * 1. 所有成员属性都是final * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个） * 那么这种类就很适合使用record来声明 */ final class Rectangle implements Shape { final double length; final double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } double length() { return length; } double width() { return width; } } /** * 1. 使用record声明的类会自动拥有上面类中的三个方法 * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法 * 3. toString方法中包括所有成员属性的字符串表示形式及其名称 */ record Rectangle(float length, float width) { } Java 15 支持在局部方法和接口中使用 record 。\nJava 16 中非静态内部类可以定义非常量的静态成员。\npublic class Outer { class Inner { static int age; } } instanceof 模式匹配 # Java 12 首次引入 instanceof 模式匹配。\nJava 13, 14, 15 相比较上个版本无变化，继续收集更多反馈。\nJava 16 模式变量不再隐式为 final。\n新版的 instanceof 可以在判断是否属于具体的类型同时完成转换。\nObject obj = \u0026#34;我是字符串\u0026#34;; if(obj instanceof String str){ System.out.println(str); } // 从 Java SE 16 开始，你可以对 instanceof 中的变量值进行修改。 public void learn(Object obj) { if (obj instanceof String s) { System.out.println(s); s = \u0026#34;JavaGuide\u0026#34;; System.out.println(s); } } Java 17 # 密封类 # 密封类可以对继承或者实现它们的类进行限制。\n比如抽象类 Person 只允许 Employee 和 Manager 继承。\npublic abstract sealed class Person permits Employee, Manager { //... } 另外，任何扩展密封类的类本身都必须声明为 sealed 、 non-sealed 或 final 。\npublic final class Employee extends Person { } public non-sealed class Manager extends Person { } 如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。\n在 JDK 15 引入的 sealed class（密封类）在 JDK 16 得到了改进：更加严格的引用检查和密封类的继承关系。\nStream.toList() # 如果需要将 Stream 转换成 List ,需要通过调用 collect 方法使用 Collectors.toList() ，代码非常冗长。\n在Java 17中将会变得简单，可以直接调用 toList() 。\nprivate static void streamToList() { Stream\u0026lt;String\u0026gt; stringStream = Stream.of(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); List\u0026lt;String\u0026gt; stringList = stringStream.toList(); for(String s : stringList) { System.out.println(s); } } "}]