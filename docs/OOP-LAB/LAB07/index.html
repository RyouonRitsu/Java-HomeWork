<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java 程序设计 LAB07 # 实验目的 # 简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类 实验题目 # 本实验假设你明白：
涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。 本次实验不会涉及以下内部类的常用技巧：
回调与闭包 事件与控制框架 也不会涉及以下内部类的边角情况：
内部类的继承与覆盖 多重嵌套的内部类 Question01 InnerClass1 代码填空 # 阅读下面这段代码：
class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(/*???*/); System.out.println(/*???*/); System.out.println(/*???*/); } } } public class Test { public static void main(String[] args) { Outer."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Java 程序设计 LAB07 # 实验目的 # 简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类 实验题目 # 本实验假设你明白：
涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。 本次实验不会涉及以下内部类的常用技巧：
回调与闭包 事件与控制框架 也不会涉及以下内部类的边角情况：
内部类的继承与覆盖 多重嵌套的内部类 Question01 InnerClass1 代码填空 # 阅读下面这段代码：
class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(/*???*/); System.out.println(/*???*/); System.out.println(/*???*/); } } } public class Test { public static void main(String[] args) { Outer."><meta property="og:type" content="article"><meta property="og:url" content="https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB07/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-10-27T19:06:19+08:00"><title>Lab07 | 面向对象的程序设计</title><link rel=manifest href=/Java-HomeWork/manifest.json><link rel=icon href=/Java-HomeWork/favicon.png type=image/x-icon><link rel=stylesheet href=/Java-HomeWork/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/Java-HomeWork/flexsearch.min.js></script>
<script defer src=/Java-HomeWork/en.search.min.79bbde9831b2443d98e0702d69f4fb49af3520dd4eb4555151b4cd810ec3b0d9.js integrity="sha256-ebvemDGyRD2Y4HAtafT7Sa81IN1OtFVRUbTNgQ7DsNk=" crossorigin=anonymous></script>
<script defer src=/Java-HomeWork/sw.min.f9d6a999699a3b48a5eb200be51ffe46d9f4e077c31bf4122a23051ca7b6bc92.js integrity="sha256-+dapmWmaO0il6yAL5R/+Rtn04HfDG/QSKiMFHKe2vJI=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/Java-HomeWork/><span>面向对象的程序设计</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/Java-HomeWork/docs/OOP-LAB/>Oop Lab</a><ul><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB01/>Lab01</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB02/>Lab02</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB03/>Lab03</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB04/>Lab04</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB05/>Lab05</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB06/>Lab06</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/LAB07/ class=active>Lab07</a></li><li><a href=/Java-HomeWork/docs/OOP-LAB/TEMPLATE/>Template</a></li></ul></li><li><a href=/Java-HomeWork/docs/MySCS/>My Scs</a><ul><li><a href=/Java-HomeWork/docs/MySCS/MySCS-1/>My Scs 1</a></li><li><a href=/Java-HomeWork/docs/MySCS/MySCS-2/>My Scs 2</a></li><li><a href=/Java-HomeWork/docs/MySCS/MySCS-3/>My Scs 3</a></li></ul></li><li><a href=/Java-HomeWork/docs/Q-A/>Q & A</a><ul><li><a href=/Java-HomeWork/docs/Q-A/%E7%AC%AC%E4%B8%80%E6%9C%9F/>第一期</a></li></ul></li><li><a href=/Java-HomeWork/docs/Resource/>Resource</a><ul><li><a href=/Java-HomeWork/docs/Resource/Java8-17%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/>Java8 17语法新特性总结</a></li></ul></li></ul><ul><li><a href=https://github.com/RyouonRitsu/Java-HomeWork target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/Java-HomeWork/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Lab07</strong>
<label for=toc-control><img src=/Java-HomeWork/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#java-程序设计-lab07>Java 程序设计 LAB07</a><ul><li><a href=#实验目的>实验目的</a></li><li><a href=#实验题目>实验题目</a><ul><li><a href=#question01-innerclass1-代码填空>Question01 InnerClass1 <code>代码填空</code></a></li><li><a href=#question02-innerclass2-代码填空>Question02 InnerClass2 <code>代码填空</code></a></li><li><a href=#question03-匿名类的-shapefactory-编程题旧题>Question03 匿名类的 ShapeFactory <code>编程题|旧题</code></a><ul><li><a href=#题外话>题外话</a></li></ul></li><li><a href=#question04-shapesequence-编程题>Question04 ShapeSequence <code>编程题</code></a><ul><li><a href=#注意>注意</a></li><li><a href=#题外话-1>题外话</a></li></ul></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=java-程序设计-lab07>Java 程序设计 LAB07
<a class=anchor href=#java-%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1-lab07>#</a></h1><h2 id=实验目的>实验目的
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84>#</a></h2><ul><li>简单了解 Object 类</li><li>掌握良好重写 Object 类中方法的能力</li><li>简单了解内部类、匿名类</li></ul><h2 id=实验题目>实验题目
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e9%a2%98%e7%9b%ae>#</a></h2><blockquote><p>本实验假设你明白：</p><ul><li>涉及内部类时的初始化过程</li><li>内部类能够访问其外部类的所有属性和方法</li><li>构造内部类必须先构造外部类对象</li><li>嵌套类（静态内部类）只能够访问外部类的静态属性和方法</li><li>嵌套类可以直接通过类名构造</li><li>匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数）
上述这些语法层面的东西，可以尝试自行证明。</li></ul></blockquote><blockquote><p>本次实验不会涉及以下内部类的常用技巧：</p><ul><li>回调与闭包</li><li>事件与控制框架</li></ul><p>也不会涉及以下内部类的边角情况：</p><ul><li>内部类的继承与覆盖</li><li>多重嵌套的内部类</li></ul></blockquote><h3 id=question01-innerclass1-代码填空>Question01 InnerClass1 <code>代码填空</code>
<a class=anchor href=#question01-innerclass1-%e4%bb%a3%e7%a0%81%e5%a1%ab%e7%a9%ba>#</a></h3><p>阅读下面这段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 10<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Inner</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 20<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> num <span style=color:#f92672>=</span> 30<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#75715e>/*???*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#75715e>/*???*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#75715e>/*???*/</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Outer<span style=color:#f92672>.</span><span style=color:#a6e22e>Inner</span> oi <span style=color:#f92672>=</span> <span style=color:#75715e>/*???*/</span><span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        oi<span style=color:#f92672>.</span><span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>在 <code>Code/Question01/Test.java</code> 中的注释部分填代码，使程序先后输出 30、20、10。</li><li>注意：<ul><li>不允许修改已经有的代码。</li><li>考察的是内部类的构造以及访问外部类的方法，请<strong>不要用加减运算</strong>这种操作。</li></ul></li></ul><h3 id=question02-innerclass2-代码填空>Question02 InnerClass2 <code>代码填空</code>
<a class=anchor href=#question02-innerclass2-%e4%bb%a3%e7%a0%81%e5%a1%ab%e7%a9%ba>#</a></h3><p>阅读下面这段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Inter</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Outer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*???*/</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Outer<span style=color:#f92672>.</span><span style=color:#a6e22e>method</span><span style=color:#f92672>().</span><span style=color:#a6e22e>show</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><ul><li>在 <code>Code/Question02/Test.java</code> 中的注释部分填代码，使程序输出"DuluDulu"。</li><li>注意：<ul><li>不允许修改已经有的代码。</li><li>考察的是匿名类，但是用内部类也可以实现</li></ul></li></ul><h3 id=question03-匿名类的-shapefactory-编程题旧题>Question03 匿名类的 ShapeFactory <code>编程题|旧题</code>
<a class=anchor href=#question03-%e5%8c%bf%e5%90%8d%e7%b1%bb%e7%9a%84-shapefactory-%e7%bc%96%e7%a8%8b%e9%a2%98%e6%97%a7%e9%a2%98>#</a></h3><p>在前面实验的 <code>Shape</code> 的基础上，定义一个满足如下需求的 <code>IShapeFactory</code> 接口：</p><ul><li>具有方法 <code>Shape makeShape(double a, double b)</code> ，返回一个由 a 和 b 指定大小的 形状；<ul><li>参数不合法时，返回 null 或抛出异常</li></ul></li></ul><p>用单例模式+工厂方法模式的思想修改矩形、椭圆、菱形类：</p><ul><li>每一个类都增设一个 <code>private static IShapeFactory factory</code> 字段<ul><li>类中的 factory 用于生成该类的形状对象<ul><li>比如 Rectangle 类中的 factory，其 makeShape 方法返回 Rectangle 对象</li></ul></li><li>直接使用匿名类为 factory 进行静态初始化，不允许像 ShapeFactory2 那样定义工厂类</li></ul></li><li>进行其他的修改，使外界的其他类能够获取到 factory 并成功构造形状对象</li></ul><p>选择你认为合适的方式编写测试类，：</p><ul><li>你的测试类应该能够覆盖到所有等价类。</li><li>测试形式可以是单元测试，被测对象的形式可以参考之前实验中的 <code>ShapeFactoriesTest.makeShape</code> 方法。</li><li>在代码注释中（或者与代码一起提交一个 readme），描述你的测试计划</li></ul><h4 id=题外话>题外话
<a class=anchor href=#%e9%a2%98%e5%a4%96%e8%af%9d>#</a></h4><p>使用匿名类，依然是为每一个形状创建了一个对应的工厂，因此本质上依然是工厂方法模式，区别在于不用显式定义新的类（据说编码过程中，起名字是最麻烦的事情）。
工厂方法模式的应用中，每一种工厂通常只有一个实例，因此它经常和单例模式一起被使用。</p><h3 id=question04-shapesequence-编程题>Question04 ShapeSequence <code>编程题</code>
<a class=anchor href=#question04-shapesequence-%e7%bc%96%e7%a8%8b%e9%a2%98>#</a></h3><blockquote><p>这是一个主动要求大家造轮子的题，因此不允许继承或组合任何 java 自带的容器（除了数组）。
本题假设大家在算法上机时能够较为熟练的使用 C++中 STL 容器，并至少对变长容器的迭代访问有一定了解。</p></blockquote><p>定义一个迭代器接口<code>IIterator</code>具有下述抽象方法：</p><ul><li><code>boolean isEnd()</code></li><li><code>Shape current()</code></li><li><code>void moveNext()</code></li><li><code>boolean equals(Object o)</code></li></ul><p>在 Shape 的基础上，定义一个满足如下需求的 <code>ShapeSequence</code> 类：</p><ul><li>具有属性 <code>private Shape[] shapes</code></li><li>构造方法 <code>ShapeSequence(int size)</code><ul><li>size 用于指定 shapes 的最大长度，如果 size 是负数，那么按照 0 来处理。</li><li>构造方法中应当对 shapes 进行初始化赋值，在其他过程中 shapes 的大小不
应该被改变</li></ul></li><li>方法 <code>public void add(Shape shape)</code><ul><li>向 shapes 中添加一个新的元素</li><li>当 shapes 被填满时，什么都不做</li></ul></li><li>方法 <code>public String toString()</code><ul><li>返回这个容器的字符串表达，格式为 <code>[Type, Type,...]</code></li><li>格式中的 Type 是形状类型的全小写英文单词，比如 <code>rectangle、ellipse</code></li></ul></li><li>方法 <code>public IIterator iterator() {return new SequenceIterator();}</code></li><li>具有内部类 <code>private class SequenceIterator implements IIterator</code>，它用于序列遍历的迭代器<ul><li>自定义必要的属性。</li><li>默认构造方法，在被构造时，迭代器指向的位置代表数组下标 0</li><li>方法 <code>public boolean isEnd()</code>，迭代器完成遍历时，返回 true<ul><li>完成遍历不代表迭代器指向了最后一个元素，而是指向了最后一个元素的下一个位置</li></ul></li><li>方法 <code>public Shape current()</code>，返回当前迭代器指向位置的 Shape 对象<ul><li>isEnd()是 true 时，访问 current 是非法操作</li></ul></li><li>方法 <code>public void moveNext()</code>，使迭代器移动到下一个元素的位置<ul><li>isEnd()是 true 时，什么都不做</li></ul></li><li>方法 <code>public boolean equals(Object o)</code>，当 o 是 <code>SequenceItetator</code> 类型的、且
o 和 this 的外部类对象相同、且 o 和 this 的位置相同时，返回 true</li></ul></li></ul><p>编写测试类并描述你的测试计划</p><h4 id=注意>注意
<a class=anchor href=#%e6%b3%a8%e6%84%8f>#</a></h4><p><strong>toString 和 equals 是 override 继承自 Object 的方法，尽量避免出现诸如 ToString、 equals 的参数类型不是 Object（这种情况会算作 overload）等情况</strong></p><p>题目中省略了一些实现上必要但是方式不唯一的属性：比如你可以在 <code>ShapeSequence</code> 类中声明一个 int 属性来表示当前容器被填充到了什么位置；给 <code>SequenceIterator</code> 一个 int 属性表示当前迭代器指向的位置，当使用 <code>isEnd</code> 时，判断迭代器位置和外部类容器的填充位置进行比较。</p><h4 id=题外话-1>题外话
<a class=anchor href=#%e9%a2%98%e5%a4%96%e8%af%9d-1>#</a></h4><ul><li>在实现本题的 <code>toString</code> 时，推荐使用 <code>StringBuilder</code>或<code>StringJoiner</code>。</li><li>你可以考虑一下不使用内部类时要如何实现迭代器，内部类为这种数据访问是否带来了足够的便利？</li><li>为什么 <code>SequenceIterator</code> 被限定为了 private</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/8cde68be044c7fbc06928a246c1647945c494d34 title='Last modified by 橙原 凯 | October 27, 2022' target=_blank rel=noopener><img src=/Java-HomeWork/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 27, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/OOP-LAB/LAB07.md target=_blank rel=noopener><img src=/Java-HomeWork/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#java-程序设计-lab07>Java 程序设计 LAB07</a><ul><li><a href=#实验目的>实验目的</a></li><li><a href=#实验题目>实验题目</a><ul><li><a href=#question01-innerclass1-代码填空>Question01 InnerClass1 <code>代码填空</code></a></li><li><a href=#question02-innerclass2-代码填空>Question02 InnerClass2 <code>代码填空</code></a></li><li><a href=#question03-匿名类的-shapefactory-编程题旧题>Question03 匿名类的 ShapeFactory <code>编程题|旧题</code></a><ul><li><a href=#题外话>题外话</a></li></ul></li><li><a href=#question04-shapesequence-编程题>Question04 ShapeSequence <code>编程题</code></a><ul><li><a href=#注意>注意</a></li><li><a href=#题外话-1>题外话</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>