<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java 实验规划 on 面向对象的程序设计</title><link>https://ryouonritsu.github.io/Java-HomeWork/</link><description>Recent content in Java 实验规划 on 面向对象的程序设计</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ryouonritsu.github.io/Java-HomeWork/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB01/</guid><description>Lab01: 认识 Java # 1. 实验目的 # 掌握 Java 环境配置 使用 CMD 编译运行 Java 程序 使用 IDE 编译运行 Java 应用程序 理解 Java 语言中的关键字、标识符并能灵活使用 理解、掌握 Java 语言的简单数据类型并能灵活使用（重点强制类型转换） 理解引用数据类型，理解简单数据类型和引用数据类型的特点 理解、掌握 Java 语言中的运算符并能灵活使用 理解、掌握常量与变量的概念并能灵活使用 2. 编译与运行 # Question01 # 借助身边的工具，学习 java， javac 等命令的使用，并尝试通过命令行来编译并运行一个 Java 程序，输出 Hello, World!，提交你所使用的命令和运行结果截图。
Question02 # 相信这一定难不倒聪明的你，接下来我们略微增加一点点难度 ~ 你需要输出很多 Hello, World!
本题需要你实现一个 Test 类：
程序开始运行，进入main方法，并输出你的学号和姓名
当终端输入 QUIT 时，系统退出，并在终端打印一行字符：
----- Good Bye! ----- 对于其他的输入，在终端中输出一行 Hello, World!，等待下一行输入 你需要提交运行时的截图。
程序退出 # 和 C 语言的return 0类似，Java 程序也有其退出码，整个程序的正常的退出码应该为 0，而不应该为-1、1 等。</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB02/</guid><description>Lab02: Java 语法 &amp;amp; 面向对象初步 # 1. 实验目的 # 掌握 Java 环境配置 使⽤ CMD 编译运⾏ Java 程序 使⽤ IDE 编译运⾏ Java 应⽤程序 理解 Java 语⾔中的关键字、标识符并能灵活使⽤ 理解、掌握 Java 语⾔的简单数据类型并能灵活使⽤（重点强制类型转换） 理解引⽤数据类型，理解简单数据类型和引⽤数据类型的特点 理解、掌握 Java 语⾔中的运算符并能灵活使⽤ 理解、掌握常量与变量的概念并能灵活使⽤ 理解、掌握 Java 语⾔的流程控制（重点 switch case break 语句）并能灵活使⽤ 理解、掌握 Java 语⾔的数组的声明、赋值及使⽤ 理解掌握面向对象思维方式，确定问题域，使用面向对象思维解决实际问题 2. Class 初步 # Question01 # 阅读下列 Java 源文件，并回答问题。
public class Person { void sayHello() { System.out.print(&amp;#34;您好，很高兴认识您&amp;#34;); System.out.println(&amp;#34;nice to meet you!&amp;#34;); } } class PersonTest { public static void main(String[] args) { Person rover = new Person(); rover.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB03/</guid><description>Java 程序设计 Lab03 # 实验目的 # 理解并掌握类的概念 理解并掌握对象的概念 理解类与对象的关系 理解面向对象中抽象过程 理解面向对象中的消息 理解 Java 程序的基本结构并能灵活使用 理解并掌握 Java 类的定义（成员变量、成员方法和方法重载） 理解并掌握 Java 类的构造函数（默认构造函数、带参数构造函数），理解重 载的构造函数并灵活使用 理解 Java 垃圾内存自动回收机制 理解并掌握 Java 类变量和类方法 实验题目 # Question1: 简答题 # 编译下面这个类：
public class Sample { int x; // 1 long y = x; // 2 public void f(int n) { int m; // 3 int t = n + m; // 4 } public static void main(String[] args) { Sample t=new Sample(); t.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB04/</guid><description>Java 程序设计 LAB04 # 实验目的 # 理解封装含义 理解信息隐藏的必要性 掌握访问控制修饰符的使用 私有成员（变量和方法）的理解和使用 共有成员的理解和使用 保护成员的理解和使用 使用不加任何权限修饰符的成员 加深对“类和对象”的理解 注意事项 # 建议建立一个自己的统一且良好的代码风格，比如命名风格（camelCase、snake_case 等）、缩进方式（空格数量、switch-case 缩不缩进等）、开闭大括号换不换行等容易引发战 争（迫真）的东西，以养成良好的编程习惯。
编程题最好为每一个类编写一个完备的测试类，覆盖尽可能多的输入、函数调用、输出，以证明代码正确实现了功能。
如果编程题使用了 package 语句，应当确保提交时目录结构和 package 语句表达的包结构相同。（IDE 很多时候会帮你做）
编程题在给出了具体需求的情况下，可以根据自己的需要添加额外的方法。
实验题目 # 初始化 I # 阅读下面这段代码，尝试理解 Java 中初始化的顺序：
class A { int value; static A a1 = new A(1); public A(int i) { System.out.println(&amp;#34;initialize A&amp;#34;+i); value = i; } public A(A a) { System.out.println(&amp;#34;copy from A&amp;#34;+a.value); value = a.value; } static A a2 = new A(2); } class B { A a8; // A a7 = new A(a6); A a6 = new A(6); static A a3 = new A(3); static A a4; static { a4 = new A(4); } static A a5 = new A(5); public B(int i) { System.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB05/</guid><description>Java 程序设计 LAB05 # 实验目的 # 理解继承的必要性 理解继承的基本概念：单继承，多继承 掌握继承的使用 子类属性、构造方法和一般成员方法的书写的编写 变量隐藏 this 和 super 的使用 向上映射 在继承的基础上加深理解权限控制符的使用 保护成员的使用 方法覆盖（初步，重点放在多态一章） 复合与继承的区别及使用 注意事项 # 建议建立一个自己的统一且良好的代码风格，比如命名风格（camelCase、snake_case等）、缩进方式（空格数量、switch-case 缩不缩进等）、开闭大括号换不换行等容易引发战争（迫真）的东西，以养成良好的编程习惯。编程题最好为每一个类编写一个完备的测试类，覆盖尽可能多的输入、函数调用、输出，以证明代码正确实现了功能。如果编程题使用了 package 语句，应当确保提交时目录结构和 package 语句表达的包结构相同。（IDE 很多时候会帮你做）编程题在给出了具体需求的情况下，可以根据自己的需要添加额外的方法。
大家可以在 vscode、IDEA 等 IDE 上找到对应的代码风格检查工具，也可以自己设置自己的代码风格文件，可自行搜索了解 例如： vscode 插件 checkstyle
实验题目 # Question1. Package # 浏览 Code 文件夹中的 Question01 目录，不允许变更目录结构和文件位置，只允许在文件中添加 package 和 import 语句，使根目录下 build 和 test 文件中的指令可以无报错顺利执行。
建议通过右键 Question01 文件夹以 vscode、IDEA等IDE打开，或直接在IDE内打开 Question01 文件夹，以确保构建正确的项目结构，下同。
Question2. 权限 # 阅读 Code 文件夹中的 Question02 目录，根据你对访问权限的理解。将文件中所有无法通过编译的语句注释掉。</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB06/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB06/</guid><description>Java 程序设计 LAB06 # 实验目的 # 理解静多态和动多态的概念 理解多态的必要性和实现机制 理解并灵活使用方法重载和方法覆盖 理解并灵活使用抽象类和抽象方法 理解接口的必要性（将接口用作 API） 掌握如何定义接口、实现接口 将接口用作类型、使用接口回调 理解并掌握接口的继承 面向接口的编程 简单了解 Object 类 掌握良好重写 Object 类中方法的能力 实验题目 # Question01 多态 1 输出/简答题 # 阅读下面这段代码：
// Test.java class PrivateOverride { private void f() { System.out.println(&amp;#34;private f()&amp;#34;); } public static void main(String[] args) { PrivateOverride po = new Derived(); po.f(); } } class Derived extends PrivateOverride { public void f() { System.out.println(&amp;#34;public f()&amp;#34;); } } public class Test { public static void main(String[] args) { PrivateOverride.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB07/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB07/</guid><description>Java 程序设计 LAB07 # 实验目的 # 简单了解 Object 类 掌握良好重写 Object 类中方法的能力 简单了解内部类、匿名类 实验题目 # 本实验假设你明白：
涉及内部类时的初始化过程 内部类能够访问其外部类的所有属性和方法 构造内部类必须先构造外部类对象 嵌套类（静态内部类）只能够访问外部类的静态属性和方法 嵌套类可以直接通过类名构造 匿名内部类和局部内部类中直接使用的外部数据必须是 final 的（除非是匿名类的方法 的参数） 上述这些语法层面的东西，可以尝试自行证明。 本次实验不会涉及以下内部类的常用技巧：
回调与闭包 事件与控制框架 也不会涉及以下内部类的边角情况：
内部类的继承与覆盖 多重嵌套的内部类 Question01 InnerClass1 代码填空 # 阅读下面这段代码：
class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(/*???*/); System.out.println(/*???*/); System.out.println(/*???*/); } } } public class Test { public static void main(String[] args) { Outer.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/Lab08/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/Lab08/</guid><description>Java 程序设计 LAB08 # 实验目的 # 理解集合框架的设计思路
了解 Java 常用的数据结构类及其使用，重点迭代器(Iterator) 、线性表（List、ArrayList、LinkedList）、HashMap 类、HashSet 类及枚举类在企业级软件编写中经常用到，要求在理解的基础上，熟练掌握
理解泛型的概念、必要性并能够灵活使用
实验题目 # Question1 简述ArrayList和LinkedList的区别 简答 # Question2 写出以下程序的输出 简答 # //Animal.java public class Animal { public Animal(){ System.out.println(&amp;#34;I am an animal&amp;#34;); } } //Dog.java public class Dog extends Animal{ public Dog(){ System.out.println(&amp;#34;I am a dog&amp;#34;); } } //AnimalTest.java public class AnimalTest { public &amp;lt;T,S extends T&amp;gt; T testDemo(T t,S s){ System.out.println(&amp;#34;I am type T and my type is &amp;#34;+t.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB09/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB09/</guid><description>Java 程序设计 LAB09 # 实验目的 # 掌握异常处理机制 掌握使用 try…catch…finally 处理异常 掌握使用 throws 关键字 掌握使用 throw 关键字 创建用户自定义异常，并处理这种异常 实验题目 # Question1 Java中的检查型异常 (checked exception) 和非检查型异常 (unchecked exception) 有什么区别？ 简答 # Question2 简述Java异常处理中 throws 和 throw 关键字的作用。 简答 # Question3 请列出2个常见的运行时异常和2个非运行时异常。 简答 # Question4 指出下列程序的错误并改正。 改错 # import java.io.IOException; public class p04 { public static void start() throws IOException,RuntimeException{ throw new RuntimeException(&amp;#34;Unable to Start&amp;#34;); } public static void main(String[] args){ try{ start(); }catch (Exception ex){ ex.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB10/</guid><description>Java 程序设计 LAB10 # 实验目的 # 理解并掌握控制台读入数据、标准输入输出、Scanner类（基础的输入输出）
理解并掌握Java文件管理（File类）、输入/输出流类及其派生类的使用（字节流的顺序读写）
理解并掌握读写器及其派生类的使用（字符流的顺序读写）
理解并掌握对象序列化（对象流的读写）
实验题目 # Question1 如果准备按字节读取一个文件的内容，应当使用 FileInputStream 流还是 FileReader 流，为什么？ 简答 # Question2 简答 # import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileInputStreamTest { public static void main(String[] args) { File f =new File(&amp;#34;hello.txt&amp;#34;); byte [] a=&amp;#34;abcd&amp;#34;.getBytes(); try{ FileOutputStream out=new FileOutputStream(f); out.write(a); out.close(); FileInputStream in=new FileInputStream(f); byte [] tom= new byte[3]; //Part Ⅰ int m = in.read(tom,0,3); System.out.println(m);//3 String s=new String(tom,0,3); System.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/LAB11/</guid><description>Java 程序设计 LAB11 # 实验目的 # 理解程序、进程和多线程概念及特点
理解线程的状态、生命周期及调度策略
理解并掌握线程类 Thread 和 Runnable 接口，并能够进行相关应用的程序设计，实现多线程编程
实验题目 # Question1 简述程序，进程，线程的概念 简答 # Question2 产生死锁的四个条件是什么？ 简答 # Question3 创建线程的两种方式分别是什么？各有什么优缺点 简答 # Question4 判断题 # (1) 进程是线程 Thread 内部的一个执行单元，它是程序中一个单一顺序控制流程。
(2) 一个进程可以包括多个线程。两者的一个主要区别是：线程是资源分配的单位，而进程是CPU调度和执行的单位。
(3) 线程可以用 yield 使低优先级的线程运行。
(4) 当一个线程进入一个对象的一个 synchronized 方法后，其它线程可以再进入该对象的其它同步方法执行。
(5) notify 是唤醒所在对象 wait pool 中的第一个线程。
Question5 程序输出简答 # public class Main { public static void main(String[] args) { SyncThread syncThread = new SyncThread(); Thread thread1 = new Thread(syncThread, &amp;#34;SyncThread1&amp;#34;); Thread thread2 = new Thread(syncThread, &amp;#34;SyncThread2&amp;#34;); thread1.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/TEMPLATE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/OOP-LAB/TEMPLATE/</guid><description> Lab XX Assignment # 班级：
学号：
姓名：
提交要求（以下内容在最终提交的作业中可以删除，仅作参考） # 目录格式
-- 班级-学号-姓名-LabXX.zip |-- answer.pdf |-- solution |-- Question1 |-- 题1的代码文件(如果需要) |-- Question2 |-- 题2的代码文件(如果需要) |-- ...</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-1/</guid><description>MySCS -1 # 同学们，从这周开始，我们会迭代完成一个MySCS，即从零开发的软件学院云平台（青春版）。
我们每两周会增加一次新的需求，如，MySCS-1需要大家完成账号注册和登录系统，MySCS-2需要大家在1的基础上添加课程系统或其它系统等。
编写好的代码需要大家用patpat评测，所有测试点都通过以后即可上传到云平台完成本次实验。希望大家认真完成哦！请勿抄袭，抄袭会被查到的（盯
题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全自主知识产权，有极大的使用价值和收藏价值。
MySCS分为教师端和学生端，可以实现传统scs的大部分功能，如教师端对课程的增删改查，对课程所属的实验的增删改查，教师还可以为课程添加学生和助教，学生可以查看参与的课程并提交实验作业，助教可以协同老师管理课程等。
命令概览 # 命令行 功能 输出 QUIT 系统关机 &amp;mdash;&amp;ndash; Good Bye! &amp;mdash;&amp;ndash; register 学工号 名 姓 邮箱 密码 确认密码 注册 register success
already logged in
user id illegal
user id duplication
user name illegal
email address illegal
password illegal
passwords inconsistent login 学工号 密码 登录 Hello 名~
Hello Professor 姓~
already logged in
user id illegal
user id not exist</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-2/</guid><description>MySCS-2 # 同学们，我们用了两周时间完成了MySCS的部分功能，已经实现了老师端和学生端的登录注册。
我们每两周会增加一次新的需求，MySCS-2需要大家在MySCS-1的基础上完成管理端的基础命令，MySCS-3需要大家在2的基础上添加学生操作以及其他功能等。（挖坑
编写好的代码需要大家用patpat评测，所有测试点都通过以后即可上传到云平台完成本次实验。希望大家认真完成哦！请勿抄袭，抄袭会被查到的（盯
题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全的自主知识产权，有极大的使用价值和收藏价值。
MySCS分为管理端（老师端和助教端）和学生端，可以实现传统的scs的大部分功能。本此实验将完成管理端的基础操作，需要基于MySCS-1编写（建议备份一下MySCS-1，然后拷贝一下来搭MySCS-2）。
命令概览 # 命令行 功能 输出 addCourse 课程号 课程名称 添加课程（老师端） add course success removeCourse 课程号 移除课程（老师端） remove course success listCourse 列出课程（老师端） [ID:课程编号] [Name:课程名称] [TeacherNum:老师人数] [AssistantNum:助教人数] [StudentNum:学生人数] selectCourse 课程号 选择课程（管理端） select course success addAdmin 学工号 学工号 &amp;hellip; 添加课程管理端成员（老师端） add admin success removeAdmin 学工号 移除课程管理端成员（老师端） remove admin success listAdmin 列出课程管理端成员（管理端） [ID:学工号] [Name:姓 名] [Type:用户身份(Professor/Assistant)] [Email:电子邮箱] changeRole 有助教身份的学生切换身份 change into Assistant success
change into Student success addWare 资料编号 资料名称 添加课程资料（老师端） add ware success removeWare 资料编号 移除课程资料（老师端） remove ware success listWare 列出课程资料（管理端） [ID:课程资料编号] [Name:课程资料名称] addTask 作业编号 作业名称 作业开始时间 作业截至时间 添加课程作业（管理端） add task success removeTask 作业编号 移除课程作业（管理端） remove task success listTask 列出课程作业（管理端） [ID:课程作业编号] [Name:课程作业名称] [ReceiveNum:接收作业份数] [StartTime:开始时间] [EndTime:截止时间] addStudent 学工号 学工号 &amp;hellip; 添加课程学生（管理端） add student success removeStudent 学工号 移除课程学生（管理端） remove student success listStudent 列出课程学生（管理端） [ID:学工号] [Name:姓 名] [Email:电子邮箱] 功能描述 # 0.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-3/</guid><description>MySCS-3 # 同学们，在上一次的迭代中，我们已经完成了管理端的命令开发，接下来我们需要完成学生端的命令了。
编写好的代码需要使用patpat进行评测，AC后即可上传到云平台以完成本次的实验内容。希望大家认真且保质保量的完成，请勿抄袭，如有发现抄袭现象将取消迭代作业成绩。
题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全的自主知识产权，有极大的使用价值和收藏价值。本平台模拟一台操作机上的命令行，所有操作均在本地进行，不支持联网操作，同一时间的使用者有且仅有一个。
MySCS分为管理端（老师端和助教端）和学生端，可以实现传统的scs的大部分功能。本次迭代需要完成的内容为学生端命令的开发，请尽可能直接基于AC后的MySCS-2代码编写，否则可能发生其他异常情况，另外注意此前迭代AC了也不能确保你的程序是完全正确的。
注意在这次的迭代中修改了部分输出格式，同时也为部分之前的命令增添了新的功能。
整体约束 # 当输入的命令未定义时，输出
command &amp;#39;$命令&amp;#39; not found 例如： 输入 loggin 19375030 123456
由于命令 loggin 未定义，所以输出 command 'loggin' not found
若以下 功能描述中有明确给出输出顺序，则以它为准
若不满足第二条，则保持原输出顺序不改变
当输入的命令有定义，但是参数的个数不合法要求时，输出
arguments illegal 输入： login 19375030 123456 haha 和 login 19375030 都对应着 arguments illegal
当命令有定义，参数个数正确时，才会输出 Bye~ 或者 user id illegal 等成功或失败输出
当一句命令存在多种非法情况，按上述顺序只输出最先发生的非法信息
例如，注册时学号和姓名均非法，按上述顺序，输出 user id illegal，而不是user name illegal
评测时，请将所有文件放到patpat可执行文件相同路径下。例如：
MySCS\example ├─LAB1.md ├─Lesson1.txt ├─19376054.task ├─T191743.ans ├─patpat.exe ├─3-学号-姓名 │ ├─out │ └─src │ └─Test.</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/MySCS/MySCS-4/</guid><description>MySCS-4 # 编写好的代码需要使用patpat进行评测，AC后即可上传到云平台以完成本次的实验内容。希望大家认真且保质保量的完成，请勿抄袭，如有发现抄袭现象将取消迭代作业成绩。
题目背景 # 软件学院云平台（青春版），即MySCS，是一款更加轻量化的命令行操作的云平台，屏幕前的你拥有完全的自主知识产权，有极大的使用价值和收藏价值。本平台模拟一台操作机上的命令行，所有操作均在本地进行，不支持联网操作，同一时间的使用者有且仅有一个。
本次迭代主要依托于MySCS2，仅涉及MySCS3中学生选择课程相关的操作。
整体约束 # 本次迭代将不再重复考察此前类关系设计、错误处理等，而是将重点放置在对面向对象特性的考察。MYSCS4题目复杂性大大降低。如果同学们能够认真完成Lab，实现起来将会非常轻松。在本次题目中，我们将对程序实现提出一些具体类设计提示（当然这也是为了辅助同学们能够更轻松地实现题目需求），若同学们基于自己的类设计能有更好的实现也当然可以。
注意： 你不需要考虑任何错误数据，评测保证所有数据均为合法数据。
总体说明 # 你需要了解的： # 序列化与反序列化
Java 序列化就是指把 Java 对象转换为字节序列的过程
Java 反序列化就是指把字节序列恢复为 Java 对象的过程。
序列化最重要的作用：在传递和保存对象时，保证对象的完整性和可传递性。对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。
反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。
总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）
在本次迭代中，我们简化了传递这一过程。在本机中，由 A 学生将自己的虚拟机对象保存为序列化文件，再由 B 学生读取序列化文件，并反序列化生成虚拟机对象并持有。
可供参考：
理论：https://blog.csdn.net/weixin_45433031/article/details/115364830
实践：https://www.cnblogs.com/com-Jacob/p/16207339.html
例如你实例化了一个对象，名字为小明，此时这个小明对象只在你程序运行期间存在，运行结束后就消失了，但是你可以通过序列化，将小明对象转换为字节序列（在运行期间这个对象本质也只是一串数据）存储到本地文件中，之后即可通过反序列化将这个文件中存储的字节序列转换回一个名字叫小明的对象。
命令概览 # 命令 功能描述 requestVM 系统类型 申请虚拟机 startVM 启动虚拟机 clearVM 机器编号 清空虚拟机 logVM 查看历史指令 uploadVM 路径 上传虚拟机 downloadVM 路径 下载虚拟机 功能描述 # 申请虚拟机 # 命令 参数 requestVM 系统类型 使用对象：学生端
功能：根据系统类型在当前课程下申请虚拟机，其中系统类型仅有三种可能：Windows, Linux, MacOS。</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/Q-A/%E7%AC%AC%E4%B8%80%E6%9C%9F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/Q-A/%E7%AC%AC%E4%B8%80%E6%9C%9F/</guid><description>OOP实验猪脚说——第一期 # 前言 # 因为同学们的共性问题非常多，所以各位助教（猪脚）总结并写了下来方便各位查阅，不定期更新，希望能帮到大家。
迭代实验 # 前置步骤 # Windows用户 # 下载群内提供的patpat示例教程.zip并解压，使用方式在其中的README.md中有详细说明。为了防止大家懒得看，也可以看接下来的步骤；
patpat-windows-amd64.exe需要重新命名为patpat.exe；
在patpat示例教程下打开终端（命令行）运行如下命令：
./patpat reg -sid your_sid -pwd your_password # 如./patpat reg -sid 18373722 -pwd buaa-se-oop 账号创建后，密码不支持修改。如需修改，请联系助教。
macOS或Linux用户 # 下载群内提供的patpat示例教程.zip并解压，使用方式在其中的README.md中有详细说明。为了防止大家懒得看，也可以看接下来的步骤；
下载群内提供的patpat各版本.zip并解压，选择正确的版本移入patpat示例教程文件夹中，替换并删除掉原有的patpat-windows-amd64.exe；
替换后的文件需要重新命名为patpat；
在patpat示例教程下打开终端（命令行）运行chmod +x patpat，使评测机程序具有可执行权限；
在patpat示例教程下打开终端（命令行）运行如下命令：
./patpat reg -sid your_sid -pwd your_password # 如./patpat reg -sid 18373722 -pwd buaa-se-oop 账号创建后，密码不支持修改。如需修改，请联系助教。
实验具体流程 # 编写完迭代作业的代码；
建立一个n-学号-姓名的文件夹在patpat示例教程下，其内建立out文件夹（out是n-学号-姓名文件夹的子孙）；
把你idea中的src文件夹直接复制粘入n-学号-姓名中 （src是out的兄弟）；
终端（命令行）中运行
./patpat ta -judge 1-学号-姓名 -pwd your_pwd -tag 随意打一些文字，可以用来标注第几次尝试 # 线上测试命令 命令（不是stu命令不是stu命令不是stu命令，自己编写测试文件和stu自测基本上用不到，只是提供了这么个功能，完全没必要用，我上次就没用过）；</description></item><item><title/><link>https://ryouonritsu.github.io/Java-HomeWork/docs/Resource/Java8-17%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ryouonritsu.github.io/Java-HomeWork/docs/Resource/Java8-17%E8%AF%AD%E6%B3%95%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</guid><description>Java8-17语法新特性总结 # 班级：202115
学号：19377054
姓名：周洪熙
Java 8 # Interface # interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，interface 修改的时候，实现它的类也必须跟着改。
为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用 default 或 static 修饰，这样就可以有方法体，实现类也不必重写此方法。
一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。
default 修饰的方法，是普通实例方法，可以用this调用，可以被子类继承、重写。
static 修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用Interface调用。 我们来看一个实际的例子。
public interface InterfaceNew { static void sm() { System.out.println(&amp;#34;interface提供的方式实现&amp;#34;); } static void sm2() { System.out.println(&amp;#34;interface提供的方式实现&amp;#34;); } default void def() { System.out.println(&amp;#34;interface default方法&amp;#34;); } default void def2() { System.out.println(&amp;#34;interface default2方法&amp;#34;); } //须要实现类重写 void f(); } public interface InterfaceNew1 { default void def() { System.</description></item></channel></rss>